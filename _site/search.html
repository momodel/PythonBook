<!DOCTYPE html>
<html lang="en">
  

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width,minimum-scale=1">

  <title>Search the site</title>
  <meta name="description" content="Python入门教程">

  <link rel="canonical" href="http://0.0.0.0:4000//search">
  <link rel="alternate" type="application/rss+xml" title="Python 教程" href="http://0.0.0.0:4000//feed.xml">

  <meta property="og:url"         content="http://0.0.0.0:4000//search" />
<meta property="og:type"        content="article" />
<meta property="og:title"       content="Search the site" />
<meta property="og:description" content="Python入门教程" />
<meta property="og:image"       content="" />


  <script type="application/ld+json">
  {
  "@context": "http://schema.org",
  "@type": "NewsArticle",
  "mainEntityOfPage":
    "http://0.0.0.0:4000//search",
  "headline":
    "Search the site",
  "datePublished":
    "2019-08-08T11:31:33-05:00",
  "dateModified":
    "2019-08-08T11:31:33-05:00",
  "description":
    "Python入门教程",
  "author": {
    "@type": "Person",
    "name": "Momodel Team"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Data 100 at UC Berkeley",
    "logo": {
      "@type": "ImageObject",
      "url": "http://0.0.0.0:4000/",
      "width": 60,
      "height": 60
    }
  },
  "image": {
    "@type": "ImageObject",
    "url": "http://0.0.0.0:4000/",
    "height": 60,
    "width": 60
  }
}

  </script>
  <link rel="stylesheet" href="/assets/css/styles.css">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css ">
  <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">

  <!-- <link rel="manifest" href="/manifest.json"> -->
  <!-- <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#efae0a"> -->
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="msapplication-TileImage" content="/mstile-144x144.png">
  <meta name="theme-color" content="#233947">

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/x-icon" href="/images/logo/Python.png">

  <!-- MathJax Config -->
  <!-- Allow inline math using $ and automatically break long math lines -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    CommonHTML: {
        linebreaks: {
            automatic: true,
        },
    },
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_CHTML' async></script>

  <!-- DOM updating function -->
  <script>
const runWhenDOMLoaded = cb => {
  if (document.readyState != 'loading') {
    cb()
  } else if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', cb)
  } else {
    document.attachEvent('onreadystatechange', function() {
      if (document.readyState == 'complete') cb()
    })
  }
}

// Helper function to init things quickly
initFunction = function(myfunc) {
  runWhenDOMLoaded(myfunc);
  document.addEventListener('turbolinks:load', myfunc);
};
</script>

  <!-- Define some javascript variables that will be useful in other javascript -->
  <script>
    const site_basename = '/';
  </script>

  <!-- Add AnchorJS to let headers be linked -->
  <script src="/assets/js/anchor.min.js"  type="text/javascript"></script>
  <script>

initFunction(function () {
    anchors.add("main h1, main h2, main h3, main h4")
});

</script>

  <!-- Include Turbolinks to make page loads fast -->
  <!-- https://github.com/turbolinks/turbolinks -->
  <script src="/assets/js/turbolinks.js" async></script>
  <meta name="turbolinks-cache-control" content="no-cache">

  <!-- Load nbinteract for widgets -->
  

  <!-- Load Thebelab for interactive widgets -->
  <!-- Include Thebelab for interactive code if it's enabled -->


<!-- Display Thebelab button in each code cell -->
<script>
/**
 * Set up thebelab button for code blocks
 */

const thebelabCellButton = id =>
  `<a id="thebelab-cell-button-${id}" class="btn thebebtn o-tooltip--left" data-tooltip="Interactive Mode">
    <img src="/assets/images/edit-button.svg" alt="Start interactive mode">
  </a>`


const addThebelabButtonToCodeCells =  () => {

  const codeCells = document.querySelectorAll('div.input_area > div.highlighter-rouge:not(.output) pre')
  codeCells.forEach((codeCell, index) => {
    const id = codeCellId(index)
    codeCell.setAttribute('id', id)
    if (document.getElementById("thebelab-cell-button-" + id) == null) {
      codeCell.insertAdjacentHTML('afterend', thebelabCellButton(id));
    }
  })
}

initFunction(addThebelabButtonToCodeCells);
</script>



<script type="text/x-thebe-config">
    {
      requestKernel: true,
      binderOptions: {
        repo: 'momodel/Pythonbook',
        ref: 'master',
      },
      codeMirrorConfig: {
        theme: "abcdef"
      },
      kernelOptions: {
        name: 'python3',
      }
    }
</script>
<script src="https://unpkg.com/thebelab@0.4.0/lib/index.js"></script>
<script>
    /**
     * Add attributes to Thebelab blocks
     */

    const initThebelab = () => {
        const addThebelabToCodeCells = () => {
            console.log("Adding thebelab to code cells...");
            // If Thebelab hasn't loaded, wait a bit and try again. This
            // happens because we load ClipboardJS asynchronously.
            if (window.thebelab === undefined) {
                setTimeout(addThebelabToCodeCells, 250)
            return
            }

            // If we already detect a Thebelab cell, don't re-run
            if (document.querySelectorAll('div.thebelab-cell').length > 0) {
                return;
            }

            // Find all code cells, replace with Thebelab interactive code cells
            const codeCells = document.querySelectorAll('.input_area pre')
            codeCells.forEach((codeCell, index) => {
                const id = codeCellId(index)
                codeCell.setAttribute('data-executable', 'true')

                // Figure out the language it uses and add this too
                var parentDiv = codeCell.parentElement.parentElement;
                var arrayLength = parentDiv.classList.length;
                for (var ii = 0; ii < arrayLength; ii++) {
                    var parts = parentDiv.classList[ii].split('language-');
                    if (parts.length === 2) {
                        // If found, assign dataLanguage and break the loop
                        var dataLanguage = parts[1];
                        break;
                    }
                }
                codeCell.setAttribute('data-language', dataLanguage)

                // If the code cell is hidden, show it
                var inputCheckbox = document.querySelector(`input#hidebtn${codeCell.id}`);
                if (inputCheckbox !== null) {
                    setCodeCellVisibility(inputCheckbox, 'visible');
                }
            });

            // Remove the event listener from the page so keyboard press doesn't
            // Change page
            document.removeEventListener('keydown', initPageNav)
            keyboardListener = false;

            // Init thebelab
            thebelab.bootstrap();

            // Remove copy buttons since they won't work anymore
            const copyAndThebeButtons = document.querySelectorAll('.copybtn, .thebebtn')
            copyAndThebeButtons.forEach((button, index) => {
                button.remove();
            });

            // Remove outputs since they'll be stale
            const outputs = document.querySelectorAll('.output *, .output')
            outputs.forEach((output, index) => {
                output.remove();
            });
        }

        // Add event listener for the function to modify code cells
        const thebelabButtons = document.querySelectorAll('[id^=thebelab], [id$=thebelab]')
        thebelabButtons.forEach((thebelabButton,index) => {
            if (thebelabButton === null) {
                setTimeout(initThebelab, 250)
                return
            };
            thebelabButton.addEventListener('click', addThebelabToCodeCells);
        });
    }

    // Initialize Thebelab
    initFunction(initThebelab);
</script>



  <!-- Load the auto-generating TOC -->
  <script src="/assets/js/tocbot.min.js"  type="text/javascript"></script>
  <script>
var initToc = function () {
  tocbot.init({
    tocSelector: 'nav.onthispage',
    contentSelector: '.c-textbook__content',
    headingSelector: 'h2, h3',
    orderedList: false,
    collapseDepth: 6,
    listClass: 'toc__menu',
    activeListItemClass: "",  // Not using
    activeLinkClass: "", // Not using
  });
  tocbot.refresh();
}
initFunction(initToc);
</script>

  <!-- Google analytics -->
  <script src="/assets/js/ga.js" async></script>

  <!-- Clipboard copy button -->
  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" async></script>

  <!-- Load JS that depends on site variables -->
  <script>
/**
 * Set up copy/paste for code blocks
 */
const codeCellId = index => `codecell${index}`

const clipboardButton = id =>
  `<a id="copy-button-${id}" class="btn copybtn o-tooltip--left" data-tooltip="Copy" data-clipboard-target="#${id}">
    <img src="/assets/images/copy-button.svg" alt="Copy to clipboard">
  </a>`

// Clears selected text since ClipboardJS will select the text when copying
const clearSelection = () => {
  if (window.getSelection) {
    window.getSelection().removeAllRanges()
  } else if (document.selection) {
    document.selection.empty()
  }
}

// Changes tooltip text for two seconds, then changes it back
const temporarilyChangeTooltip = (el, newText) => {
  const oldText = el.getAttribute('data-tooltip')
  el.setAttribute('data-tooltip', newText)
  setTimeout(() => el.setAttribute('data-tooltip', oldText), 2000)
}

const addCopyButtonToCodeCells = () => {
  // If ClipboardJS hasn't loaded, wait a bit and try again. This
  // happens because we load ClipboardJS asynchronously.
  if (window.ClipboardJS === undefined) {
    setTimeout(addCopyButtonToCodeCells, 250)
    return
  }

  const codeCells = document.querySelectorAll('div.c-textbook__content > div.highlighter-rouge > div.highlight > pre, div.input_area pre')
  codeCells.forEach((codeCell, index) => {
    const id = codeCellId(index)
    codeCell.setAttribute('id', id)
    if (document.getElementById("copy-button" + id) == null) {
      codeCell.insertAdjacentHTML('afterend', clipboardButton(id));
    }
  })

  const clipboard = new ClipboardJS('.copybtn')
  clipboard.on('success', event => {
    clearSelection()
    temporarilyChangeTooltip(event.trigger, 'Copied!')
  })

  clipboard.on('error', event => {
    temporarilyChangeTooltip(event.trigger, 'Failed to copy')
  })

  // Get rid of clipboard before the next page visit to avoid memory leak
  document.addEventListener('turbolinks:before-visit', () =>
    clipboard.destroy()
  )
}

initFunction(addCopyButtonToCodeCells);
</script>


  <!-- Hide cell code -->
  
<script>
/**
Add buttons to hide code cells
*/


var setCodeCellVisibility = function(inputField, kind) {
    // Update the image and class for hidden
    var id = inputField.getAttribute('data-id');
    var codeCell = document.querySelector(`#${id} div.highlight`);

    if (kind === "visible") {
        codeCell.classList.remove('hidden');
        inputField.checked = true;
    } else {
        codeCell.classList.add('hidden');
        inputField.checked = false;
    }
}

var toggleCodeCellVisibility = function (event) {
    // The label is clicked, and now we decide what to do based on the input field's clicked status
    if (event.target.tagName === "LABEL") {
        var inputField = event.target.previousElementSibling;
    } else {
        // It is the span inside the target
        var inputField = event.target.parentElement.previousElementSibling;
    }

    if (inputField.checked === true) {
        setCodeCellVisibility(inputField, "visible");
    } else {
        setCodeCellVisibility(inputField, "hidden");
    }
}


// Button constructor
const hideCodeButton = id => `<input class="hidebtn" type="checkbox" id="hidebtn${id}" data-id="${id}"><label title="Toggle cell" for="hidebtn${id}" class="plusminus"><span class="pm_h"></span><span class="pm_v"></span></label>`

var addHideButton = function () {
  // If a hide button is already added, don't add another
  if (document.querySelector('div.hidecode input') !== null) {
      return;
  }

  // Find the input cells and add a hide button
  document.querySelectorAll('div.input_area').forEach(function (item, index) {
    if (!item.classList.contains("hidecode")) {
        // Skip the cell if it doesn't have a hidecode class
        return;
    }

    const id = codeCellId(index)
    item.setAttribute('id', id);
    // Insert the button just inside the end of the next div
    item.querySelector('div').insertAdjacentHTML('beforeend', hideCodeButton(id))

    // Set up the visibility toggle
    hideLink = document.querySelector(`#${id} div.highlight + input + label`);
    hideLink.addEventListener('click', toggleCodeCellVisibility)
  });
}


// Initialize the hide buttos
var initHiddenCells = function () {
    // Add hide buttons to the cells
    addHideButton();

    // Toggle the code cells that should be hidden
    document.querySelectorAll('div.hidecode input').forEach(function (item) {
        setCodeCellVisibility(item, 'hidden');
        item.checked = true;
    })
}

initFunction(initHiddenCells);

</script>


  <!-- Load custom website scripts -->
  <script src="/assets/js/scripts.js" async></script>

  <!-- Load custom user CSS and JS  -->
  <script src="/assets/custom/custom.js" async></script>
  <link rel="stylesheet" href="/assets/custom/custom.css">

  <!-- Update interact links w/ REST param, is defined in includes so we can use templates -->
  
<script>
/**
  * To auto-embed hub URLs in interact links if given in a RESTful fashion
 */

function getJsonFromUrl(url) {
  var query = url.split('?');
  if (query.length < 2) {
    // No queries so just return false
    return false;
  }
  query = query[1];
  // Collect REST params into a dictionary
  var result = {};
  query.split("&").forEach(function(part) {
    var item = part.split("=");
    result[item[0]] = decodeURIComponent(item[1]);
  });
  return result;
}
    
function dict2param(dict) {
    params = Object.keys(dict).map(function(k) {
        return encodeURIComponent(k) + '=' + encodeURIComponent(dict[k])
    });
    return params.join('&')
}

// Parse a Binder URL, converting it to the string needed for JupyterHub
function binder2Jupyterhub(url) {
  newUrl = {};
  parts = url.split('v2/gh/')[1];
  // Grab the base repo information
  repoinfo = parts.split('?')[0];
  var [org, repo, ref] = repoinfo.split('/');
  newUrl['repo'] = ['https://github.com', org, repo].join('/');
  newUrl['branch'] = ref
  // Grab extra parameters passed
  params = getJsonFromUrl(url);
  if (params['filepath'] !== undefined) {
    newUrl['subPath'] = params['filepath']
  }
  return dict2param(newUrl);
}

// Filter out potentially unsafe characters to prevent xss
function safeUrl(url)
{
   return String(encodeURIComponent(url))
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
}

function addParamToInternalLinks(hub) {
  var links = document.querySelectorAll("a").forEach(function(link) {
    var href = link.href;
    // If the link is an internal link...
    if (href.search("http://0.0.0.0:4000") !== -1 || href.startsWith('/') || href.search("127.0.0.1:") !== -1) {
      // Assume we're an internal link, add the hub param to it
      var params = getJsonFromUrl(href);
      if (params !== false) {
        // We have REST params, so append a new one
        params['jupyterhub'] = hub;
      } else {
        // Create the REST params
        params = {'jupyterhub': hub};
      }
      // Update the link
      var newHref = href.split('?')[0] + '?' + dict2param(params);
      link.setAttribute('href', decodeURIComponent(newHref));
    }
  });
  return false;
}


// Update interact links
function updateInteractLink() {
    // hack to make this work since it expects a ? in the URL
    rest = getJsonFromUrl("?" + location.search.substr(1));
    jupyterHubUrl = rest['jupyterhub'];
    var hubType = null;
    var hubUrl = null;
    if (jupyterHubUrl !== undefined) {
      hubType = 'jupyterhub';
      hubUrl = jupyterHubUrl;
    }

    if (hubType !== null) {
      // Sanitize the hubUrl
      hubUrl = safeUrl(hubUrl);

      // Add HTTP text if omitted
      if (hubUrl.indexOf('http') < 0) {hubUrl = 'http://' + hubUrl;}
      var interactButtons = document.querySelectorAll("button.interact-button")
      var lastButton = interactButtons[interactButtons.length-1];
      var link = lastButton.parentElement;

      // If we've already run this, skip the link updating
      if (link.nextElementSibling !== null) {
        return;
      }

      // Update the link and add context div
      var href = link.getAttribute('href');
      if (lastButton.id === 'interact-button-binder') {
        // If binder links exist, we need to re-work them for jupyterhub
        if (hubUrl.indexOf('http%3A%2F%2Flocalhost') > -1) {
          // If localhost, assume we're working from a local Jupyter server and remove `/hub`
          first = [hubUrl, 'git-sync'].join('/')
        } else {
          first = [hubUrl, 'hub', 'user-redirect', 'git-sync'].join('/')
        }
        href = first + '?' + binder2Jupyterhub(href);
      } else {
        // If interact button isn't binderhub, assume it's jupyterhub
        // If JupyterHub links, we only need to replace the hub url
        href = href.replace("", hubUrl);
        if (hubUrl.indexOf('http%3A%2F%2Flocalhost') > -1) {
          // Assume we're working from a local Jupyter server and remove `/hub`
          href = href.replace("/hub/user-redirect", "");
        }
      }
      link.setAttribute('href', decodeURIComponent(href));

      // Add text after interact link saying where we're launching
      hubUrlNoHttp = decodeURIComponent(hubUrl).replace('http://', '').replace('https://', '');
      link.insertAdjacentHTML('afterend', '<div class="interact-context">on ' + hubUrlNoHttp + '</div>');

      // Update internal links so we retain the hub url
      addParamToInternalLinks(hubUrl);
    }
}

runWhenDOMLoaded(updateInteractLink)
document.addEventListener('turbolinks:load', updateInteractLink)
</script>


  <!-- Lunr search code - will only be executed on the /search page -->
  <script src="/assets/js/lunr/lunr.min.js" type="text/javascript"></script>
  <script>var initQuery = function() {
  // See if we have a search box
  var searchInput = document.querySelector('input#lunr_search');
  if (searchInput === null) {
    return;
  }

  // Function to parse our lunr cache
  var idx = lunr(function () {
    this.field('title')
    this.field('excerpt')
    this.field('categories')
    this.field('tags')
    this.ref('id')

    this.pipeline.remove(lunr.trimmer)

    for (var item in store) {
      this.add({
        title: store[item].title,
        excerpt: store[item].excerpt,
        categories: store[item].categories,
        tags: store[item].tags,
        id: item
      })
    }
  });

  // Run search upon keyup
  searchInput.addEventListener('keyup', function () {
    var resultdiv = document.querySelector('#results');
    var query = document.querySelector("input#lunr_search").value.toLowerCase();
    var result =
      idx.query(function (q) {
        query.split(lunr.tokenizer.separator).forEach(function (term) {
          q.term(term, { boost: 100 })
          if(query.lastIndexOf(" ") != query.length-1){
            q.term(term, {  usePipeline: false, wildcard: lunr.Query.wildcard.TRAILING, boost: 10 })
          }
          if (term != ""){
            q.term(term, {  usePipeline: false, editDistance: 1, boost: 1 })
          }
        })
      });

      // Empty the results div
      while (resultdiv.firstChild) {
        resultdiv.removeChild(resultdiv.firstChild);
      }

    resultdiv.insertAdjacentHTML('afterbegin', '<p class="results__found">'+result.length+' Result(s) found</p>');
    for (var item in result) {
      var ref = result[item].ref;
      if(store[ref].teaser){
        var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<div class="archive__item-teaser">'+
                '<img src="'+store[ref].teaser+'" alt="">'+
              '</div>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      else{
    	  var searchitem =
          '<div class="list__item">'+
            '<article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">'+
              '<h2 class="archive__item-title" itemprop="headline">'+
                '<a href="'+store[ref].url+'" rel="permalink">'+store[ref].title+'</a>'+
              '</h2>'+
              '<p class="archive__item-excerpt" itemprop="description">'+store[ref].excerpt.split(" ").splice(0,20).join(" ")+'...</p>'+
            '</article>'+
          '</div>';
      }
      resultdiv.insertAdjacentHTML('beforeend', searchitem);
    }
  });
};

initFunction(initQuery);
</script>
</head>

  <body>
    <!-- .js-show-sidebar shows sidebar by default -->
    <div id="js-textbook" class="c-textbook js-show-sidebar">
      



<nav id="js-sidebar" class="c-textbook__sidebar">
  <a href="https://jupyter.org/jupyter-book/"><img src="/images/logo/Python.png" class="textbook_logo" id="sidebar-logo" data-turbolinks-permanent/></a>
  <h2 class="c-sidebar__title">Python 教程</h2>
  <ul class="c-sidebar__chapters">
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/intro.html"
        >
          
          目录
        </a>

        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="http://www.momodel.cn:8899/classroom"
        >
          
          Momodel repository
        </a>

        
      </li>

      
    
      
      
        <li class="c-sidebar__chapter"><a class="c-sidebar__entry" href="/search.html">查询</a></li>
        
      
      
        <li class="c-sidebar__divider"></li>
        
      
      
        <li><h2 class="c-sidebar__title">书籍内容</li>
        
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/01/features.html"
        >
          
          第1章 Python 介绍
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/01/01.html"
                >
                  
                  01-1 Python 简介
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/02/features.html"
        >
          
          第2章 Python基础
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/01.html"
                >
                  
                  02-01 Python 入门演示
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/02.html"
                >
                  
                  02-02 Python 数据类型
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/03.html"
                >
                  
                  02-03 Python 数字
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/04.html"
                >
                  
                  02-04 Python 字符串
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/05.html"
                >
                  
                  02-05 索引和切片
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/06.html"
                >
                  
                  02-06 列表
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/07.html"
                >
                  
                  02-07 可变和不可变类型
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/08.html"
                >
                  
                  02-08 元组
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/09.html"
                >
                  
                  02-09 列表与元组的速度比较
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/10.html"
                >
                  
                  02-10 字典
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/11.html"
                >
                  
                  02-11 集合
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/12.html"
                >
                  
                  02-12 不可变集合
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/13.html"
                >
                  
                  02-13 Python 赋值机制
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/14.html"
                >
                  
                  02-14 判断语句
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/15.html"
                >
                  
                  02-15 循环
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/16.html"
                >
                  
                  02-16 列表推导式
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/17.html"
                >
                  
                  02-17 函数
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/18.html"
                >
                  
                  02-18 模块和包
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/19.html"
                >
                  
                  02-19 异常
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/20.html"
                >
                  
                  02-20 警告
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/02/21.html"
                >
                  
                  02-21 文件读写
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/03/features.html"
        >
          
          第3章 Python 进阶
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/01.html"
                >
                  
                  03-01 sys 模块简介
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/02.html"
                >
                  
                  03-02 与操作系统进行交互 os 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/03.html"
                >
                  
                  03-03 CSV 文件和 csv 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/04.html"
                >
                  
                  03-04 正则表达式和 re 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/05.html"
                >
                  
                  03-05 datetime 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/06.html"
                >
                  
                  03-06 SQL 数据库
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/07.html"
                >
                  
                  03-07 对象关系映射
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/08.html"
                >
                  
                  03-08 函数进阶
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/09.html"
                >
                  
                  03-09 迭代器
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/10.html"
                >
                  
                  03-10 生成器
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/11.html"
                >
                  
                  03-11 with 语句和上下文管理器
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/12.html"
                >
                  
                  03-12 装饰器
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/13.html"
                >
                  
                  03-13 装饰器的使用
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/14.html"
                >
                  
                  03-14 Python 常用模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/15.html"
                >
                  
                  03-15 作用域
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/03/16.html"
                >
                  
                  03-16 动态编译
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/04/features.html"
        >
          
          第4章 Numpy
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/01.html"
                >
                  
                  04-01 Numpy 简介
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/02.html"
                >
                  
                  04-02 Matplotlib基础
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/03.html"
                >
                  
                  04-03 Numpy 数组及其索引
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/04.html"
                >
                  
                  04-04 数组类型
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/05.html"
                >
                  
                  04-05 数组方法
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/06.html"
                >
                  
                  04-06 数组排序
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/07.html"
                >
                  
                  04-07 数组形状
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/08.html"
                >
                  
                  04-08 对角线
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/09.html"
                >
                  
                  04-09 数组与字符串的转换
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/10.html"
                >
                  
                  04-10 数组属性方法总结
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/11.html"
                >
                  
                  04-11 生成数组的函数
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/12.html"
                >
                  
                  04-12 矩阵
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/13.html"
                >
                  
                  04-13 一般函数
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/14.html"
                >
                  
                  04-14 向量化函数
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/15.html"
                >
                  
                  04-15 二元运算
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/16.html"
                >
                  
                  04-16 ufunc 对象
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/17.html"
                >
                  
                  04-17 choose 函数
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/18.html"
                >
                  
                  04-18 数组广播机制
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/19.html"
                >
                  
                  04-19 数组读写
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/20.html"
                >
                  
                  04-20 结构化数组
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/21.html"
                >
                  
                  04-21 记录数组
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/22.html"
                >
                  
                  04-22 内存映射
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/04/23.html"
                >
                  
                  04-23 从 Matlab 到 Numpy
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/05/features.html"
        >
          
          第5章 Pandas
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/05/01.html"
                >
                  
                  05-01 十分钟上手 Pandas
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/05/02.html"
                >
                  
                  05-02 Series
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/05/03.html"
                >
                  
                  05-03 Dataframe
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/06/features.html"
        >
          
          第6章 Matplotlib
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/06/01.html"
                >
                  
                  06-01 Pyplot 教程
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/06/02.html"
                >
                  
                  06-02 使用 style 来配置 pyplot 风格
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/06/03.html"
                >
                  
                  06-03 处理文本（基础）
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/06/04.html"
                >
                  
                  06-04 处理文本（数学表达式）
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/06/05.html"
                >
                  
                  06-05 图像基础
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/06/06.html"
                >
                  
                  06-06 注释
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/06/07.html"
                >
                  
                  06-07 标签
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/06/08.html"
                >
                  
                  06-08 figures, subplots, axes 和 ticks 对象
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/06/09.html"
                >
                  
                  06-09 不要迷信默认设置
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/06/10.html"
                >
                  
                  06-10 各种绘图实例
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/07/features.html"
        >
          
          第7章 Scipy
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/07/01.html"
                >
                  
                  07-01 Scientific Python 简介
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/07/02.html"
                >
                  
                  07-02 插值
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/07/03.html"
                >
                  
                  07-03 统计概率方法
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/07/04.html"
                >
                  
                  07-04 曲线拟合
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/07/05.html"
                >
                  
                  07-05 最小化函数
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/07/06.html"
                >
                  
                  07-06 积分
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/07/07.html"
                >
                  
                  07-07 解微分方程
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/07/08.html"
                >
                  
                  07-08 稀疏矩阵
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/07/09.html"
                >
                  
                  07-09 线性代数
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/07/10.html"
                >
                  
                  07-10 系数矩阵的线性代数
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
      
      

      
      

      
      
      <li class="c-sidebar__chapter">
        <a class="c-sidebar__entry "
          href="/08/features.html"
        >
          
          第8章 Python 有用的库
        </a>

        

          
          
          
          

          

          <ul class="c-sidebar__sections ">
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/08/01.html"
                >
                  
                  08-01 pprint 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/08/02.html"
                >
                  
                  08-02 pickle 和 cPickle 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/08/03.html"
                >
                  
                  08-03 json 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/08/04.html"
                >
                  
                  08-04 glob 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/08/05.html"
                >
                  
                  08-05 shutil 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/08/06.html"
                >
                  
                  08-06 gzip, zipfile, tarfile 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/08/07.html"
                >
                  
                  08-07 logging 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/08/08.html"
                >
                  
                  08-08 string 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/08/09.html"
                >
                  
                  08-09 collections 模块
                </a>

                
                

              </li>
              
            
              
              

              <li class="c-sidebar__section">
                <a class="c-sidebar__entry "
                  href="/08/10.html"
                >
                  
                  08-10 requests 模块
                </a>

                
                

              </li>
              
            
          </ul>
        
      </li>

      
    
  </ul>
  <p class="sidebar_footer">Powered by <a href="http://www.momodel.cn:8899/classroom">Python 教程</a></p>
</nav>

      
      <main class="c-textbook__page" tabindex="-1">
          <div class="o-wrapper">
            <div class="c-sidebar-toggle">
  <!-- We show the sidebar by default so we use .is-active -->
  <button
    id="js-sidebar-toggle"
    class="hamburger hamburger--arrowalt is-active"
  >
    <span class="hamburger-box">
      <span class="hamburger-inner"></span>
    </span>
    <span class="c-sidebar-toggle__label">Toggle Sidebar</span>
  </button>
</div>

            

            <div class="c-textbook__content">
              <div class="search-content__inner-wrap">
    <input type="text" id="lunr_search" class="search-input" tabindex="-1" placeholder="'Enter your search term...''" />
    <div id="results" class="results"></div>
</div>

<script>
    // Add the lunr store since we will now search it
    var store = [{
        "title": "01-1 Python 简介",
        
        "excerpt":
            "Python 简介   Python 历史   Python 的创始人为荷兰人吉多·范罗苏姆（Guido van Rossum）。1989年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的脚本解释程序，作为 ABC 语言的一种继承。之所以选中 Python 作为程序的名字，是因为他是 BBC 电视剧——蒙提·派森的飞行马戏团（Monty Python's Flying Circus）的爱好者。   1991年，第一个 Python 编译器诞生。它是用C语言实现的，并能够调用C语言的库文件。   Python 2.0 于 2000 年 10 月 16 日发布，增加了实现完整的垃圾回收，并且支持 Unicode。   Python 3.0 于 2008 年 12 月 3 日发布，此版不完全兼容之前的 Python 源代码。不过，很多新特性后来也被移植到旧的 Python 2.6/2.7 版本。   第一行Python代码   安装好 Python 之后，在命令行下输入：   python   就可以进入 Python 解释器的页面。   按照惯例，第一行代码应该是输出 \"hello world!\"：           print (\"hello world!\")                        hello world!                  相对与 Java，C 等语言，Python 仅仅使用一行语句就完成的了这个任务。   可以将这句话的内容保存到一个文本文件中，并使用后缀名 .py 结尾，例如 hello_world.py，在命令行下运行这个程序：   python hello_world.py   也会输出 \"hello world!\" 的结果。   Python 之禅   在 Python 解释器下输入   import this   会出来这样一首小诗：           import this                        The Zen of Python, by Tim Peters  Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those!                  这首诗反映了Python的设计哲学——Python是一种追求优雅，明确，简单的编程语言，但事实上，产生这首诗的代码并没有写的那么简单易懂：           s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref  Ornhgvshy vf orggre guna htyl. Rkcyvpvg vf orggre guna vzcyvpvg. Fvzcyr vf orggre guna pbzcyrk. Pbzcyrk vf orggre guna pbzcyvpngrq. Syng vf orggre guna arfgrq. Fcnefr vf orggre guna qrafr. Ernqnovyvgl pbhagf. Fcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf. Nygubhtu cenpgvpnyvgl orngf chevgl. Reebef fubhyq arire cnff fvyragyl. Hayrff rkcyvpvgyl fvyraprq. Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff. Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg. Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu. Abj vf orggre guna arire. Nygubhtu arire vf bsgra orggre guna *evtug* abj. Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn. Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn. Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"  d = {} for c in (65, 97):     for i in range(26):         d[chr(i+c)] = chr((i+13) % 26 + c)  print (\"\".join([d.get(c, c) for c in s]))                        The Zen of Python, by Tim Peters  Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those!                     Life is short. Use Python.   ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/01/01.html",
        "teaser":null},{
        "title": "第1章 Python 介绍",
        
        "excerpt":
            "第1章 Python 介绍   01-1-Python 简介  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/01/features.html",
        "teaser":null},{
        "title": "02-01 Python 入门演示",
        
        "excerpt":
            "Python 入门演示   简单的数学运算   整数相加，得到整数：           2 + 2                         4                   浮点数相加，得到浮点数：           2.0 + 2.5                         4.5                   整数和浮点数相加，得到浮点数：           2 + 2.5                         4.5                   变量赋值   Python使用&lt;变量名&gt;=&lt;表达式&gt;的方式对变量进行赋值           a = 0.2            字符串 String   字符串的生成，单引号与双引号是等价的：           s = \"hello world\" s                         'hello world'                           s = 'hello world' s                         'hello world'                   三引号用来输入包含多行文字的字符串：           s = \"\"\"hello world\"\"\" print (s)                        hello world                          s = '''hello world''' print (s)                        hello world                  字符串的加法：           s = \"hello\" + \" world\" s                         'hello world'                   字符串索引：           s[0]                         'h'                           s[-1]                         'd'                           s[0:5]                         'hello'                   字符串的分割：           s = \"hello world\" s.split()                         ['hello', 'world']                   查看字符串的长度：           len(s)                         11                   列表 List   Python用[]来生成列表           a = [1, 2.0, 'hello', 5 + 1.0] a                         [1, 2.0, 'hello', 6.0]                   列表加法：           a + a                         [1, 2.0, 'hello', 6.0, 1, 2.0, 'hello', 6.0]                   列表索引：           a[1]                         2.0                   列表长度：           len(a)                         4                   向列表中添加元素：           a.append(\"world\") a                         [1, 2.0, 'hello', 6.0, 'world']                   集合 Set   Python用{}来生成集合，集合中不含有相同元素。           s = {2, 3, 4, 2} s                         {2, 3, 4}                   集合的长度：           len(s)                         3                   向集合中添加元素：           s.add(1) s                         {1, 2, 3, 4}                   集合的交：           a = {1, 2, 3, 4} b = {2, 3, 4, 5} a &amp; b                         {2, 3, 4}                   并：           a | b                         {1, 2, 3, 4, 5}                   差：           a - b                         {1}                   对称差：           a ^ b                         {1, 5}                   字典 Dictionary   Python用{key:value}来生成Dictionary。           d = {'dogs':5, 'cats':4} d                         {'dogs': 5, 'cats': 4}                   字典的大小           len(d)                         2                   查看字典某个键对应的值：           d[\"dogs\"]                         5                   修改键值：           d[\"dogs\"] = 2 d                         {'dogs': 2, 'cats': 4}                   插入键值：           d[\"pigs\"] = 7 d                         {'dogs': 2, 'cats': 4, 'pigs': 7}                   所有的键：           d.keys()                         dict_keys(['dogs', 'cats', 'pigs'])                   所有的值：           d.values()                         dict_values([2, 4, 7])                   所有的键值对：           d.items()                         dict_items([('dogs', 2), ('cats', 4), ('pigs', 7)])                   数组 Numpy Arrays   需要先导入需要的包，Numpy数组可以进行很多列表不能进行的运算。           from numpy import array a = array([1, 2, 3, 4]) a                         array([1, 2, 3, 4])                   加法：           a + 2                         array([3, 4, 5, 6])                           a + a                         array([2, 4, 6, 8])                   画图 Plot   Python提供了一个很像MATLAB的绘图接口。           %matplotlib inline from matplotlib.pyplot import plot plot(a, a**2)                         [&lt;matplotlib.lines.Line2D at 0x1141e8a90&gt;]                                             循环 Loop           line = '1 2 3 4 5' fields = line.split() fields                         ['1', '2', '3', '4', '5']                           total = 0 for field in fields:     total += int(field) total                         15                   Python中有一种叫做列表推导式(List comprehension)的用法：           numbers = [int(field) for field in fields] numbers                         [1, 2, 3, 4, 5]                           sum(numbers)                         15                   写在一行：           sum([int(field) for field in line.split()])                         15                   文件操作 File IO           cd ./                        /Users/luxu/Downloads/python-tutorial-cn/2. python-essentials                  写文件：           f = open('data.txt', 'w') f.write('1 2 3 4\\n') f.write('2 3 4 5\\n') f.close()            读文件：           f = open('data.txt') data = [] for line in f:     data.append([int(field) for field in line.split()]) f.close() data                          [[1, 2, 3, 4], [2, 3, 4, 5]]                           for row in data:     print (row)                        [1, 2, 3, 4] [2, 3, 4, 5]                  删除文件：           import os os.remove('data.txt')            函数 Function   Python用关键词def来定义函数。           def poly(x, a, b, c):     y = a * x ** 2 + b * x + c     return y  x = 1 poly(x, 1, 2, 3)                         6                   用Numpy数组做参数x：           x = array([1, 2, 3]) poly(x, 1, 2, 3)                         array([ 6, 11, 18])                   可以在定义时指定参数的默认值：           from numpy import arange  def poly(x, a = 1, b = 2, c = 3):     y = a*x**2 + b*x + c     return y  x = arange(10) x array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])                         array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])                           poly(x)                         array([  3,   6,  11,  18,  27,  38,  51,  66,  83, 102])                           poly(x, b = 1)                         array([ 3,  5,  9, 15, 23, 33, 45, 59, 75, 93])                   模块 Module   Python中使用import关键词来导入模块。           import os            当前进程号：           os.getpid()                         2578                   系统分隔符：           os.sep                         '/'                   - 类 Class   用class来定义一个类。 Person(object)表示继承自object类； __init__函数用来初始化对象； self表示对象自身，类似于C Java里面this。           class Person(object):     def __init__(self, first, last, age):         self.first = first         self.last = last         self.age = age     def full_name(self):         return self.first + ' ' + self.last            构建新对象：           person = Person('Mertle', 'Sedgewick', 52)            调用对象的属性：           person.first                         'Mertle'                   调用对象的方法：           person.full_name()                         'Mertle Sedgewick'                   修改对象的属性：           person.last = 'Smith'            添加新属性，d是之前定义的字典：           person.critters = d person.critters                         {'dogs': 2, 'cats': 4, 'pigs': 7}                   网络数据 Data from Web           url = 'http://www.sample-videos.com/csv/Sample-Spreadsheet-10-rows.csv'            处理后就相当于一个可读文件：           import urllib.request  aa = urllib.request.urlopen(url) ge_csv = aa.read() data = [] for line in ge_csv:     data.append(line) data[:4]                         [49, 44, 34, 69]                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/01.html",
        "teaser":null},{
        "title": "02-02 Python 数据类型",
        
        "excerpt":
            "Python 数据类型   常用数据类型 Common Data Types                  类型       例子                       整数       -100                 浮点数       3.1416                 字符串       'hello'                 列表       [1, 1.2, 'hello']                 字典       {'dogs': 5, 'pigs': 3}                 Numpy数组       array([1, 2, 3])           其他类型 Others                  类型       例子                       长整型       1000000000000L                 布尔型       True, False                 元组       ('ring', 1000)                 集合       {1, 2, 3}                 Pandas类型       DataFrame, Series                 自定义       Object Oriented Classes          ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/02.html",
        "teaser":null},{
        "title": "02-03 Python 数字",
        
        "excerpt":
            "数字   整型 Integers   整型运算，加减乘：           2 + 2                         4                           3 - 4                         -1                           4 * 5                         20                   在Python 2.7中，整型的运算结果只能返回整型，除法的结果也不例外。   例如12 / 5返回的结果并不是2.4，而是2：           12 / 5                         2.4                   幂指数：           2 ** 5                         32                   取余：           32 % 5                         2                   赋值给变量：           a = 1 a                         1                   使用type()函数来查看变量类型：           type(a)                         int                   整型数字的最大最小值：   在 32 位系统中，一个整型 4 个字节，最小值 -2,147,483,648，最大值 2,147,483,647。   在 64 位系统中，一个整型 8 个字节，最小值 -9,223,372,036,854,775,808，最大值 9,223,372,036,854,775,807。           import sys sys.maxsize                         9223372036854775807                   长整型 Long Integers   当整型超出范围时，Python会自动将整型转化为长整型，不过长整型计算速度会比整型慢。           a = sys.maxsize + 1 print (type(a))                        &lt;class 'int'&gt;                  长整型的一个标志是后面以字母L结尾：           a                         9223372036854775808                   浮点数 Floating Point Numbers           a = 1.4 type(a)                         float                   在之前的除法例子12 / 5中，假如想要使返回的结果为2.4，可以将它们写成浮点数的形式：           12.0 / 5.0                         2.4                           12 / 5.0                         2.4                           12.0 / 5                         2.4                   上面的例子说明，浮点数与整数进行运算时，返回的仍然是浮点数：           5 + 2.4                         7.4                   浮点数也可以进行与整数相似的运算，甚至可以取余：           3.4 - 3.2                         0.19999999999999973                           12.3 + 32.4                         44.7                           2.5 ** 2                         6.25                           3.4 % 2.1                         1.2999999999999998                   Python的浮点数标准与C，Java一致，都是IEEE 754 floating point standard。   注意看 3.4 - 3.2 的结果并不是我们预期的0.2，这是因为浮点数本身储存方式引起的，浮点数本身会存在一点误差。                  事实上，Python 中储存的值为’0.199999999999999733546474089962430298328399658203125’，因为这是最接近0.2的浮点数。                   '{:.52}'.format(3.4 - 3.2)                         '0.199999999999999733546474089962430298328399658203125'                   当我们使用print显示时，Python会自动校正这个结果           print (3.4 - 3.2)                        0.19999999999999973                  可以用sys.float_info来查看浮点数的信息：           import sys sys.float_info                         sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)                   例如浮点数能表示的最大值：           sys.float_info.max                         1.7976931348623157e+308                   浮点数能表示的最接近0的值：           sys.float_info.min                         2.2250738585072014e-308                   浮点数的精度：           sys.float_info.epsilon                         2.220446049250313e-16                   复数 Complex Numbers   Python 使用 j 来表示复数的虚部：           a = 1 + 2j type(a)                         complex                   可以查看它的实部，虚部以及共轭：           a.real                         1.0                           a.imag                         2.0                           a.conjugate()                         (1-2j)                   ##交互计算   可以将复杂的表达式放在一起计算：           1 + 2 - (3 * 4 / 6) ** 5 + 7 % 5                         -27.0                   在Python中运算是有优先级的，优先级即算术的先后顺序，比如“先乘除后加减”和“先算括号里面的”都是两种优先级的规则，优先级从高到低排列如下：      ( ) 括号   ** 幂指数运算   * / // % 乘，除，整数除法，取余运算   ’+ -‘ 加减   整数除法，返回的是比结果小的最大整数值：           12.3 // 5.2                         2.0                           12.3 // -4                         -4.0                   简单的数学函数   绝对值：           abs(-12.4)                         12.4                   取整：           round(21.6)                         22                   最大最小值：           print (min(2, 3, 4, 5)) print (max(2, 4, 3))                        2 4                  变量名覆盖   不要用内置的函数来命名变量，否则会出现意想不到的结果：           type(max)                         builtin_function_or_method                   不要这样做！！！           max = 1 type(max)                         int                           max(4, 5)                             ---------------------------------------------------------------------------      TypeError                                 Traceback (most recent call last)      &lt;ipython-input-44-844ab04d5106&gt; in &lt;module&gt;     ----&gt; 1 max(4, 5)           TypeError: 'int' object is not callable                    类型转换   浮点数转整型，只保留整数部分：           print (int(12.324)) print (int(-3.32))                        12 -3                  整型转浮点型：           print (float(1.2))                        1.2                  其他表示   除了10进制外，整数还有其他类型的表示方法。   科学计数法：           1e-6                         1e-06                   16进制，前面加0x修饰，后面使用数字0-9A-F：           0xFF                         255                   2进制，前面加0b修饰，后面使用数字0或1：           0b101010                         42                   原地计算 In-place   Python可以使用下面的形式进行原地计算：           b = 2.5 b += 2 print (b) b *= 2 print (b) b -= 3 print (b)                        4.5 9.0 6.0                  布尔型 Boolean Data Type   布尔型可以看成特殊的二值变量，其取值为True和False：           q = True type(q)                         bool                   可以用表达式构建布尔型变量：           q = 1 &gt; 2 print (q)                        False                  常用的比较符号包括：   &lt;, &gt;, &lt;=, &gt;=, ==, !=   Python支持链式比较：           x = 2  1 &lt; x &lt;= 3                         True                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/03.html",
        "teaser":null},{
        "title": "02-04 Python 字符串",
        
        "excerpt":
            "字符串   生成字符串   Python中可以使用一对单引号’‘或者双引号”“生成字符串。           s = \"hello, world\" print (s)                        hello, world                          s = 'hello world' print (s)                        hello world                  简单操作   加法：           s = 'hello ' + 'world' s                         'hello world'                   字符串与数字相乘：           \"echo\" * 3                         'echoechoecho'                   字符串长度：           len(s)                         11                   字符串方法   Python是一种面向对象的语言，面向对象的语言中一个必不可少的元素就是方法，而字符串是对象的一种，所以有很多可用的方法。   跟很多语言一样，Python使用以下形式来调用方法：   对象.方法(参数)   分割   s.split()将s按照空格（包括多个空格，制表符\\t，换行符\\n等）分割，并返回所有分割得到的字符串。           line = \"1 2 3 4  5\" numbers = line.split() print (numbers)                        ['1', '2', '3', '4', '5']                  s.split(sep)以给定的sep为分隔符对s进行分割。           line = \"1,2,3,4,5\" numbers = line.split(',') print (numbers)                        ['1', '2', '3', '4', '5']                  连接   与分割相反，s.join(str_sequence)的作用是以s为连接符将字符串序列str_sequence中的元素连接起来，并返回连接后得到的新字符串：           s = ' ' s.join(numbers)                         '1 2 3 4 5'                           s = ',' s.join(numbers)                         '1,2,3,4,5'                   替换   s.replace(part1, part2)将字符串s中指定的部分part1替换成想要的部分part2，并返回新的字符串。           s = \"hello world\" s.replace('world', 'python')                         'hello python'                   此时，s的值并没有变化，替换方法只是生成了一个新的字符串。           s                         'hello world'                   大小写转换   s.upper()方法返回一个将s中的字母全部大写的新字符串。   s.lower()方法返回一个将s中的字母全部小写的新字符串。           \"hello world\".upper()                         'HELLO WORLD'                   这两种方法也不会改变原来s的值：           s = \"HELLO WORLD\" print (s.lower()) print (s)                        hello world HELLO WORLD                  去除多余空格   s.strip()返回一个将s两端的多余空格除去的新字符串。   s.lstrip()返回一个将s开头的多余空格除去的新字符串。   s.rstrip()返回一个将s结尾的多余空格除去的新字符串。           s = \"  hello world   \" s.strip()                         'hello world'                   s的值依然不会变化：           s                         '  hello world   '                           s.lstrip()                         'hello world   '                           s.rstrip()                         '  hello world'                   更多方法   可以使用dir函数查看所有可以使用的方法：           dir(s)                         ['__add__',  '__class__',  '__contains__',  '__delattr__',  '__dir__',  '__doc__',  '__eq__',  '__format__',  '__ge__',  '__getattribute__',  '__getitem__',  '__getnewargs__',  '__gt__',  '__hash__',  '__init__',  '__iter__',  '__le__',  '__len__',  '__lt__',  '__mod__',  '__mul__',  '__ne__',  '__new__',  '__reduce__',  '__reduce_ex__',  '__repr__',  '__rmod__',  '__rmul__',  '__setattr__',  '__sizeof__',  '__str__',  '__subclasshook__',  'capitalize',  'casefold',  'center',  'count',  'encode',  'endswith',  'expandtabs',  'find',  'format',  'format_map',  'index',  'isalnum',  'isalpha',  'isdecimal',  'isdigit',  'isidentifier',  'islower',  'isnumeric',  'isprintable',  'isspace',  'istitle',  'isupper',  'join',  'ljust',  'lower',  'lstrip',  'maketrans',  'partition',  'replace',  'rfind',  'rindex',  'rjust',  'rpartition',  'rsplit',  'rstrip',  'split',  'splitlines',  'startswith',  'strip',  'swapcase',  'title',  'translate',  'upper',  'zfill']                   多行字符串   Python 用一对 \"\"\" 或者 ''' 来生成多行字符串：           a = \"\"\"hello world. it is a nice day.\"\"\" print (a)                        hello world. it is a nice day.                  在储存时，我们在两行字符间加上一个换行符 '\\n'           a                         'hello world.\\nit is a nice day.'                   使用 () 或者 \\ 来换行   当代码太长或者为了美观起见时，我们可以使用两种方法来将一行代码转为多行代码：      ()   \\           a = (\"hello, world. \"     \"it's a nice day. \"     \"my name is xxx\") a                         \"hello, world. it's a nice day. my name is xxx\"                           a = \"hello, world. \" \\     \"it's a nice day. \" \\     \"my name is xxx\" a                         \"hello, world. it's a nice day. my name is xxx\"                   强制转换为字符串      str(ob)强制将ob转化成字符串。   repr(ob)也是强制将ob转化成字符串。   不同点如下：           str(1.1 + 2.2)                         '3.3000000000000003'                           repr(1.1 + 2.2)                         '3.3000000000000003'                   整数与不同进制的字符串的转化   可以将整数按照不同进制转化为不同类型的字符串。   十六进制：           hex(255)                         '0xff'                   八进制：           oct(255)                         '0o377'                   二进制：           bin(255)                         '0b11111111'                   可以使用 int 将字符串转为整数：           int('23')                         23                   还可以指定按照多少进制来进行转换，最后返回十进制表达的整数：           int('FF', 16)                         255                           int('377', 8)                         255                           int('11111111', 2)                         255                   float 可以将字符串转换为浮点数：           float('3.5')                         3.5                   格式化字符串   Python用字符串的format()方法来格式化字符串。   具体用法如下，字符串中花括号 {} 的部分会被format传入的参数替代，传入的值可以是字符串，也可以是数字或者别的对象。           '{} {} {}'.format('a', 'b', 'c')                         'a b c'                   可以用数字指定传入参数的相对位置：           '{2} {1} {0}'.format('a', 'b', 'c')                         'c b a'                   还可以指定传入参数的名称：           '{color} {n} {x}'.format(n=10, x=1.5, color='blue')                         'blue 10 1.5'                   可以在一起混用：           '{color} {0} {x} {1}'.format(10, 'foo', x = 1.5, color='blue')                         'blue 10 1.5 foo'                   可以用{&lt;field name&gt;:&lt;format&gt;}指定格式：           from math import pi  '{0:10} {1:10d} {2:10.2f}'.format('foo', 5, 2 * pi)                         'foo                 5       6.28'                   具体规则与C中相同。   也可以使用旧式的 % 方法进行格式化：           s = \"some numbers:\" x = 1.34 y = 2 # 用百分号隔开，括号括起来 t = \"%s %f, %d\" % (s, x, y)                    t                         'some numbers: 1.340000, 2'                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/04.html",
        "teaser":null},{
        "title": "02-05 索引和切片",
        
        "excerpt":
            "索引和分片   索引   对于一个有序序列，可以通过索引的方法来访问对应位置的值。字符串便是一个有序序列的例子，Python使用 [] 来对有序序列进行索引。           s = \"hello world\" s[0]                         'h'                   Python中索引是从 0 开始的，所以索引 0 对应与序列的第 1 个元素。为了得到第 5 个元素，需要使用索引值 4 。           s[4]                         'o'                   除了正向索引，Python还引入了负索引值的用法，即从后向前开始计数，例如，索引 -2 表示倒数第 2 个元素：           s[-2]                         'l'                   单个索引大于等于字符串的长度时，会报错：           s[6]                         'w'                   分片   分片用来从序列中提取出想要的子序列，其用法为：   var[lower:upper:step]   其范围包括 lower ，但不包括 upper ，即 [lower, upper)， step 表示取值间隔大小，如果没有默认为1。           s                         'hello world'                           s[1:3]                         'el'                   分片中包含的元素的个数为 3-1=2 。   也可以使用负索引来指定分片的范围：           s[1:-2]                         'ello wor'                   包括索引 1 但是不包括索引 -2 。   lower和upper可以省略，省略lower意味着从开头开始分片，省略upper意味着一直分片到结尾。           s[:3]                         'hel'                           s[-3:]                         'rld'                           s[:]                         'hello world'                   每隔两个取一个值：           s[::2]                         'hlowrd'                   当step的值为负时，省略lower意味着从结尾开始分片，省略upper意味着一直分片到开头。           s[::-1]                         'dlrow olleh'                   当给定的upper超出字符串的长度（注意：因为不包含upper，所以可以等于）时，Python并不会报错，不过只会计算到结尾。           s[:100]                         'hello world'                   使用“0”作为索引开头的原因   使用[low, up)形式的原因   假设需要表示字符串 hello 中的内部子串 el ：                  方式       [low, up)       (low, up]       (lower, upper)       [lower, upper]                       表示       [1,3)       (0,2]       (0,3)       [1,2]                 序列长度       up - low       up - low       up - low - 1       up - low + 1           对长度来说，前两种方式比较好，因为不需要烦人的加一减一。   现在只考虑前两种方法，假设要表示字符串hello中的从头开始的子串hel：                  方式       [low, up)       (low, up]                       表示       [0,3)       (-1,2]                 序列长度       up - low       up - low           第二种表示方法从-1开始，不是很好，所以选择使用第一种[low, up)的形式。   使用0-base的形式      Just too beautiful to ignore.  —-Guido van Rossum    两种简单的情况：      从头开始的n个元素；            使用0-base：[0, n)       使用1-base：[1, n+1)           第i+1个元素到第i+n个元素。            使用0-base：[i, n+i)       使用1-base：[i+1, n+i+1)           1-base有个+1部分，所以不推荐。   综合这两种原因，Python使用0-base的方法来进行索引。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/05.html",
        "teaser":null},{
        "title": "02-06 列表",
        
        "excerpt":
            "列表   在Python中，列表是一个有序的序列。   列表用一对 [] 生成，中间的元素用 , 隔开，其中的元素不需要是同一类型，同时列表的长度也不固定。           l = [1, 2.0, 'hello'] print (l)                        [1, 2.0, 'hello']                  空列表可以用 [] 或者 list() 生成：           empty_list = [] empty_list                         []                           empty_list = list() empty_list                         []                   列表操作   与字符串类似，列表也支持以下的操作：   长度   用 len 查看列表长度：           len(l)                         3                   加法和乘法   列表加法，相当于将两个列表按顺序连接：           a = [1, 2, 3] b = [3.2, 'hello'] a + b                         [1, 2, 3, 3.2, 'hello']                   列表与整数相乘，相当于将列表重复相加：           l * 2                         [1, 2.0, 'hello', 1, 2.0, 'hello']                   索引和分片   列表和字符串一样可以通过索引和分片来查看它的元素。   索引：           a = [10, 11, 12, 13, 14] a[0]                         10                   反向索引：           a[-1]                         14                   分片：           a[2:-1]                         [12, 13]                   与字符串不同的是，列表可以通过索引和分片来修改。   对于字符串，如果我们通过索引或者分片来修改，Python会报错：           s = \"hello world\" # 把开头的 h 改成大写 s[0] = 'H'                             ---------------------------------------------------------------------------      TypeError                                 Traceback (most recent call last)      &lt;ipython-input-10-53d5e2ea1490&gt; in &lt;module&gt;           1 s = \"hello world\"           2 # 把开头的 h 改成大写     ----&gt; 3 s[0] = 'H'           TypeError: 'str' object does not support item assignment                    而这种操作对于列表来说是可以的：           a = [10, 11, 12, 13, 14] a[0] = 100 print (a)                        [100, 11, 12, 13, 14]                  这种赋值也适用于分片，例如，将列表的第2，3两个元素换掉：           a[1:3] = [1, 2] a                         [100, 1, 2, 13, 14]                   事实上，对于连续的分片（即步长为 1 ），Python采用的是整段替换的方法，两者的元素个数并不需要相同，例如，将 [11,12] 替换为 [1,2,3,4]：           a = [10, 11, 12, 13, 14] a[1:3] = [1, 2, 3, 4] print (a)                        [10, 1, 2, 3, 4, 13, 14]                  这意味着，可以用这种方法来删除列表中一个连续的分片：           a = [10, 1, 2, 11, 12] print (a[1:3]) a[1:3] = [] print (a)                        [1, 2] [10, 11, 12]                  对于不连续（间隔step不为1）的片段进行修改时，两者的元素数目必须一致：           a = [10, 11, 12, 13, 14] a[::2] = [1, 2, 3] a                         [1, 11, 2, 13, 3]                   否则会报错：           a[::2] = []                             ---------------------------------------------------------------------------      ValueError                                Traceback (most recent call last)      &lt;ipython-input-18-29c2e240c5c6&gt; in &lt;module&gt;     ----&gt; 1 a[::2] = []           ValueError: attempt to assign sequence of size 0 to extended slice of size 3                    删除元素   Python提供了删除列表中元素的方法 ‘del’。   删除列表中的第一个元素：           a = [1002, 'a', 'b', 'c'] del a[0] print (a)                        ['a', 'b', 'c']                  删除第2到最后一个元素：           a = [1002, 'a', 'b', 'c'] del a[1:] a                         [1002]                   删除间隔的元素：           a = ['a', 1, 'b', 2, 'c'] del a[::2] a                         [1, 2]                   测试从属关系   用 in 来看某个元素是否在某个序列（不仅仅是列表）中，用not in来判断是否不在某个序列中。           a = [10, 11, 12, 13, 14] print (10 in a) print (10 not in a)                        True False                  也可以作用于字符串：           s = 'hello world' print ('he' in s) print ('world' not in s)                        True False                  列表中可以包含各种对象，甚至可以包含列表：           a = [10, 'eleven', [12, 13]] a[2]                         [12, 13]                   a[2]是列表，可以对它再进行索引：           a[2][1]                         13                   列表方法   不改变列表的方法   列表中某个元素个数count   l.count(ob) 返回列表中元素 ob 出现的次数。           a = [11, 12, 13, 12, 11] a.count(11)                         2                   列表中某个元素位置index   l.index(ob) 返回列表中元素 ob 第一次出现的索引位置，如果 ob 不在 l 中会报错。           a.index(12)                         1                   不存在的元素会报错：           a.index(1)                             ---------------------------------------------------------------------------      ValueError                                Traceback (most recent call last)      &lt;ipython-input-30-4cb73546dbcc&gt; in &lt;module&gt;     ----&gt; 1 a.index(1)           ValueError: 1 is not in list                    改变列表的方法   向列表添加单个元素   l.append(ob) 将元素 ob 添加到列表 l 的最后。           a = [10, 11, 12] a.append(11) print (a)                        [10, 11, 12, 11]                  append每次只添加一个元素，并不会因为这个元素是序列而将其展开：           a.append([11, 12]) print (a)                        [10, 11, 12, 11, [11, 12]]                  向列表添加序列   l.extend(lst) 将序列 lst 的元素依次添加到列表 l 的最后，作用相当于 l += lst。           a = [10, 11, 12, 11] a.extend([1, 2]) print (a)                        [10, 11, 12, 11, 1, 2]                  插入元素   l.insert(idx, ob) 在索引 idx 处插入 ob ，之后的元素依次后移。           a = [10, 11, 12, 13, 11] # 在索引 3 插入 'a' a.insert(3, 'a') print (a)                        [10, 11, 12, 'a', 13, 11]                  移除元素   l.remove(ob) 会将列表中第一个出现的 ob 删除，如果 ob 不在 l 中会报错。           a = [10, 11, 12, 13, 11] # 移除了第一个 11 a.remove(11) print (a)                        [10, 12, 13, 11]                  弹出元素   l.pop(idx) 会将索引 idx 处的元素删除，并返回这个元素。           a = [10, 11, 12, 13, 11] a.pop(2)                         12                   排序   l.sort() 会将列表中的元素按照一定的规则排序：           a = [10, 1, 11, 13, 11, 2] a.sort() print (a)                        [1, 2, 10, 11, 11, 13]                  如果不想改变原来列表中的值，可以使用 sorted 函数：           a = [10, 1, 11, 13, 11, 2] b = sorted(a) print (a) print (b)                        [10, 1, 11, 13, 11, 2] [1, 2, 10, 11, 11, 13]                  列表反向   l.reverse() 会将列表中的元素从后向前排列。           a = [1, 2, 3, 4, 5, 6] a.reverse() print (a)                        [6, 5, 4, 3, 2, 1]                  如果不想改变原来列表中的值，可以使用这样的方法：           a = [1, 2, 3, 4, 5, 6] b = a[::-1] print (a) print (b)                        [1, 2, 3, 4, 5, 6] [6, 5, 4, 3, 2, 1]                  如果不清楚用法，可以查看帮助：           a.sort?                        \u001b[0;31mDocstring:\u001b[0m L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE* \u001b[0;31mType:\u001b[0m      builtin_function_or_method                   ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/06.html",
        "teaser":null},{
        "title": "02-07 可变和不可变类型",
        
        "excerpt":
            "可变和不可变类型   列表是可变的（Mutable）           a = [1,2,3,4] a                         [1, 2, 3, 4]                   通过索引改变：           a[0] = 100 a                         [100, 2, 3, 4]                   通过方法改变：           a.insert(3, 200) a                         [100, 2, 3, 200, 4]                           a.sort() a                         [2, 3, 4, 100, 200]                   字符串是不可变的（Immutable）           s = \"hello world\" s                         'hello world'                   通过索引改变会报错：           s[0] = 'z'                             ---------------------------------------------------------------------------      TypeError                                 Traceback (most recent call last)      &lt;ipython-input-6-5994e1a74598&gt; in &lt;module&gt;     ----&gt; 1 s[0] = 'z'           TypeError: 'str' object does not support item assignment                    字符串方法只是返回一个新字符串，并不改变原来的值：           print (s.replace('world', 'Mars')) print (s)                        hello Mars hello world                  如果想改变字符串的值，可以用重新赋值的方法：           s = \"hello world\" s = s.replace('world', 'Mars') print (s)                        hello Mars                  数据类型分类：                  可变数据类型       不可变数据类型                       list, dictionary, set, numpy array, user defined objects       integer, float, long, complex, string, tuple, frozenset           字符串不可变的原因   其一，列表可以通过以下的方法改变，而字符串不支持这样的变化。           a = [1, 2, 3, 4] b = a            此时， a 和 b 指向同一块区域，改变 b 的值， a 也会同时改变：           b[0] = 100 a                         [100, 2, 3, 4]                   其二，是字符串与整数浮点数一样被认为是基本类型，而基本类型在Python中是不可变的。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/07.html",
        "teaser":null},{
        "title": "02-08 元组",
        
        "excerpt":
            "元组   基本操作   与列表相似，元组Tuple也是个有序序列，但是元组是不可变的，用()生成。           t = (10, 11, 12, 13, 14) t                         (10, 11, 12, 13, 14)                   可以索引，切片：           t[0]                         10                           t[1:3]                         (11, 12)                   但是元组是不可变的：           # 会报错 t[0] = 1                             ---------------------------------------------------------------------------      TypeError                                 Traceback (most recent call last)      &lt;ipython-input-4-8c7972379529&gt; in &lt;module&gt;           1 # 会报错     ----&gt; 2 t[0] = 1           TypeError: 'tuple' object does not support item assignment                    单个元素的元组生成   由于()在表达式中被应用，只含有单个元素的元组容易和表达式混淆，所以采用下列方式定义只有一个元素的元组：           a = (10,) print (a) print (type(a))                        (10,) &lt;class 'tuple'&gt;                          a = (10) print (type(a))                        &lt;class 'int'&gt;                  将列表转换为元组：           a = [10, 11, 12, 13, 14] tuple(a)                         (10, 11, 12, 13, 14)                   元组方法   由于元组是不可变的，所以只能有一些不可变的方法，例如计算元素个数 count 和元素位置 index ，用法与列表一样。           a.count(10)                         1                           a.index(12)                         2                   为什么需要元组   旧式字符串格式化中参数要用元组；   在字典中当作键值；   数据库的返回值……  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/08.html",
        "teaser":null},{
        "title": "02-09 列表与元组的速度比较",
        
        "excerpt":
            "列表与元组的速度比较   IPython 中用 magic 命令 %timeit 来计时。   比较生成速度           %timeit [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]                        184 ns ± 4.92 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)                          %timeit (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25)                        14 ns ± 0.516 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)                  可以看到，元组的生成速度要比列表的生成速度快得多，相差大概一个数量级。   比较遍历速度   产生内容相同的随机列表和元组：           from numpy.random import rand values = rand(10000,4) lst = [list(row) for row in values] tup = tuple(tuple(row) for row in values)                     %timeit for row in lst: list(row)                        2.05 ms ± 57.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)                          %timeit for row in tup: tuple(row)                        1.09 ms ± 65.4 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)                  在遍历上，元组和列表的速度表现差不多。   比较遍历和索引速度：           %timeit for row in lst: a = row[0] + 1                        2.39 ms ± 30.8 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)                          %timeit for row in tup: a = row[0] + 1                        2.53 ms ± 336 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)                  元组的生成速度会比列表快很多，迭代速度快一点，索引速度差不多。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/09.html",
        "teaser":null},{
        "title": "02-10 字典",
        
        "excerpt":
            "字典   字典 dictionary ，在一些编程语言中也称为 hash ， map ，是一种由键值对组成的数据结构。   顾名思义，我们把键想象成字典中的单词，值想象成词对应的定义，那么——   一个词可以对应一个或者多个定义，但是这些定义只能通过这个词来进行查询。   基本操作   空字典   Python 使用 {} 或者 dict() 来创建一个空的字典：           a = {} type(a)                         dict                           a = dict() type(a)                         dict                   有了dict之后，可以用索引键值的方法向其中添加元素，也可以通过索引来查看元素的值：   插入键值           a[\"one\"] = \"this is number 1\" a[\"two\"] = \"this is number 2\" a                         {'one': 'this is number 1', 'two': 'this is number 2'}                   查看键值           a['one']                         'this is number 1'                   更新键值           a[\"one\"] = \"this is number 1, too\" a                         {'one': 'this is number 1, too', 'two': 'this is number 2'}                   初始化字典   可以看到，Python使用key: value这样的结构来表示字典中的元素结构，事实上，可以直接使用这样的结构来初始化一个字典：           b = {'one': 'this is number 1', 'two': 'this is number 2'} b['one']                         'this is number 1'                   字典没有顺序   当我们 print 一个字典时，Python并不一定按照插入键值的先后顺序进行显示,因为字典中的键本身不一定是有序的。           print (a)                        {'one': 'this is number 1, too', 'two': 'this is number 2'}                          print (b)                        {'one': 'this is number 1', 'two': 'this is number 2'}                  因此，Python中不能用支持用数字索引按顺序查看字典中的值，而且数字本身也有可能成为键值，这样会引起混淆：           # 会报错 a[0]                             ---------------------------------------------------------------------------      KeyError                                  Traceback (most recent call last)      &lt;ipython-input-9-f76a772240d5&gt; in &lt;module&gt;           1 # 会报错     ----&gt; 2 a[0]           KeyError: 0                    键必须是不可变的类型   出于hash的目的，Python中要求这些键值对的键必须是不可变的，而值可以是任意的Python对象。   一个表示近义词的字典：           synonyms = {} synonyms['mutable'] = ['changeable', 'variable', 'varying', 'fluctuating',                        'shifting', 'inconsistent', 'unpredictable', 'inconstant',                        'fickle', 'uneven', 'unstable', 'protean'] synonyms['immutable'] = ['fixed', 'set', 'rigid', 'inflexible',                           'permanent', 'established', 'carved in stone'] synonyms                         {'immutable': ['fixed',   'set',   'rigid',   'inflexible',   'permanent',   'established',   'carved in stone'],  'mutable': ['changeable',   'variable',   'varying',   'fluctuating',   'shifting',   'inconsistent',   'unpredictable',   'inconstant',   'fickle',   'uneven',   'unstable',   'protean']}                   另一个例子：           # 定义四个字典 e1 = {'mag': 0.05, 'width': 20} e2 = {'mag': 0.04, 'width': 25} e3 = {'mag': 0.05, 'width': 80} e4 = {'mag': 0.03, 'width': 30} # 以字典作为值传入新的字典 events = {500: e1, 760: e2, 3001: e3, 4180: e4} events                         {500: {'mag': 0.05, 'width': 20},  760: {'mag': 0.04, 'width': 25},  3001: {'mag': 0.05, 'width': 80},  4180: {'mag': 0.03, 'width': 30}}                   键（或者值）的数据类型可以不同：           people = [     {'first': 'Sam', 'last': 'Malone', 'name': 35},     {'first': 'Woody', 'last': 'Boyd', 'name': 21},     {'first': 'Norm', 'last': 'Peterson', 'name': 34},     {'first': 'Diane', 'last': 'Chambers', 'name': 33} ] people                         [{'first': 'Sam', 'last': 'Malone', 'name': 35},  {'first': 'Woody', 'last': 'Boyd', 'name': 21},  {'first': 'Norm', 'last': 'Peterson', 'name': 34},  {'first': 'Diane', 'last': 'Chambers', 'name': 33}]                   使用 dict 初始化字典   除了通常的定义方式，还可以通过 dict() 转化来生成字典：           inventory = dict(     [('foozelator', 123),      ('frombicator', 18),       ('spatzleblock', 34),       ('snitzelhogen', 23)     ]) inventory                         {'foozelator': 123, 'frombicator': 18, 'snitzelhogen': 23, 'spatzleblock': 34}                   利用索引直接更新键值对：           inventory['frombicator'] += 1 inventory                         {'foozelator': 123, 'frombicator': 19, 'snitzelhogen': 23, 'spatzleblock': 34}                   适合做键的类型   在不可变类型中，整数和字符串是字典中最常用的类型；而浮点数通常不推荐用来做键，原因如下：           data = {} data[1.1 + 2.2] = 6.6 # 会报错 data[3.3]                             ---------------------------------------------------------------------------      KeyError                                  Traceback (most recent call last)      &lt;ipython-input-15-9d18186b97d9&gt; in &lt;module&gt;           2 data[1.1 + 2.2] = 6.6           3 # 会报错     ----&gt; 4 data[3.3]           KeyError: 3.3                    事实上，观察data的值就会发现，这个错误是由浮点数的精度问题所引起的：           data                         {3.3000000000000003: 6.6}                   有时候，也可以使用元组作为键值，例如，可以用元组做键来表示从第一个城市飞往第二个城市航班数的多少：           connections = {} connections[('New York', 'Seattle')] = 100 connections[('Austin', 'New York')] = 200 connections[('New York', 'Austin')] = 400            元组是有序的，因此 ('New York', 'Austin') 和 ('Austin', 'New York') 是两个不同的键：           print (connections[('Austin', 'New York')]) print (connections[('New York', 'Austin')])                        200 400                  字典方法   get 方法   之前已经见过，用索引可以找到一个键对应的值，但是当字典中没有这个键的时候，Python会报错，这时候可以使用字典的 get 方法来处理这种情况，其用法如下：   `d.get(key, default = None)`   返回字典中键 key 对应的值，如果没有这个键，返回 default 指定的值（默认是 None ）。           a = {} a[\"one\"] = \"this is number 1\" a[\"two\"] = \"this is number 2\"            索引不存在的键值会报错：           a[\"three\"]                             ---------------------------------------------------------------------------      KeyError                                  Traceback (most recent call last)      &lt;ipython-input-20-ba528808dd1a&gt; in &lt;module&gt;     ----&gt; 1 a[\"three\"]           KeyError: 'three'                    改用get方法：           print (a.get(\"three\"))                        None                  指定默认值参数：           a.get(\"three\", \"undefined\")                         'undefined'                   pop 方法删除元素   pop 方法可以用来弹出字典中某个键对应的值，同时也可以指定默认参数：   `d.pop(key, default = None)`   删除并返回字典中键 key 对应的值，如果没有这个键，返回 default 指定的值（默认是 None ）。           a                         {'one': 'this is number 1', 'two': 'this is number 2'}                   弹出并返回值：           a.pop(\"two\")                         'this is number 2'                           a                         {'one': 'this is number 1'}                   弹出不存在的键值：           a.pop(\"two\", 'not exist')                         'not exist'                   与列表一样，del 函数可以用来删除字典中特定的键值对，例如：           del a[\"one\"] a                         {}                   update方法更新字典   之前已经知道，可以通过索引来插入、修改单个键值对，但是如果想对多个键值对进行操作，这种方法就显得比较麻烦，好在有 update 方法：   `d.update(newd)`   将字典newd中的内容更新到d中去。           person = {} person['first'] = \"Jmes\" person['last'] = \"Maxwell\" person['born'] = 1831 print (person)                        {'first': 'Jmes', 'last': 'Maxwell', 'born': 1831}                  把’first’改成’James’，同时插入’middle’的值’Clerk’：           person_modifications = {'first': 'James', 'middle': 'Clerk'} person.update(person_modifications) print (person)                        {'middle': 'Clerk', 'first': 'James', 'last': 'Maxwell', 'born': 1831}                  in查询字典中是否有该键           barn = {'cows': 1, 'dogs': 5, 'cats': 3}            in 可以用来判断字典中是否有某个特定的键：           'chickens' in barn                         False                           'cows' in barn                         True                   keys 方法，values 方法和items 方法   `d.keys()`    返回一个由所有键组成的列表；   `d.values()`    返回一个由所有值组成的列表；   `d.items()`    返回一个由所有键值对元组组成的列表；           barn.keys()                         dict_keys(['cats', 'cows', 'dogs'])                           barn.values()                         dict_values([3, 1, 5])                           barn.items()                         dict_items([('cats', 3), ('cows', 1), ('dogs', 5)])                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/10.html",
        "teaser":null},{
        "title": "02-11 集合",
        
        "excerpt":
            "集合   之前看到的列表和字符串都是一种有序序列，而集合 set 是一种无序的序列。   因为集合是无序的，所以当集合中存在两个同样的元素的时候，Python只会保存其中的一个（唯一性）；同时为了确保其中不包含同样的元素，集合中放入的元素只能是不可变的对象（确定性）。   集合生成   可以用set()函数来显示的生成空集合：           a = set() type(a)                         set                   也可以使用一个列表来初始化一个集合：           a = set([1, 2, 3, 1]) a                         {1, 2, 3}                   集合会自动去除重复元素 1。   可以看到，集合中的元素是用大括号{}包含起来的，这意味着可以用{}的形式来创建集合：           a = {1, 2, 3, 1} a                         {1, 2, 3}                   但是创建空集合的时候只能用set来创建，因为在Python中{}创建的是一个空的字典：           s = {} type(s)                         dict                   集合操作   假设有这样两个集合：           a = {1, 2, 3, 4} b = {3, 4, 5, 6}            并   两个集合的并，返回包含两个集合所有元素的集合（去除重复）。   可以用方法 a.union(b) 或者操作 a | b 实现。           a.union(b)                         {1, 2, 3, 4, 5, 6}                           b.union(a)                         {1, 2, 3, 4, 5, 6}                           a | b                         {1, 2, 3, 4, 5, 6}                   交   两个集合的交，返回包含两个集合共有元素的集合。   可以用方法 a.intersection(b) 或者操作 a &amp; b 实现。           a.intersection(b)                         {3, 4}                           b.intersection(a)                         {3, 4}                           a &amp; b                         {3, 4}                           print(a &amp; b)                        {3, 4}                  注意：一般使用print打印set的结果与表示方法并不一致。   差   a 和 b 的差集，返回只在 a 不在 b 的元素组成的集合。   可以用方法 a.difference(b) 或者操作 a - b 实现。           a.difference(b)                         {1, 2}                           a - b                         {1, 2}                   注意，a - b 与 b - a并不一样，b - a 返回的是返回 b 不在 a 的元素组成的集合：           b.difference(a)                         {5, 6}                           b - a                          {5, 6}                   对称差   a 和b 的对称差集，返回在 a 或在 b 中，但是不同时在 a 和 b 中的元素组成的集合。   可以用方法 a.symmetric_difference(b) 或者操作 a ^ b 实现（异或操作符）。           a.symmetric_difference(b)                         {1, 2, 5, 6}                           b.symmetric_difference(a)                         {1, 2, 5, 6}                           a ^ b                         {1, 2, 5, 6}                   包含关系   假设现在有这样两个集合：           a = {1, 2, 3} b = {1, 2}            要判断 b 是不是 a 的子集，可以用 b.issubset(a) 方法，或者更简单的用操作 b &lt;= a ：           b.issubset(a)                         True                           b &lt;= a                         True                   与之对应，也可以用 a.issuperset(b) 或者 a &gt;= b 来判断：           a.issuperset(b)                         True                           a &gt;= b                         True                   方法只能用来测试子集，但是操作符可以用来判断真子集：           a &lt;= a                         True                   自己不是自己的真子集：           a &lt; a                         False                   集合方法   add 方法向集合添加单个元素   跟列表的 append 方法类似，用来向集合添加单个元素。   s.add(a)   将元素 a 加入集合 s 中。           t = {1, 2, 3} t.add(5) t                         {1, 2, 3, 5}                   如果添加的是已有元素，集合不改变：           t.add(3) t                         {1, 2, 3, 5}                   update 方法向集合添加多个元素   跟列表的extend方法类似，用来向集合添加多个元素。   s.update(seq)   将seq中的元素添加到s中。           t.update([5, 6, 7]) t                         {1, 2, 3, 5, 6, 7}                   remove 方法移除单个元素   s.remove(ob)   从集合s中移除元素ob，如果不存在会报错。           t.remove(1) t                         {2, 3, 5, 6, 7}                           t.remove(10)                             ---------------------------------------------------------------------------      KeyError                                  Traceback (most recent call last)      &lt;ipython-input-31-c0ded720561a&gt; in &lt;module&gt;     ----&gt; 1 t.remove(10)           KeyError: 10                    pop方法弹出元素   由于集合没有顺序，不能像列表一样按照位置弹出元素，所以pop 方法删除并返回集合中任意一个元素，如果集合中没有元素会报错。           t.pop()                         2                           print (t)                        {3, 5, 6, 7}                          s = set() # 报错 s.pop()                             ---------------------------------------------------------------------------      KeyError                                  Traceback (most recent call last)      &lt;ipython-input-36-9af808d05936&gt; in &lt;module&gt;           1 s = set()           2 # 报错     ----&gt; 3 s.pop()           KeyError: 'pop from an empty set'                    discard 方法   作用与 remove 一样，但是当元素在集合中不存在的时候不会报错。           t.discard(3)                    t                         {5, 6, 7}                   不存在的元素不会报错：           t.discard(20)                    t                         {5, 6, 7}                   difference_update方法   a.difference_update(b)   从a中去除所有属于b的元素：  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/11.html",
        "teaser":null},{
        "title": "02-12 不可变集合",
        
        "excerpt":
            "不可变集合   对应于元组（tuple）与列表（list）的关系，对于集合（set），Python提供了一种叫做不可变集合（frozen set）的数据结构。   使用 frozenset 来进行创建：           s = frozenset([1, 2, 3, 'a', 1]) s                         frozenset({1, 2, 3, 'a'})                   与集合不同的是，不可变集合一旦创建就不可以改变。   不可变集合的一个主要应用是用来作为字典的键，例如用一个字典来记录两个城市之间的距离：           flight_distance = {} city_pair = frozenset(['Los Angeles', 'New York']) flight_distance[city_pair] = 2498 flight_distance[frozenset(['Austin', 'Los Angeles'])] = 1233 flight_distance[frozenset(['Austin', 'New York'])] = 1515 flight_distance                         {frozenset({'Austin', 'Los Angeles'}): 1233,  frozenset({'Austin', 'New York'}): 1515,  frozenset({'Los Angeles', 'New York'}): 2498}                   由于集合不分顺序，所以不同顺序不会影响查阅结果：           flight_distance[frozenset(['New York','Austin'])]                         1515                           flight_distance[frozenset(['Austin','New York'])]                         1515                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/12.html",
        "teaser":null},{
        "title": "02-13 Python 赋值机制",
        
        "excerpt":
            "Python 赋值机制   先看一个例子：           x = [1, 2, 3] y = x x[1] = 100 print (y)                        [1, 100, 3]                  改变变量x的值，变量y的值也随着改变，这与Python内部的赋值机制有关。   简单类型   先来看这一段代码在Python中的执行过程。   x = 500 y = x y = 'foo'      x = 500   Python分配了一个 PyInt 大小的内存 pos1 用来储存对象 500 ，然后，Python在命名空间中让变量 x 指向了这一块内存，注意，整数是不可变类型，所以这块内存的内容是不可变的。                  内存       命名空间                       pos1 : PyInt(500) (不可变)       x : pos1              y = x    Python并没有使用新的内存来储存变量 y 的值，而是在命名空间中，让变量 y 与变量 x 指向了同一块内存空间。                  内存       命名空间                       pos1 : PyInt(500) (不可变)       x : pos1  y : pos1              y = 'foo'   Python此时分配一个 PyStr 大小的内存 pos2 来储存对象 foo ，然后改变变量 y 所指的对象。                  内存       命名空间                       pos1 : PyInt(500) (不可变)  pos2 : PyStr('foo') (不可变)       x : pos1 y : pos2           对这一过程进行验证，可以使用 id 函数。   id(x)   返回变量 x 的内存地址。           x = 500 id(x)                         140462633666992                           y = x id(y)                         140462633666992                   也可以使用 is 来判断是不是指向同一个事物：           x is y                         True                   现在 y 指向另一块内存：           y = 'foo' id(y)                         140462779568680                           x is y                         False                   Python会为每个出现的对象进行赋值，哪怕它们的值是一样的，例如：           x = 500 id(x)                         140462633667120                           y = 500 id(y)                         140462633667152                           x is y                         False                   不过，为了提高内存利用效率，对于一些简单的对象，如一些数值较小的int对象，Python采用了重用对象内存的办法：           x = 2 id(x)                         10919456                           y = 2 id(y)                         10919456                           x is y                         True                   容器类型   现在来看另一段代码：   x = [500, 501, 502] y = x y[1] = 600 y = [700, 800]      x = [500, 501, 502]   Python为3个PyInt分配内存 pos1 ， pos2 ， pos3 （不可变），然后为列表分配一段内存 pos4 ，它包含3个位置，分别指向这3个内存，最后再让变量 x 指向这个列表。                  内存       命名空间                       pos1 : PyInt(500) (不可变)   pos2 : PyInt(501) (不可变)  pos3 : PyInt(502) (不可变)   pos4 : PyList(pos1, pos2, pos3) (可变)       x : pos4              y = x   并没有创建新的对象，只需要将 y 指向 pos4 即可。                  内存       命名空间                       pos1 : PyInt(500) (不可变)   pos2 : PyInt(501) (不可变)   pos3 : PyInt(502) (不可变)   pos4 : PyList(pos1, pos2, pos3) (可变)       x : pos4 y : pos4              y[1] = 600   原来 y[1] 这个位置指向的是 pos2 ，由于不能修改 pos2 的值，所以首先为 600 分配新内存 pos5 。   再把 y[1] 指向的位置修改为 pos5 。此时，由于 pos2 位置的对象已经没有用了，Python会自动调用垃圾处理机制将它回收。                  内存       命名空间                       pos1 : PyInt(500) (不可变)   pos2 : 垃圾回收   pos3 : PyInt(502) (不可变)   pos4 : PyList(pos1, pos5, pos3) (可变) pos5 : PyInt(600) (不可变)       x : pos4  y : pos4              y = [700, 800]   首先创建这个列表，然后将变量 y 指向它。                  内存       命名空间                       pos1 : PyInt(500) (不可变)   pos3 : PyInt(502) (不可变)  pos4 : PyList(pos1, pos5, pos3) (可变) pos5 : PyInt(600) (不可变)  pos6 : PyInt(700) (不可变) pos7 : PyInt(800) (不可变) pos8 : PyList(pos6, pos7) (可变)       x : pos4   y : pos8           对这一过程进行验证：           x = [500, 501, 502] print (id(x[0])) print (id(x[1])) print (id(x[2])) print (id(x))                        140462633667312 140462633667216 140462633666736 140462633924040                  赋值，id(y) 与 id(x) 相同。           y = x print (id(y))                        140462633924040                          x is y                         True                   修改 y[1] ，id(y) 并不改变。           y[1] = 600 print (id(y))                        140462633924040                  id(x[1]) 和 id(y[1]) 的值改变了。           print (id(x[1])) print (id(y[1]))                        140462633667152 140462633667152                  更改 y 的值，id(y) 的值改变           y = [700, 800] print (id(y)) print (id(x))                        140462633416904 140462633924040                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/13.html",
        "teaser":null},{
        "title": "02-14 判断语句",
        
        "excerpt":
            "判断语句   基本用法   判断，基于一定的条件，决定是否要执行特定的一段代码，例如判断一个数是不是正数：           x = 0.5 if x &gt; 0:     print (\"Hey!\")     print (\"x is positive\")                        Hey! x is positive                  在这里，如果 x &gt; 0 为 False ，那么程序将不会执行两条 print 语句。   虽然都是用 if 关键词定义判断，但与C，Java等语言不同，Python不使用 {} 将 if 语句控制的区域包含起来。Python使用的是缩进方法。同时，也不需要用 () 将判断条件括起来。   上面例子中的这两条语句：      print \"Hey!\"     print \"x is positive\"  就叫做一个代码块，同一个代码块使用同样的缩进值，它们组成了这条 if 语句的主体。   不同的缩进值表示不同的代码块，例如：   x &gt; 0 时：           x = 0.5 if x &gt; 0:     print (\"Hey!\")     print (\"x is positive\")     print (\"This is still part of the block\") print (\"This isn't part of the block, and will always print.\")                        Hey! x is positive This is still part of the block This isn't part of the block, and will always print.                  x &lt; 0 时：           x = -0.5 if x &gt; 0:     print (\"Hey!\")     print (\"x is positive\")     print (\"This is still part of the block\") print (\"This isn't part of the block, and will always print.\")                        This isn't part of the block, and will always print.                  在这两个例子中，最后一句并不是if语句中的内容，所以不管条件满不满足，它都会被执行。   一个完整的 if 结构通常如下所示（注意：条件后的 : 是必须要的，缩进值需要一样）：   if &lt;condition 1&gt;:     &lt;statement 1&gt;     &lt;statement 2&gt; elif &lt;condition 2&gt;:      &lt;statements&gt; else:     &lt;statements&gt;   当条件1被满足时，执行 if 下面的语句，当条件1不满足的时候，转到 elif ，看它的条件2满不满足，满足执行 elif 下面的语句，不满足则执行 else 下面的语句。   对于上面的例子进行扩展：           x = 0 if x &gt; 0:     print (\"x is positive\") elif x == 0:     print (\"x is zero\") else:     print (\"x is negative\")                        x is zero                  elif 的个数没有限制，可以是1个或者多个，也可以没有。   else 最多只有1个，也可以没有。   可以使用 and ， or , not 等关键词结合多个判断条件：           x = 10 y = -5 x &gt; 0 and y &lt; 0                         True                           not x &gt; 0                         False                           x &lt; 0 or y &lt; 0                         True                   这里使用这个简单的例子，假如想判断一个年份是不是闰年，按照闰年的定义，这里只需要判断这个年份是不是能被4整除，但是不能被100整除，或者正好被400整除：           year = 1900 if year % 400 == 0:     print (\"This is a leap year!\") # 两个条件都满足才执行 elif year % 4 == 0 and year % 100 != 0:     print (\"This is a leap year!\") else:     print (\"This is not a leap year.\")                        This is not a leap year.                  值的测试   Python不仅仅可以使用布尔型变量作为条件，它可以直接在if中使用任何表达式作为条件：   大部分表达式的值都会被当作True，但以下表达式值会被当作False：      False   None   0   空字符串，空列表，空字典，空集合           mylist = [3, 1, 4, 1, 5, 9] if mylist:     print (\"The first element is:\", mylist[0]) else:     print (\"There is no first element.\")                        The first element is: 3                  修改为空列表：           mylist = [] if mylist:     print (\"The first element is:\", mylist[0]) else:     print (\"There is no first element.\")                        There is no first element.                  当然这种用法并不推荐，推荐使用 if len(mylist) &gt; 0: 来判断一个列表是否为空。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/14.html",
        "teaser":null},{
        "title": "02-15 循环",
        
        "excerpt":
            "循环   循环的作用在于将一段代码重复执行多次。   while 循环   while &lt;condition&gt;:     &lt;statesments&gt;   Python会循环执行&lt;statesments&gt;，直到&lt;condition&gt;不满足为止。   例如，计算数字0到1000000的和：           i = 0 total = 0 while i &lt; 1000000:     total += i     i += 1 print (total)                        499999500000                  之前提到，空容器会被当成 False ，因此可以用 while 循环来读取容器中的所有元素：           plays = set(['Hamlet', 'Macbeth', 'King Lear']) while plays:     play = plays.pop()     print ('Perform', play)                        Perform Macbeth Perform King Lear Perform Hamlet                  循环每次从 plays 中弹出一个元素，一直到 plays 为空为止。   for 循环   for &lt;variable&gt; in &lt;sequence&gt;:     &lt;indented block of code&gt;   for 循环会遍历完&lt;sequence&gt;中所有元素为止   上一个例子可以改写成如下形式：           plays = set(['Hamlet', 'Macbeth', 'King Lear']) for play in plays:     print ('Perform', play)                        Perform Macbeth Perform King Lear Perform Hamlet                  使用 for 循环时，注意尽量不要改变 plays 的值，否则可能会产生意想不到的结果。   之前的求和也可以通过 for 循环来实现：           total = 0 for i in range(100000):     total += i print (total)                        4999950000                  运行时间：           %timeit for i in range(1000000): i = i                        29.3 ms ± 3.03 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)                  可以看出，xrange 用时要比 range 少。   continue 语句   遇到 continue 的时候，程序会返回到循环的最开始重新执行。   例如在循环中忽略一些特定的值：           values = [7, 6, 4, 7, 19, 2, 1] for i in values:     if i % 2 != 0:         # 忽略奇数         continue     print (i/2)                        3.0 2.0 1.0                  break 语句   遇到 break 的时候，程序会跳出循环，不管循环条件是不是满足：           command_list = ['start',                  'process',                  'process',                 'process',                  'stop',                  'start',                  'process',                  'stop'] while command_list:     command = command_list.pop(0)     if command == 'stop':         break     print(command)                        start process process process                  在遇到第一个 'stop' 之后，程序跳出循环。   else语句   与 if 一样， while 和 for 循环后面也可以跟着 else 语句，不过要和break一起连用。      当循环正常结束时，循环条件不满足， else 被执行；   当循环被 break 结束时，循环条件仍然满足， else 不执行。   不执行：           values = [7, 6, 4, 7, 19, 2, 1] for x in values:     if x &lt;= 10:         print ('Found:', x)         break else:     print ('All values greater than 10')                        Found: 7                  执行：           values = [11, 12, 13, 100] for x in values:     if x &lt;= 10:         print ('Found:', x)         break else:     print ('All values greater than 10')                        All values greater than 10                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/15.html",
        "teaser":null},{
        "title": "02-16 列表推导式",
        
        "excerpt":
            "列表推导式   循环可以用来生成列表：           values = [10, 21, 4, 7, 12] squares = [] for x in values:     squares.append(x**2) print (squares)                        [100, 441, 16, 49, 144]                  列表推导式可以使用更简单的方法来创建这个列表：           values = [10, 21, 4, 7, 12] squares = [x**2 for x in values] print (squares)                        [100, 441, 16, 49, 144]                  还可以在列表推导式中加入条件进行筛选。   例如在上面的例子中，假如只想保留列表中不大于10的数的平方：           values = [10, 21, 4, 7, 12] squares = [x**2 for x in values if x &lt;= 10] print (squares)                        [100, 16, 49]                  也可以使用推导式生成集合和字典：           square_set = {x**2 for x in values if x &lt;= 10} print(square_set) square_dict = {x: x**2 for x in values if x &lt;= 10} print(square_dict)                        {16, 49, 100} {10: 100, 4: 16, 7: 49}                  再如，计算上面例子中生成的列表中所有元素的和：           total = sum([x**2 for x in values if x &lt;= 10]) print(total)                        165                  但是，Python会生成这个列表，然后在将它放到垃圾回收机制中（因为没有变量指向它），这毫无疑问是种浪费。   为了解决这种问题，与xrange()类似，Python使用产生式表达式来解决这个问题：           total = sum(x**2 for x in values if x &lt;= 10) print(total)                        165                  与上面相比，只是去掉了括号，但这里并不会一次性的生成这个列表。   比较一下两者的用时：           x = range(1000000)                    %timeit total = sum([i**2 for i in x])                        335 ms ± 39.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)                          %timeit total = sum(i**2 for i in x)                        305 ms ± 2.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/16.html",
        "teaser":null},{
        "title": "02-17 函数",
        
        "excerpt":
            "函数   定义函数   函数function，通常接受输入参数，并有返回值。   它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性。           def add(x, y):     \"\"\"Add two numbers\"\"\"     a = x + y     return a            函数通常有一下几个特征：     使用 def 关键词来定义一个函数。   def 后面是函数的名称，括号中是函数的参数，不同的参数用 , 隔开， def foo(): 的形式是必须要有的，参数可以为空；   使用缩进来划分函数的内容；   docstring 用 \"\"\" 包含的字符串，用来解释函数的用途，可省略；   return 返回特定的值，如果省略，返回 None 。   使用函数   使用函数时，只需要将参数换成特定的值传给函数。   Python并没有限定参数的类型，因此可以使用不同的参数类型：           print (add(2, 3)) print (add('foo', 'bar'))                        5 foobar                  在这个例子中，如果传入的两个参数不可以相加，那么Python会将报错：           print (add(2, \"foo\"))                             ---------------------------------------------------------------------------      TypeError                                 Traceback (most recent call last)      &lt;ipython-input-3-fc607c31368f&gt; in &lt;module&gt;     ----&gt; 1 print (add(2, \"foo\"))           &lt;ipython-input-1-a0af632d0680&gt; in add(x, y)           1 def add(x, y):           2     \"\"\"Add two numbers\"\"\"     ----&gt; 3     a = x + y           4     return a           TypeError: unsupported operand type(s) for +: 'int' and 'str'                    如果传入的参数数目与实际不符合，也会报错：           print (add(1, 2, 3))                             ---------------------------------------------------------------------------      TypeError                                 Traceback (most recent call last)      &lt;ipython-input-4-199dc382af0f&gt; in &lt;module&gt;     ----&gt; 1 print (add(1, 2, 3))           TypeError: add() takes 2 positional arguments but 3 were given                            print (add(1))                             ---------------------------------------------------------------------------      TypeError                                 Traceback (most recent call last)      &lt;ipython-input-5-15efd13f3023&gt; in &lt;module&gt;     ----&gt; 1 print (add(1))           TypeError: add() missing 1 required positional argument: 'y'                    传入参数时，Python提供了两种选项，第一种是上面使用的按照位置传入参数，另一种则是使用关键词模式，显式地指定参数的值：           print (add(x=2, y=3)) print (add(y=\"foo\", x=\"bar\"))                        5 barfoo                  可以混合这两种模式：           print (add(2, y=3))                        5                  设定参数默认值   可以在函数定义的时候给参数设定默认值，例如：           def quad(x, a=1, b=0, c=0):     return a*x**2 + b*x + c            可以省略有默认值的参数：           print (quad(2.0))                        4.0                  可以修改参数的默认值：           print (quad(2.0, b=3))                        10.0                          print (quad(2.0, 2, c=4))                        12.0                  这里混合了位置和指定两种参数传入方式，第二个2是传给 a 的。   注意，在使用混合语法时，要注意不能给同一个值赋值多次，否则会报错，例如：           print (quad(2.0, 2, a=2))                             ---------------------------------------------------------------------------      TypeError                                 Traceback (most recent call last)      &lt;ipython-input-12-396c5b01c664&gt; in &lt;module&gt;     ----&gt; 1 print (quad(2.0, 2, a=2))           TypeError: quad() got multiple values for argument 'a'                    接收不定参数   使用如下方法，可以使函数接受不定数目的参数：           def add(x, *args):     total = x     for arg in args:         total += arg     return total            这里，*args 表示参数数目不定，可以看成一个元组，把第一个参数后面的参数当作元组中的元素。           print (add(1, 2, 3, 4)) print (add(1, 2))                        10 3                  这样定义的函数不能使用关键词传入参数，要使用关键词，可以这样：           def add(x, **kwargs):     total = x     for arg, value in kwargs.items():         print (\"adding \", arg)         total += value     return total            这里， **kwargs 表示参数数目不定，相当于一个字典，关键词和值对应于键值对。           print (add(10, y=11, z=12, w=13))                        adding  z adding  w adding  y 46                  再看这个例子，可以接收任意数目的位置参数和键值对参数：           def foo(*args, **kwargs):     print (args, kwargs)  foo(2, 3, x='bar', z=10)                        (2, 3) {'z': 10, 'x': 'bar'}                  不过要按顺序传入参数，先传入位置参数 args ，在传入关键词参数 kwargs 。   返回多个值   函数可以返回多个值：           from math import atan2  def to_polar(x, y):     r = (x**2 + y**2) ** 0.5     theta = atan2(y, x)     return r, theta  r, theta = to_polar(3, 4) print (r, theta)                        5.0 0.9272952180016122                  事实上，Python将返回的两个值变成了元组：           print (to_polar(3, 4))                        (5.0, 0.9272952180016122)                  因为这个元组中有两个值，所以可以使用   r, theta = to_polar(3, 4)   给两个值赋值。   列表也有相似的功能：           a, b, c = [1, 2, 3] print (a, b, c)                        1 2 3                  事实上，不仅仅返回值可以用元组表示，也可以将参数用元组以这种方式传入：           def add(x, y):     \"\"\"Add two numbers\"\"\"     a = x + y     return a      z = (2, 3) print (add(*z))                        5                  这里的*必不可少。   事实上，还可以通过字典传入参数来执行函数：           def add(x, y):     \"\"\"Add two numbers\"\"\"     a = x + y     return a  w = {'x': 2, 'y': 3} print (add(**w))                        5                  map 方法生成序列   可以通过 map 的方式利用函数来生成序列：           def sqr(x):      return x ** 2  a = [2,3,4] print (map(sqr, a))                        &lt;map object at 0x7fd4f42eb2b0&gt;                  其用法为：   map(aFun, aSeq)   将函数 aFun 应用到序列 aSeq 上的每一个元素上，返回一个列表，不管这个序列原来是什么类型。   事实上，根据函数参数的多少，map 可以接受多组序列，将其对应的元素作为参数传入函数：           def add(x, y):      return x + y  a = (2,3,4) b = [10,5,3] print (map(add,a,b))                        &lt;map object at 0x7fd4f42eb748&gt;                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/17.html",
        "teaser":null},{
        "title": "02-18 模块和包",
        
        "excerpt":
            "模块和包   模块   Python会将所有 .py 结尾的文件认定为Python代码文件，考虑下面的脚本 ex1.py ：           %%writefile ex1.py  PI = 3.1416  def sum(lst):     tot = lst[0]     for value in lst[1:]:         tot = tot + value     return tot      w = [0, 1, 2, 3] print (sum(w), PI)                        Overwriting ex1.py                  可以执行它：           %run ex1.py                        6 3.1416                  这个脚本可以当作一个模块，可以使用import关键词加载并执行它（这里要求ex1.py在当前工作目录）：           import ex1                        6 3.1416                          ex1                         &lt;module 'ex1' from '/home/jovyan/work/2. python-essentials/ex1.py'&gt;                   在导入时，Python会执行一遍模块中的所有内容。   ex1.py 中所有的变量都被载入了当前环境中，不过要使用   ex1.变量名   的方法来查看或者修改这些变量：           print (ex1.PI)                        3.1416                          ex1.PI = 3.141592653 print (ex1.PI)                        3.141592653                  还可以用   ex1.函数名   调用模块里面的函数：           print (ex1.sum([2, 3, 4]))                        9                  为了提高效率，Python只会载入模块一次，已经载入的模块再次载入时，Python并不会真正执行载入操作，哪怕模块的内容已经改变。   例如，这里重新导入 ex1 时，并不会执行 ex1.py 中的 print 语句：           import ex1            需要重新导入模块时，可以使用reload强制重新载入它，例如：           from imp import reload reload(ex1)                        6 3.1416                               &lt;module 'ex1' from '/home/jovyan/work/2. python-essentials/ex1.py'&gt;                   删除之前生成的文件：           import os os.remove('ex1.py')            __name__ 属性   有时候我们想将一个 .py 文件既当作脚本，又能当作模块用，这个时候可以使用 __name__ 这个属性。   只有当文件被当作脚本执行的时候， __name__的值才会是 '__main__'，所以我们可以：           %%writefile ex2.py  PI = 3.1416  def sum(lst):     \"\"\" Sum the values in a list     \"\"\"     tot = 0     for value in lst:         tot = tot + value     return tot  def add(x, y):     \" Add two values.\"     a = x + y     return a  def test():     w = [0,1,2,3]     assert(sum(w) == 6)     print ('test passed.')      if __name__ == '__main__':     test()                        Writing ex2.py                  运行文件：           %run ex2.py                        test passed.                  当作模块导入， test() 不会执行：           import ex2            但是可以使用其中的变量：           ex2.PI                         3.1416                   使用别名：           import ex2 as e2 e2.PI                         3.1416                   其他导入方法   可以从模块中导入变量：           from ex2 import add, PI            使用 from 后，可以直接使用 add ， PI：           add(2, 3)                         5                   或者使用 * 导入所有变量：           from ex2 import * add(3, 4.5)                         7.5                   这种导入方法不是很提倡，因为如果你不确定导入的都有哪些，可能覆盖一些已有的函数。   删除文件：           import os os.remove('ex2.py')            包   假设我们有这样的一个文件夹：   foo/     __init__.py   bar.py (defines func)   baz.py (defines zap)   这意味着 foo 是一个包，我们可以这样导入其中的内容：   from foo.bar import func from foo.baz import zap   bar 和 baz 都是 foo 文件夹下的 .py 文件。   导入包要求：     文件夹 foo 在Python的搜索路径中   __init__.py 表示 foo 是一个包，它可以是个空文件。   常用的标准库      re 正则表达式   copy 复制   math, cmath 数学   decimal, fraction   sqlite3 数据库   os, os.path 文件系统   gzip, bz2, zipfile, tarfile 压缩文件   csv, netrc 各种文件格式   xml   htmllib   ftplib, socket   cmd 命令行   pdb   profile, cProfile, timeit   collections, heapq, bisect 数据结构   mmap   threading, Queue 并行   multiprocessing   subprocess   pickle, cPickle   struct   PYTHONPATH设置   Python的搜索路径可以通过环境变量PYTHONPATH设置，环境变量的设置方法依操作系统的不同而不同，具体方法可以网上搜索。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/18.html",
        "teaser":null},{
        "title": "02-19 异常",
        
        "excerpt":
            "异常   try &amp; except 块   写代码的时候，出现错误必不可免，即使代码没有问题，也可能遇到别的问题。   看下面这段代码：   import math  while True:     text = input('&gt; ')     if text[0] == 'q':         break     x = float(text)     y = math.log10(x)     print \"log10({0}) = {1}\".format(x, y)   这段代码接收命令行的输入，当输入为数字时，计算它的对数并输出，直到输入值为 q 为止。   乍看没什么问题，然而当我们输入0或者负数时：           import math  while True:     text = input('&gt; ')     if text[0] == 'q':         break     x = float(text)     y = math.log10(x)     print (\"log10({0}) = {1}\".format(x, y))            log10 函数会报错，因为不能接受非正值。   一旦报错，程序就会停止执行，如果不希望程序停止执行，那么我们可以添加一对 try &amp; except：   import math  while True:     try:         text = input('&gt; ')         if text[0] == 'q':             break         x = float(text)         y = math.log10(x)         print \"log10({0}) = {1}\".format(x, y)     except ValueError:         print \"the value must be greater than 0\"   一旦 try 块中的内容出现了异常，那么 try 块后面的内容会被忽略，Python会寻找 except 里面有没有对应的内容，如果找到，就执行对应的块，没有则抛出这个异常。   在上面的例子中，try 抛出的是 ValueError，except 中有对应的内容，所以这个异常被 except 捕捉到，程序可以继续执行：           import math  while True:     try:         text = input('&gt; ')         if text[0] == 'q':             break         x = float(text)         y = math.log10(x)         print (\"log10({0}) = {1}\".format(x, y))     except ValueError:         print (\"the value must be greater than 0\")            捕捉不同的错误类型   import math  while True:     try:         text = input('&gt; ')         if text[0] == 'q':             break         x = float(text)         y = 1 / math.log10(x)         print \"log10({0}) = {1}\".format(x, y)     except ValueError:         print \"the value must be greater than 0\"   假设我们将这里的 y 更改为 1 / math.log10(x)，此时输入 1：           import math  while True:     try:         text = input('&gt; ')         if text[0] == 'q':             break         x = float(text)         y = 1 / math.log10(x)         print (\"log10({0}) = {1}\".format(x, y))     except ValueError:         print (\"the value must be greater than 0\")            因为我们的 except 里面并没有 ZeroDivisionError，所以会抛出这个异常，我们可以通过两种方式解决这个问题：   捕捉所有异常   将except 的值改成 Exception 类，来捕获所有的异常。           import math  while True:     try:         text = input('&gt; ')         if text[0] == 'q':             break         x = float(text)         y = 1 / math.log10(x)         print (\"1 / log10({0}) = {1}\".format(x, y))     except Exception:         print (\"invalid value\")            指定特定值   这里，我们把 ZeroDivisionError 加入 except 。           import math  while True:     try:         text = input('&gt; ')         if text[0] == 'q':             break         x = float(text)         y = 1 / math.log10(x)         print (\"1 / log10({0}) = {1}\".format(x, y))     except (ValueError, ZeroDivisionError):         print (\"invalid value\")            或者另加处理：           import math  while True:     try:         text = input('&gt; ')         if text[0] == 'q':             break         x = float(text)         y = 1 / math.log10(x)         print (\"1 / log10({0}) = {1}\".format(x, y))     except ValueError:         print (\"the value must be greater than 0\")     except ZeroDivisionError:         print (\"the value must not be 1\")            事实上,我们还可以将这两种方式结合起来,用 Exception 来捕捉其他的错误：           import math  while True:     try:         text = input('&gt; ')         if text[0] == 'q':             break         x = float(text)         y = 1 / math.log10(x)         print (\"1 / log10({0}) = {1}\".format(x, y))     except ValueError:         print (\"the value must be greater than 0\")     except ZeroDivisionError:         print (\"the value must not be 1\")     except Exception:         print (\"unexpected error\")            得到异常的具体信息   在上面的例子中，当我们输入不能转换为浮点数的字符串时，它输出的是 the value must be greater than 0，这并没有反映出实际情况。           float('a')            为了得到异常的具体信息，我们将这个 ValueError 具现化：           import math  while True:     try:         text = input('&gt; ')         if text[0] == 'q':             break         x = float(text)         y = 1 / math.log10(x)         print (\"1 / log10({0}) = {1}\".format(x, y))     except ValueError as exc:         if exc.message == \"math domain error\":             print (\"the value must be greater than 0\")         else:             print (\"could not convert '%s' to float\" % text)     except ZeroDivisionError:         print (\"the value must not be 1\")     except Exception as exc:         print (\"unexpected error:\", exc.message)            同时，我们也将捕获的其他异常的信息显示出来。   这里，exc.message 显示的内容是异常对应的说明，例如   ValueError: could not convert string to float: a   对应的 message 是   could not convert string to float: a   当我们使用 except Exception 时，会捕获所有的 Exception 和它派生出来的子类，但不是所有的异常都是从 Exception 类派生出来的，可能会出现一些不能捕获的情况，因此，更加一般的做法是使用这样的形式：   try:     pass except:     pass   这样不指定异常的类型会捕获所有的异常，但是这样的形式并不推荐。   自定义异常   异常是标准库中的类，这意味着我们可以自定义异常类：           class CommandError(ValueError):     pass            这里我们定义了一个继承自 ValueError 的异常类，异常类一般接收一个字符串作为输入，并把这个字符串当作异常信息，例如：           valid_commands = {'start', 'stop', 'pause'}  while True:     command = input('&gt; ')     if command.lower() not in valid_commands:         raise CommandError('Invalid commmand: %s' % command)            我们使用 raise 关键词来抛出异常。   我们可以使用 try/except 块来捕捉这个异常：   valid_commands = {'start', 'stop', 'pause'}  while True:     command = input('&gt; ')     try:         if command.lower() not in valid_commands:             raise CommandError('Invalid commmand: %s' % command)     except CommandError:         print ('Bad command string: \"%s\"' % command)   由于 CommandError 继承自 ValueError，我们也可以使用 except ValueError 来捕获这个异常。   finally   try/catch 块还有一个可选的关键词 finally。   不管 try 块有没有异常， finally 块的内容总是会被执行，而且会在抛出异常前执行，因此可以用来作为安全保证，比如确保打开的文件被关闭。。           try:     print (1) finally:     print ('finally was called.')                        1 finally was called.                  在抛出异常前执行：           try:     print (1 / 0) finally:     print ('finally was called.')                        finally was called.                                   ---------------------------------------------------------------------------      ZeroDivisionError                         Traceback (most recent call last)      &lt;ipython-input-20-b1710967a0a4&gt; in &lt;module&gt;           1 try:     ----&gt; 2     print (1 / 0)           3 finally:           4     print ('finally was called.')           ZeroDivisionError: division by zero                    如果异常被捕获了，在最后执行：           try:     print (1 / 0) except ZeroDivisionError:     print ('divide by 0.') finally:     print ('finally was called.')                        divide by 0. finally was called.                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/19.html",
        "teaser":null},{
        "title": "02-20 警告",
        
        "excerpt":
            "警告   出现了一些需要让用户知道的问题，但又不想停止程序，这时候我们可以使用警告：   首先导入警告模块：           import warnings            在需要的地方，我们使用 warnings 中的 warn 函数：   warn(msg, WarningType = UserWarning)           def month_warning(m):     if not 1&lt;= m &lt;= 12:         msg = \"month (%d) is not between 1 and 12\" % m         warnings.warn(msg, RuntimeWarning)  month_warning(13)            有时候我们想要忽略特定类型的警告，可以使用 warnings 的 filterwarnings 函数：   filterwarnings(action, category)   将 action 设置为 'ignore' 便可以忽略特定类型的警告：           warnings.filterwarnings(action = 'ignore', category = RuntimeWarning)  month_warning(13)           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/20.html",
        "teaser":null},{
        "title": "02-21 文件读写",
        
        "excerpt":
            "文件读写   写入测试文件：           %%writefile test.txt this is a test file. hello world! python is good! today is a good day.            读文件   使用 open 函数来读文件，使用文件名的字符串作为输入参数：           f = open('test.txt')            默认以读的方式打开文件，如果文件不存在会报错。   可以使用 read 方法来读入文件中的所有内容：           text = f.read() print (text)            也可以按照行读入内容，readlines 方法返回一个列表，每个元素代表文件中每一行的内容：           f = open('test.txt') lines = f.readlines() print (lines)            使用完文件之后，需要将文件关闭。           f.close()            事实上，我们可以将 f 放在一个循环中，得到它每一行的内容：           f = open('test.txt') for line in f:     print (line) f.close()            删除刚才创建的文件：           import os os.remove('test.txt')            写文件   我们使用 open 函数的写入模式来写文件：           f = open('myfile.txt', 'w') f.write('hello world!') f.close()            使用 w 模式时，如果文件不存在会被创建，我们可以查看是否真的写入成功：           print (open('myfile.txt').read())            如果文件已经存在， w 模式会覆盖之前写的所有内容：           f = open('myfile.txt', 'w') f.write('another hello world!') f.close() print (open('myfile.txt').read())            除了写入模式，还有追加模式 a ，追加模式不会覆盖之前已经写入的内容，而是在之后继续写入：           f = open('myfile.txt', 'a') f.write('... and more') f.close() print (open('myfile.txt').read())            写入结束之后一定要将文件关闭，否则可能出现内容没有完全写入文件中的情况。   还可以使用读写模式 w+：           f = open('myfile.txt', 'w+') f.write('hello world!') f.seek(6) print (f.read()) f.close()            这里 f.seek(6) 移动到文件的第6个字符处，然后 f.read() 读出剩下的内容。           import os os.remove('myfile.txt')            二进制文件   二进制读写模式 b：           import os f = open('binary.bin', 'wb') f.write(os.urandom(16)) f.close()  f = open('binary.bin', 'rb') print (repr(f.read())) f.close()                    import os os.remove('binary.bin')            换行符   不同操作系统的换行符可能不同：      \\r   \\n   \\r\\n   使用 U 选项，可以将这三个统一看成 \\n 换行符。   关闭文件   在Python中，如果一个打开的文件不再被其他变量引用时，它会自动关闭这个文件。   所以正常情况下，如果一个文件正常被关闭了，忘记调用文件的 close 方法不会有什么问题。   关闭文件可以保证内容已经被写入文件，而不关闭可能会出现意想不到的结果：           f = open('newfile.txt','w') f.write('hello world') g = open('newfile.txt', 'r') print (repr(g.read()))            虽然这里写了内容，但是在关闭之前，这个内容并没有被写入磁盘。   使用循环写入的内容也并不完整：           f = open('newfile.txt','w') for i in range(3000):     f.write('hello world: ' + str(i) + '\\n')  g = open('newfile.txt', 'r') print (g.read()) f.close() g.close()                    import os os.remove('newfile.txt')            出现异常时候的读写：           f = open('newfile.txt','w') for i in range(3000):     x = 1.0 / (i - 1000)     f.write('hello world: ' + str(i) + '\\n')            查看已有内容：           g = open('newfile.txt', 'r') print (g.read()) f.close() g.close()            可以看到，出现异常的时候，磁盘的写入并没有完成，为此我们可以使用 try/except/finally 块来关闭文件，这里 finally 确保关闭文件，所有的写入已经完成。           f = open('newfile.txt','w') try:     for i in range(3000):         x = 1.0 / (i - 1000)         f.write('hello world: ' + str(i) + '\\n') except Exception:     print \"something bad happened\" finally:     f.close()                    g = open('newfile.txt', 'r') print g.read() g.close()            with 方法   事实上，Python提供了更安全的方法，当 with 块的内容结束后，Python会自动调用它的close 方法，确保读写的安全：           with open('newfile.txt','w') as f:     for i in range(3000):         x = 1.0 / (i - 1000)         f.write('hello world: ' + str(i) + '\\n')            与 try/exception/finally 效果相同，但更简单。           g = open('newfile.txt', 'r') print g.read() g.close()            所以，写文件时候要确保文件被正确关闭。           import os os.remove('newfile.txt')           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/21.html",
        "teaser":null},{
        "title": "第2章 Python基础",
        
        "excerpt":
            "第2章 Python 基础   02-1-Python 入门演示   02-2-Python 数据类型   02-3-Python 数字   02-4-Python 字符串   02-5-索引和切片   02-6-列表   02-7-可变和不可变类型   02-8-元组   02-9-列表与元组的速度比较   02-10-字典   02-11-集合   02-12-不可变集合   02-13-Python 赋值机制   02-14-判断语句   02-15-循环   02-16-列表推导式   02-17-函数   02-18-模块和包   02-19-异常   02-20-警告   02-21-文件读写  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/02/features.html",
        "teaser":null},{
        "title": "03-01 sys 模块简介",
        
        "excerpt":
            "sys 模块简介           import sys            命令行参数   sys.argv 显示传入的参数：           %%writefile print_args.py import sys print (sys.argv)                        Writing print_args.py                  运行这个程序：           %run print_args.py 1 foo                        ['print_args.py', '1', 'foo']                  第一个参数 （sys.args[0]） 表示的始终是执行的文件名，然后依次显示传入的参数。   删除刚才生成的文件：           import os os.remove('print_args.py')            异常消息   sys.exc_info() 可以显示 Exception 的信息，返回一个 (type, value, traceback) 组成的三元组，可以与 try/catch 块一起使用：           try:     x = 1/0 except Exception:     print (sys.exc_info())                        (&lt;class 'ZeroDivisionError'&gt;, ZeroDivisionError('division by zero',), &lt;traceback object at 0x7f08742c76c8&gt;)                  sys.exc_clear() 用于清除所有的异常消息。   标准输入输出流      sys.stdin   sys.stdout   sys.stderr   退出Python   sys.exit(arg=0) 用于退出 Python。0 或者 None 表示正常退出，其他值表示异常。   Python Path   sys.path 表示 Python 搜索模块的路径和查找顺序：           sys.path                         ['',  '/home/jovyan/.virtualenvs/basenv/lib/python3.5/site-packages',  '/home/jovyan/work/.localenv/lib/python35.zip',  '/home/jovyan/work/.localenv/lib/python3.5',  '/home/jovyan/work/.localenv/lib/python3.5/plat-x86_64-linux-gnu',  '/home/jovyan/work/.localenv/lib/python3.5/lib-dynload',  '/usr/lib/python3.5',  '/usr/lib/python3.5/plat-x86_64-linux-gnu',  '/home/jovyan/work/.localenv/lib/python3.5/site-packages',  '/usr/local/lib/python3.5/dist-packages',  '/usr/lib/python3/dist-packages',  '/home/jovyan/.virtualenvs/basenv/lib/python3.5/site-packages/IPython/extensions',  '/home/jovyan/.ipython']                   在程序中可以修改，添加新的路径。   操作系统信息   sys.platform 显示当前操作系统信息：      Windows: win32   Mac OSX: darwin   Linux:   linux2           sys.platform                         'linux'                   Python 版本信息           sys.version                         '3.5.2 (default, Nov 23 2017, 16:37:01) \\n[GCC 5.4.0 20160609]'                           sys.version_info                         sys.version_info(major=3, minor=5, micro=2, releaselevel='final', serial=0)                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/01.html",
        "teaser":null},{
        "title": "03-02 与操作系统进行交互：os 模块",
        
        "excerpt":
            "与操作系统进行交互：os 模块   os 模块提供了对系统文件进行操作的方法：           import os            文件路径操作      os.remove(path) 或 os.unlink(path) ：删除指定路径的文件。路径可以是全名，也可以是当前工作目录下的路径。   os.removedirs：删除文件，并删除中间路径中的空文件夹   os.chdir(path)：将当前工作目录改变为指定的路径   os.getcwd()：返回当前的工作目录   os.curdir：表示当前目录的符号   os.rename(old, new)：重命名文件   os.renames(old, new)：重命名文件，如果中间路径的文件夹不存在，则创建文件夹   os.listdir(path)：返回给定目录下的所有文件夹和文件名，不包括 '.' 和 '..' 以及子文件夹下的目录。（'.' 和 '..' 分别指当前目录和父目录）   os.mkdir(name)：产生新文件夹   os.makedirs(name)：产生新文件夹，如果中间路径的文件夹不存在，则创建文件夹   当前目录：           os.getcwd()            当前目录的符号：           os.curdir            当前目录下的文件：           os.listdir(os.curdir)            产生文件：           f = open(\"test.file\", \"w\") f.close()  print (\"test.file\" in os.listdir(os.curdir))            重命名文件：           os.rename(\"test.file\", \"test.new.file\")  print (\"test.file\" in os.listdir(os.curdir)) print (\"test.new.file\" in os.listdir(os.curdir))            删除文件：           os.remove(\"test.new.file\")            系统常量   当前操作系统的换行符：           # windows 为 \\r\\n os.linesep            当前操作系统的路径分隔符：           os.sep            当前操作系统的环境变量中的分隔符（';' 或 ':'）：           os.pathsep            其他   os.getenv 是一个存储所有环境变量的值的字典，可以修改。           os.getenv('USER')            os.urandom(len) 返回指定长度的随机字节。   os.path 模块   不同的操作系统使用不同的路径规范，这样当我们在不同的操作系统下进行操作时，可能会带来一定的麻烦，而 os.path 模块则帮我们解决了这个问题。           import os.path            测试      os.path.isfile(path) ：检测一个路径是否为普通文件   os.path.isdir(path)：检测一个路径是否为文件夹   os.path.exists(path)：检测路径是否存在   os.path.isabs(path)：检测路径是否为绝对路径   split 和 join      os.path.split(path)：拆分一个路径为 (head, tail) 两部分   os.path.join(a, *p)：使用系统的路径分隔符，将各个部分合成一个路径   其他      os.path.abspath()：返回路径的绝对路径   os.path.dirname(path)：返回路径中的文件夹部分   os.path.basename(path)：返回路径中的文件部分   os.path.splitext(path)：将路径与扩展名分开   os.path.expanduser(path)：展开 '~' 和 '~user'  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/02.html",
        "teaser":null},{
        "title": "03-03 CSV 文件和 csv 模块",
        
        "excerpt":
            "CSV 文件和 csv 模块   标准库中有自带的 csv (逗号分隔值) 模块处理 csv 格式的文件：           import csv            读 csv 文件   假设我们有这样的一个文件：           %%file data.csv \"alpha 1\",  100, -1.443 \"beat  3\",   12, -0.0934 \"gamma 3a\", 192, -0.6621 \"delta 2a\",  15, -4.515                        Writing data.csv                  打开这个文件，并产生一个文件 reader：           fp = open(\"data.csv\") r = csv.reader(fp)            可以按行迭代数据：           for row in r:     print (row)      fp.close()                        ['alpha 1', '  100', ' -1.443'] ['beat  3', '   12', ' -0.0934'] ['gamma 3a', ' 192', ' -0.6621'] ['delta 2a', '  15', ' -4.515']                  默认数据内容都被当作字符串处理，不过可以自己进行处理：           data = []  with open('data.csv') as fp:     r = csv.reader(fp)     for row in r:         data.append([row[0], int(row[1]), float(row[2])])      data                         [['alpha 1', 100, -1.443],  ['beat  3', 12, -0.0934],  ['gamma 3a', 192, -0.6621],  ['delta 2a', 15, -4.515]]                           import os os.remove('data.csv')            写 csv 文件   可以使用 csv.writer 写入文件，不过相应地，传入的应该是以写方式打开的文件，不过一般要用 'wb' 即二进制写入方式，防止出现换行不正确的问题：           data = [('one', 1, 1.5), ('two', 2, 8.0)] with open('out.csv', 'w') as fp:     w = csv.writer(fp)     w.writerows(data)            显示结果：           ! cat 'out.csv'                                           更换分隔符   默认情况下，csv 模块默认 csv 文件都是由 excel 产生的，实际中可能会遇到这样的问题：           data = [('one, \\\"real\\\" string', 1, 1.5), ('two', 2, 8.0)] with open('out.csv', 'w') as fp:     w = csv.writer(fp)     w.writerows(data)                    !cat 'out.csv'                                           可以修改分隔符来处理这组数据：           data = [('one, \\\"real\\\" string', 1, 1.5), ('two', 2, 8.0)] with open('out.psv', 'w') as fp:     w = csv.writer(fp, delimiter=\"|\")     w.writerows(data)                    ! cat 'out.psv'                                                   import os os.remove('out.psv') os.remove('out.csv')            其他选项   numpy.loadtxt() 和 pandas.read_csv() 可以用来读写包含很多数值数据的 csv 文件：           %%file trades.csv Order,Date,Stock,Quantity,Price A0001,2013-12-01,AAPL,1000,203.4 A0002,2013-12-01,MSFT,1500,167.5 A0003,2013-12-02,GOOG,1500,167.5                        Writing trades.csv                  使用 pandas 进行处理，生成一个 DataFrame 对象：           import pandas df = pandas.read_csv('trades.csv', index_col=0) print (df)                                     Date Stock  Quantity  Price Order                                    A0001  2013-12-01  AAPL      1000  203.4 A0002  2013-12-01  MSFT      1500  167.5 A0003  2013-12-02  GOOG      1500  167.5                  通过名字进行索引：           df['Quantity'] * df['Price']                         Order A0001    203400.0 A0002    251250.0 A0003    251250.0 dtype: float64                           import os os.remove('trades.csv')           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/03.html",
        "teaser":null},{
        "title": "03-04 正则表达式和 re 模块",
        
        "excerpt":
            "正则表达式和 re 模块   正则表达式   正则表达式是用来匹配字符串或者子串的一种模式，匹配的字符串可以很具体，也可以很一般化。   Python 标准库提供了 re 模块。           import re            re.match &amp; re.search   在 re 模块中， re.match 和 re.search 是常用的两个方法：   re.match(pattern, string[, flags]) re.search(pattern, string[, flags])   两者都寻找第一个匹配成功的部分，成功则返回一个 match 对象，不成功则返回 None，不同之处在于 re.match 只匹配字符串的开头部分，而 re.search 匹配的则是整个字符串中的子串。   re.findall &amp; re.finditer   re.findall(pattern, string) 返回所有匹配的对象， re.finditer 则返回一个迭代器。   re.split   re.split(pattern, string[, maxsplit]) 按照 pattern 指定的内容对字符串进行分割。   re.sub   re.sub(pattern, repl, string[, count]) 将 pattern 匹配的内容进行替换。   re.compile   re.compile(pattern) 生成一个 pattern 对象，这个对象有匹配，替换，分割字符串的方法。   正则表达式规则   正则表达式由一些普通字符和一些元字符（metacharacters）组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义：                  子表达式       匹配内容                       .       匹配除了换行符之外的内容                 \\w       匹配所有字母和数字字符                 \\d       匹配所有数字，相当于 [0-9]                 \\s       匹配空白，相当于 [\\t\\n\\t\\f\\v]                 \\W,\\D,\\S       匹配对应小写字母形式的补                 [...]       表示可以匹配的集合，支持范围表示如 a-z, 0-9 等                 (...)       表示作为一个整体进行匹配                 ¦       表示逻辑或                 ^       表示匹配后面的子表达式的补                 *       表示匹配前面的子表达式 0 次或更多次                 +       表示匹配前面的子表达式 1 次或更多次                 ?       表示匹配前面的子表达式 0 次或 1 次                 {m}       表示匹配前面的子表达式 m 次                 {m,}       表示匹配前面的子表达式至少 m 次                 {m,n}       表示匹配前面的子表达式至少 m 次，至多 n 次           例如：      ca*t       匹配： ct, cat, caaaat, ...   ab\\d|ac\\d  匹配： ab1, ac9, ...   ([^a-q]bd) 匹配： rbd, 5bd, ...   例子   假设我们要匹配这样的字符串：           string = 'hello world' pattern = 'hello (\\w+)'  match = re.match(pattern, string) print (match)                        &lt;_sre.SRE_Match object; span=(0, 11), match='hello world'&gt;                  一旦找到了符合条件的部分，我们便可以使用 group 方法查看匹配的部分：           if match is not None:     print (match.group(0))                        hello world                          if match is not None:     print (match.group(1))                        world                  我们可以改变 string 的内容：           string = 'hello there' pattern = 'hello (\\w+)'  match = re.match(pattern, string) if match is not None:     print (match.group(0))     print (match.group(1))                        hello there there                  通常，match.group(0) 匹配整个返回的内容，之后的 1,2,3,... 返回规则中每个括号（按照括号的位置排序）匹配的部分。   如果某个 pattern 需要反复使用，那么我们可以将它预先编译：           pattern1 = re.compile('hello (\\w+)')  match = pattern1.match(string) if match is not None:     print (match.group(1))                        there                  由于元字符的存在，所以对于一些特殊字符，我们需要使用 '\\' 进行逃逸字符的处理，使用表达式 '\\\\' 来匹配 '\\' 。   但事实上，Python 本身对逃逸字符也是这样处理的：           pattern = '\\\\' print (pattern)                        \\                  因为逃逸字符的问题，我们需要使用四个 '\\\\\\\\' 来匹配一个单独的 '\\'：           pattern = '\\\\\\\\' path = \"C:\\\\foo\\\\bar\\\\baz.txt\" print (re.split(pattern, path))                        ['C:', 'foo', 'bar', 'baz.txt']                  这样看起来十分麻烦，好在 Python 提供了 raw string 来忽略对逃逸字符串的处理，从而可以这样进行匹配：           pattern = r'\\\\' path = r\"C:\\foo\\bar\\baz.txt\" print (re.split(pattern, path))                        ['C:', 'foo', 'bar', 'baz.txt']                  如果规则太多复杂，正则表达式不一定是个好选择。   Numpy 的 fromregex()           %%file test.dat  1312 foo 1534    bar 444  qux                        Writing test.dat                  fromregex(file, pattern, dtype)   dtype 中的内容与 pattern 的括号一一对应：           pattern = \"(\\d+)\\s+(...)\" dt = [('num', 'int64'), ('key', 'S3')]  from numpy import fromregex output = fromregex('test.dat', pattern, dt) print (output)                        [(1312, b'foo') (1534, b'bar') ( 444, b'qux')]                  显示 num 项：           print (output['num'])                        [1312 1534  444]                          import os os.remove('test.dat')           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/04.html",
        "teaser":null},{
        "title": "03-05 datetime 模块",
        
        "excerpt":
            "datetime 模块           import datetime as dt            datetime 提供了基础时间和日期的处理。   date 对象   可以使用 date(year, month, day) 产生一个 date 对象：           d1 = dt.date(2007, 9, 25) d2 = dt.date(2008, 9, 25)            可以格式化 date 对象的输出：           print (d1) print (d1.strftime('%A, %m/%d/%y')) print (d1.strftime('%a, %m-%d-%Y'))                        2007-09-25 Tuesday, 09/25/07 Tue, 09-25-2007                  可以看两个日期相差多久：           print (d2 - d1)                        366 days, 0:00:00                  返回的是一个 timedelta 对象：           d = d2 - d1 print (d.days) print (d.seconds)                        366 0                  查看今天的日期：           print (dt.date.today())                        2018-12-24                  time 对象   可以使用 time(hour, min, sec, us) 产生一个 time 对象：           t1 = dt.time(15, 38) t2 = dt.time(18)            改变显示格式：           print (t1) print (t1.strftime('%I:%M, %p')) print (t1.strftime('%H:%M:%S, %p'))                        15:38:00 03:38, PM 15:38:00, PM                  因为没有具体的日期信息，所以 time 对象不支持减法操作。   datetime 对象   可以使用 datetime(year, month, day, hr, min, sec, us) 来创建一个 datetime 对象。   获得当前时间：           d1 = dt.datetime.now() print (d1)                        2018-12-24 11:21:05.670893                  给当前的时间加上 30 天，timedelta 的参数是 timedelta(day, hr, min, sec, us)：           d2 = d1 + dt.timedelta(30) print (d2)                        2019-01-23 11:21:05.670893                  除此之外，我们还可以通过一些指定格式的字符串来创建 datetime 对象：           print (dt.datetime.strptime('2/10/01', '%m/%d/%y'))                        2001-02-10 00:00:00                  datetime 格式字符表                  字符       含义                       %a       星期英文缩写                 %A       星期英文                 %w       一星期的第几天，[0(sun),6]                 %b       月份英文缩写                 %B       月份英文                 %d       日期，[01,31]                 %H       小时，[00,23]                 %I       小时，[01,12]                 %j       一年的第几天，[001,366]                 %m       月份，[01,12]                 %M       分钟，[00,59]                 %p       AM 和 PM                 %S       秒钟，[00,61] （大概是有闰秒的存在）                 %U       一年中的第几个星期，星期日为第一天，[00,53]                 %W       一年中的第几个星期，星期一为第一天，[00,53]                 %y       没有世纪的年份                 %Y       完整的年份          ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/05.html",
        "teaser":null},{
        "title": "03-06 SQL 数据库",
        
        "excerpt":
            "SQL 数据库   Python 提供了一系列标准的数据库的 API，这里我们介绍 sqlite 数据库的用法，其他的数据库的用法大同小异：           import sqlite3 as db            首先我们要建立或者连接到一个数据库上：           connection = db.connect(\"my_database.sqlite\")            不同的数据库有着不同的连接方法，例如 cx-oracle 数据库的链接方式为：   connection = db.connect(username, password, host, port,  'XE')   一旦建立连接，我们可以利用它的 cursor() 来执行 SQL 语句：           cursor = connection.cursor() cursor.execute(\"\"\"CREATE TABLE IF NOT EXISTS orders(         order_id TEXT PRIMARY KEY,         date TEXT,         symbol TEXT,         quantity INTEGER,         price NUMBER)\"\"\") cursor.execute(\"\"\"INSERT INTO orders VALUES ('A0010', '2018-12-01', 'AAPLG', 2000, 203.4)\"\"\") connection.commit()            不过为了安全起见，一般不将数据内容写入字符串再传入，而是使用这样的方式：           orders = [           (\"A0011\",\"2013-12-01\",\"MSFT\",1500,167.5),           (\"A0012\",\"2013-12-02\",\"GOOG\",1500,167.5) ] cursor.executemany(\"\"\"INSERT INTO orders VALUES     (?, ?, ?, ?, ?)\"\"\", orders) connection.commit()            cx-oracle 数据库使用不同的方式：   cursor.executemany(\"\"\"INSERT INTO orders VALUES (:order_id, :date, :symbol, :quantity, :price)\"\"\", orders)   查看支持的数据库格式：           db.paramstyle                         'qmark'                   在 query 语句执行之后，我们需要进行 commit，否则数据库将不会接受这些变化，如果想撤销某个 commit，可以使用 rollback() 方法撤销到上一次 commit() 的结果：   try:     ... # perform some operations except:     connection.rollback()     raise else:     connection.commit()   使用 SELECT 语句对数据库进行查询：           stock = 'MSFT' cursor.execute(\"\"\"SELECT *     FROM orders     WHERE symbol=?     ORDER BY quantity\"\"\", (stock,)) for row in cursor:     print (row)                        ('A0004', '2015-09-10', 'MSFT', -1000, 187.54) ('A0002', '2013-12-01', 'MSFT', 1500, 167.5) ('A0008', '2013-12-01', 'MSFT', 1500, 167.5)                  cursor.fetchone() 返回下一条内容， cursor.fetchall() 返回所有查询到的内容组成的列表（可能非常大）：           stock = 'AAPL' cursor.execute(\"\"\"SELECT *     FROM orders     WHERE symbol=?     ORDER BY quantity\"\"\", (stock,)) cursor.fetchall()                         [('A0001', '2013-12-01', 'AAPL', 1000, 203.4)]                   关闭数据库：           cursor.close() connection.close()           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/06.html",
        "teaser":null},{
        "title": "03-07 对象关系映射",
        
        "excerpt":
            "对象关系映射   数据库中的记录可以与一个 Python 对象对应。   例如对于上一节中的数据库：                  Order       Date       Stock       Quantity       Price                       A0001       2013-12-01       AAPL       1000       203.4                 A0002       2013-12-01       MSFT       1500       167.5                 A0003       2013-12-02       GOOG       1500       167.5           可以用一个类来描述：                  Attr.       Method                       Order id       Cost                 Date                         Stock                         Quant.                         Price                   可以使用 sqlalchemy 来实现这种对应：           from sqlalchemy.ext.declarative import declarative_base from sqlalchemy import Column, Date, Float, Integer, String  Base = declarative_base()  class Order(Base):     __tablename__ = 'orders'          order_id = Column(String, primary_key=True)     date = Column(Date)     symbol = Column(String)     quantity = Column(Integer)     price = Column(Float)          def get_cost(self):         return self.quantity*self.price            生成一个 Order 对象：           import datetime order = Order(order_id='A0006', date=datetime.date.today(), symbol='MSFT', quantity=-1000, price=187.54)            调用方法：           order.get_cost()                         -187540.0                   使用上一节生成的数据库产生一个 session：           from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker  engine = create_engine(\"sqlite:///my_database.sqlite\")   # 相当于 connection Session = sessionmaker(bind=engine) # 相当于 cursor session = Session()            使用这个 session 向数据库中添加刚才生成的对象：           session.add(order) session.commit()            显示是否添加成功：           for row in engine.execute(\"SELECT * FROM orders\"):     print (row)                        ('A0001', '2013-12-01', 'AAPL', 1000, 203.4) ('A0002', '2013-12-01', 'MSFT', 1500, 167.5) ('A0003', '2013-12-02', 'GOOG', 1500, 167.5) ('A0004', '2015-09-10', 'MSFT', -1000, 187.54) ('A0007', '2018-12-01', 'AAPLG', 2000, 203.4) ('A0008', '2013-12-01', 'MSFT', 1500, 167.5) ('A0009', '2013-12-02', 'GOOG', 1500, 167.5) ('A0006', '2018-12-24', 'MSFT', -1000, 187.54)                  使用 filter 进行查询，返回的是 Order 对象的列表：           for order in session.query(Order).filter(Order.symbol==\"AAPL\"):     print (order.order_id, order.date, order.get_cost())                        A0001 2013-12-01 203400.0                  返回列表的第一个：           order_2 = session.query(Order).filter(Order.order_id=='A0002').first()                    order_2.symbol                         'MSFT'                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/07.html",
        "teaser":null},{
        "title": "03-08 函数进阶",
        
        "excerpt":
            "函数进阶：参数传递，高阶函数，lambda 匿名函数，global 变量，递归   函数是基本类型   在 Python 中，函数是一种基本类型的对象，这意味着      可以将函数作为参数传给另一个函数   将函数作为字典的值储存   将函数作为另一个函数的返回值           def square(x):     \"\"\"Square of x.\"\"\"     return x*x  def cube(x):     \"\"\"Cube of x.\"\"\"     return x*x*x            作为字典的值：           funcs = {     'square': square,     'cube': cube, }            例子：           x = 2  print (square(x)) print (cube(x))  for func in sorted(funcs):     print (func, funcs[func](x))                        4 8 cube 8 square 4                  函数参数   引用传递   Python 中的函数传递方式是 call by reference 即引用传递，例如，对于这样的用法：   x = [10, 11, 12] f(x)   传递给函数 f 的是一个指向 x 所包含内容的引用，如果我们修改了这个引用所指向内容的值（例如 x[0]=999），那么外面的 x 的值也会被改变。不过如果我们在函数中赋给 x 一个新的值（例如另一个列表），那么在函数外面的 x 的值不会改变：           def mod_f(x):     x[0] = 999     return x  x = [1, 2, 3]  print (x) print (mod_f(x)) print (x)                        [1, 2, 3] [999, 2, 3] [999, 2, 3]                          def no_mod_f(x):     x = [4, 5, 6]     return x  x = [1,2,3]  print (x) print (no_mod_f(x)) print (x)                        [1, 2, 3] [4, 5, 6] [1, 2, 3]                  默认参数是可变的！   函数可以传递默认参数，默认参数的绑定发生在函数定义的时候，以后每次调用默认参数时都会使用同一个引用。   这样的机制会导致这种情况的发生：           def f(x = []):     x.append(1)     return x            理论上说，我们希望调用 f() 时返回的是 [1]， 但事实上：           print (f()) print (f()) print (f()) print (f(x = [9,9,9])) print (f()) print (f())                        [1] [1, 1] [1, 1, 1] [9, 9, 9, 1] [1, 1, 1, 1] [1, 1, 1, 1, 1]                  而我们希望看到的应该是这样：           def f(x = None):     if x is None:         x = []     x.append(1)     return x  print (f()) print (f()) print (f()) print (f(x = [9,9,9])) print (f()) print (f())                        [1] [1] [1] [9, 9, 9, 1] [1] [1]                  高阶函数   以函数作为参数，或者返回一个函数的函数是高阶函数，常用的例子有 map 和 filter 函数：   map(f, sq) 函数将 f 作用到 sq 的每个元素上去，并返回结果组成的列表，相当于：  [f(s) for s in sq]           map(square, range(5))                         &lt;map at 0x7faee8594f60&gt;                   filter(f, sq) 函数的作用相当于，对于 sq 的每个元素 s，返回所有 f(s) 为 True 的 s 组成的列表，相当于：  [s for s in sq if f(s)]           def is_even(x):     return x % 2 == 0  filter(is_even, range(5))                         &lt;filter at 0x7faee8573cc0&gt;                   一起使用：           map(square, filter(is_even, range(5)))                         &lt;map at 0x7faee8573fd0&gt;                   reduce(f, sq) 函数接受一个二元操作函数 f(x,y)，并对于序列 sq 每次合并两个元素：           from functools import reduce def my_add(x, y):     return x + y  reduce(my_add, [1,2,3,4,5])                         15                   传入加法函数，相当于对序列求和。   返回一个函数：           def make_logger(target):     def logger(data):         with open(target, 'a') as f:             f.write(data + '\\n')     return logger  foo_logger = make_logger('foo.txt') foo_logger('Hello') foo_logger('World')                    !cat foo.txt                        Hello World                          import os os.remove('foo.txt')            匿名函数   在使用 map， filter，reduce 等函数的时候，为了方便，对一些简单的函数，我们通常使用匿名函数的方式进行处理，其基本形式是：   lambda &lt;variables&gt;: &lt;expression&gt;   例如，我们可以将这个：           print (map(square, range(5)))                        &lt;map object at 0x7faee85a2208&gt;                  用匿名函数替换为：           print (map(lambda x: x * x, range(5)))                        &lt;map object at 0x7faee85a2ba8&gt;                  匿名函数虽然写起来比较方便（省去了定义函数的烦恼），但是有时候会比较难于阅读：           from functools import reduce s1 = reduce(lambda x, y: x+y, map(lambda x: x**2, range(1,10))) print(s1)                        285                  当然，更简单地，我们可以写成这样：           s2 = sum(x**2 for x in range(1, 10)) print (s2)                        285                  global 变量   一般来说，函数中是可以直接使用全局变量的值的：           x = 15  def print_x():     print (x)      print_x()                        15                  但是要在函数中修改全局变量的值，需要加上 global 关键字：           x = 15  def print_newx():     global x     x = 18     print (x)      print_newx()  print (x)                        18 18                  如果不加上这句 global 那么全局变量的值不会改变：           x = 15  def print_newx():     x = 18     print (x)      print_newx()  print (x)                        18 15                  递归   递归是指函数在执行的过程中调用了本身，一般用于分治法，不过在 Python 中这样的用法十分地小，所以一般不怎么使用：   Fibocacci 数列：           def fib1(n):     \"\"\"Fib with recursion.\"\"\"      # base case     if n==0 or n==1:         return 1     # recurssive caae     else:         return fib1(n-1) + fib1(n-2)  print ([fib1(i) for i in range(10)])                        [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]                  一个更高效的非递归版本：           def fib2(n):     \"\"\"Fib without recursion.\"\"\"     a, b = 0, 1     for i in range(1, n+1):         a, b = b, a+b     return b  print ([fib2(i) for i in range(10)])                        [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]                  速度比较：           %timeit fib1(20) %timeit fib2(20)                        3.3 ms ± 61.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) 1.37 µs ± 86.2 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)                  对于第一个递归函数来说，调用 fib(n+2) 的时候计算 fib(n+1), fib(n)，调用 fib(n+1) 的时候也计算了一次 fib(n)，这样造成了重复计算。   使用缓存机制的递归版本，这里利用了默认参数可变的性质，构造了一个缓存：           def fib3(n, cache={0: 1, 1: 1}):     \"\"\"Fib with recursion and caching.\"\"\"      try:         return cache[n]     except KeyError:         cache[n] = fib3(n-1) + fib3(n-2)         return cache[n]  print ([fib3(i) for i in range(10)])  %timeit fib1(20) %timeit fib2(20) %timeit fib3(20)                        [1, 1, 2, 3, 5, 8, 13, 21, 34, 55] 2.9 ms ± 36 µs per loop (mean ± std. dev. of 7 runs, 100 loops each) 1.34 µs ± 51.4 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each) 115 ns ± 6.8 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/08.html",
        "teaser":null},{
        "title": "03-09 迭代器",
        
        "excerpt":
            "迭代器   简介   迭代器对象可以在 for 循环中使用：           x = [2, 4, 6]  for n in x:     print (n)                        2 4 6                  其好处是不需要对下标进行迭代，但是有些情况下，我们既希望获得下标，也希望获得对应的值，那么可以将迭代器传给 enumerate 函数，这样每次迭代都会返回一组 (index, value) 组成的元组：           x = [2, 4, 6]  for i, n in enumerate(x):     print ('pos', i, 'is', n)                        pos 0 is 2 pos 1 is 4 pos 2 is 6                  迭代器对象必须实现 __iter__ 方法：           x = [2, 4, 6] i = x.__iter__() print (i)                        &lt;list_iterator object at 0x7f21743c2748&gt;                  __iter__() 返回的对象支持 next 方法，返回迭代器中的下一个元素：           print (next(i))                        2                  当下一个元素不存在时，会 raise 一个 StopIteration 错误：           print (next(i)) print (next(i))                        4 6                          next(i)                             ---------------------------------------------------------------------------      StopIteration                             Traceback (most recent call last)      &lt;ipython-input-23-a883b34d6d8a&gt; in &lt;module&gt;     ----&gt; 1 next(i)           StopIteration:                     很多标准库函数返回的是迭代器：           r = reversed(x) print (r)                        &lt;list_reverseiterator object at 0x7f21743c25f8&gt;                  调用它的 next() 方法：           print (next(r)) print (next(r)) print (next(r))                        6 4 2                  自定义一个 list 的取反迭代器：   不会出现之前的问题：  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/09.html",
        "teaser":null},{
        "title": "03-10 生成器",
        
        "excerpt":
            "生成器   while 循环通常有这样的形式：   &lt;do setup&gt; result = [] while True:     &lt;generate value&gt;     result.append(value)     if &lt;done&gt;:         break   使用迭代器实现这样的循环：   class GenericIterator(object):     def __init__(self, ...):         &lt;do setup&gt;         # 需要额外储存状态         &lt;store state&gt;     def next(self):          &lt;load state&gt;         &lt;generate value&gt;         if &lt;done&gt;:             raise StopIteration()         &lt;store state&gt;         return value   更简单的，可以使用生成器：   def generator(...):     &lt;do setup&gt;     while True:         &lt;generate value&gt;         # yield 说明这个函数可以返回多个值！         yield value         if &lt;done&gt;:             break   生成器使用 yield 关键字将值输出，而迭代器则通过 next 的 return 将值返回；与迭代器不同的是，生成器会自动记录当前的状态，而迭代器则需要进行额外的操作来记录当前的状态。   对于之前的 collatz 猜想，简单循环的实现如下：           def collatz(n):     sequence = []     while n != 1:         if n % 2 == 0:             n /= 2         else:             n = 3*n + 1         sequence.append(n)     return sequence  for x in collatz(7):     print (x)                        22 11.0 34.0 17.0 52.0 26.0 13.0 40.0 20.0 10.0 5.0 16.0 8.0 4.0 2.0 1.0                  生成器的版本如下：           def collatz(n):     while n != 1:         if n % 2 == 0:             n /= 2         else:             n = 3*n + 1         yield n  for x in collatz(7):     print (x)                        22 11.0 34.0 17.0 52.0 26.0 13.0 40.0 20.0 10.0 5.0 16.0 8.0 4.0 2.0 1.0                  事实上，生成器也是一种迭代器：           x = collatz(7) print (x)                        &lt;generator object collatz at 0x7f278853e518&gt;                  它支持 next 方法，返回下一个 yield 的值：           print (next(x)) print (next(x))                        22 11.0                  __iter__ 方法返回的是它本身：           print (x.__iter__())                        &lt;generator object collatz at 0x7f278853e518&gt;                  之前的二叉树迭代器可以改写为更简单的生成器模式来进行中序遍历：           class BinaryTree(object):     def __init__(self, value, left=None, right=None):         self.value = value         self.left = left         self.right = right      def __iter__(self):         # 将迭代器设为生成器方法         return self.inorder()          def inorder(self):         # traverse the left branch         if self.left is not None:             for value in self.left:                 yield value                          # yield node's value         yield self.value                  # traverse the right branch         if self.right is not None:             for value in self.right:                 yield value            非递归的实现：           def inorder(self):     node = self     stack = []     while len(stack) &gt; 0 or node is not None:         while node is not None:             stack.append(node)             node = node.left         node = stack.pop()         yield node.value         node = node.right                    tree = BinaryTree(     left=BinaryTree(         left=BinaryTree(1),         value=2,         right=BinaryTree(             left=BinaryTree(3),             value=4,             right=BinaryTree(5)         ),     ),     value=6,     right=BinaryTree(         value=7,         right=BinaryTree(8)     ) ) for value in tree:     print (value)                        1 2 3 4 5 6 7 8                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/10.html",
        "teaser":null},{
        "title": "03-11 with 语句和上下文管理器",
        
        "excerpt":
            "with 语句和上下文管理器   # create/aquire some resource ... try:     # do something with the resource     ... finally:     # destroy/release the resource     ...   处理文件，线程，数据库，网络编程等等资源的时候，我们经常需要使用上面这样的代码形式，以确保资源的正常使用和释放。   好在Python 提供了 with 语句帮我们自动进行这样的处理，例如之前在打开文件时我们使用：           with open('my_file', 'w') as fp:     # do stuff with fp     data = fp.write(\"Hello world\")            这等效于下面的代码，但是要更简便：           fp = open('my_file', 'w') try:     # do stuff with f     data = fp.write(\"Hello world\") finally:     fp.close()            上下文管理器   其基本用法如下：  with &lt;expression&gt;:     &lt;block&gt;   &lt;expression&gt; 执行的结果应当返回一个实现了上下文管理器的对象，即实现这样两个方法，__enter__ 和 __exit__：           print (fp.__enter__) print (fp.__exit__)                        &lt;built-in method __enter__ of _io.TextIOWrapper object at 0x7f64800471f8&gt; &lt;built-in method __exit__ of _io.TextIOWrapper object at 0x7f64800471f8&gt;                  __enter__ 方法在 &lt;block&gt; 执行前执行，而 __exit__ 在 &lt;block&gt; 执行结束后执行：   比如可以这样定义一个简单的上下文管理器：           class ContextManager(object):          def __enter__(self):         print (\"Entering\")          def __exit__(self, exc_type, exc_value, traceback):         print (\"Exiting\")            使用 with 语句执行：           with ContextManager():     print (\"  Inside the with statement\")                        Entering   Inside the with statement Exiting                  即使 &lt;block&gt; 中执行的内容出错，__exit__ 也会被执行：           with ContextManager():     print (1/0)                        Entering Exiting                                   ---------------------------------------------------------------------------      ZeroDivisionError                         Traceback (most recent call last)      &lt;ipython-input-10-ada04d4fc361&gt; in &lt;module&gt;           1 with ContextManager():     ----&gt; 2     print (1/0)           ZeroDivisionError: division by zero                    __enter__ 的返回值   如果在 __enter__ 方法下添加了返回值，那么我们可以使用 as 把这个返回值传给某个参数：           class ContextManager(object):          def __enter__(self):         print (\"Entering\")         return \"my value\"          def __exit__(self, exc_type, exc_value, traceback):         print (\"Exiting\")            将 __enter__ 返回的值传给 value 变量：           with ContextManager() as value:     print (value)                        Entering my value Exiting                  一个通常的做法是将 __enter__ 的返回值设为这个上下文管理器对象本身，文件对象就是这样做的：           fp = open('my_file', 'r') print (fp.__enter__()) fp.close()                        &lt;_io.TextIOWrapper name='my_file' mode='r' encoding='UTF-8'&gt;                          import os os.remove('my_file')            实现方法非常简单：           class ContextManager(object):          def __enter__(self):         print (\"Entering\")         return self          def __exit__(self, exc_type, exc_value, traceback):         print (\"Exiting\")                    with ContextManager() as value:     print (value)                        Entering &lt;__main__.ContextManager object at 0x7f646b75d198&gt; Exiting                  错误处理   上下文管理器对象将错误处理交给 __exit__ 进行，可以将错误类型，错误值和 traceback 等内容作为参数传递给 __exit__ 函数：           class ContextManager(object):          def __enter__(self):         print (\"Entering\")          def __exit__(self, exc_type, exc_value, traceback):         print (\"Exiting\")         if exc_type is not None:             print (\"  Exception:\", exc_value)            如果没有错误，这些值都将是 None, 当有错误发生的时候：           with ContextManager():     print (1/0)                        Entering Exiting   Exception: division by zero                                   ---------------------------------------------------------------------------      ZeroDivisionError                         Traceback (most recent call last)      &lt;ipython-input-18-ada04d4fc361&gt; in &lt;module&gt;           1 with ContextManager():     ----&gt; 2     print (1/0)           ZeroDivisionError: division by zero                    在这个例子中，我们只是简单的显示了错误的值，并没有对错误进行处理，所以错误被向上抛出了，如果不想让错误抛出，只需要将 __exit__ 的返回值设为 True：           class ContextManager(object):          def __enter__(self):         print \"Entering\"          def __exit__(self, exc_type, exc_value, traceback):         print \"Exiting\"         if exc_type is not None:             print \" Exception suppresed:\", exc_value             return True                    with ContextManager():     print (1/0)                        Entering Exiting   Exception: division by zero                                   ---------------------------------------------------------------------------      ZeroDivisionError                         Traceback (most recent call last)      &lt;ipython-input-19-ada04d4fc361&gt; in &lt;module&gt;           1 with ContextManager():     ----&gt; 2     print (1/0)           ZeroDivisionError: division by zero                    在这种情况下，错误就不会被向上抛出。   数据库的例子   对于数据库的 transaction 来说，如果没有错误，我们就将其 commit 进行保存，如果有错误，那么我们将其回滚到上一次成功的状态。           class Transaction(object):          def __init__(self, connection):         self.connection = connection          def __enter__(self):         return self.connection.cursor()          def __exit__(self, exc_type, exc_value, traceback):         if exc_value is None:             # transaction was OK, so commit             self.connection.commit()         else:             # transaction had a problem, so rollback             self.connection.rollback()            建立一个数据库，保存一个地址表：           import sqlite3 as db connection = db.connect(\":memory:\")  with Transaction(connection) as cursor:     cursor.execute(\"\"\"CREATE TABLE IF NOT EXISTS addresses (         address_id INTEGER PRIMARY KEY,         street_address TEXT,         city TEXT,         state TEXT,         country TEXT,         postal_code TEXT     )\"\"\")            插入数据：           with Transaction(connection) as cursor:     cursor.executemany(\"\"\"INSERT OR REPLACE INTO addresses VALUES (?, ?, ?, ?, ?, ?)\"\"\", [         (0, '515 Congress Ave', 'Austin', 'Texas', 'USA', '78701'),         (1, '245 Park Avenue', 'New York', 'New York', 'USA', '10167'),         (2, '21 J.J. Thompson Ave.', 'Cambridge', None, 'UK', 'CB3 0FA'),         (3, 'Supreme Business Park', 'Hiranandani Gardens, Powai, Mumbai', 'Maharashtra', 'India', '400076'),     ])            假设插入数据之后出现了问题：           with Transaction(connection) as cursor:     cursor.execute(\"\"\"INSERT OR REPLACE INTO addresses VALUES (?, ?, ?, ?, ?, ?)\"\"\",         (4, '2100 Pennsylvania Ave', 'Washington', 'DC', 'USA', '78701'),     )     raise Exception(\"out of addresses\")                             ---------------------------------------------------------------------------      Exception                                 Traceback (most recent call last)      &lt;ipython-input-23-f5aba7fc14d7&gt; in &lt;module&gt;           3         (4, '2100 Pennsylvania Ave', 'Washington', 'DC', 'USA', '78701'),           4     )     ----&gt; 5     raise Exception(\"out of addresses\")           Exception: out of addresses                    那么最新的一次插入将不会被保存，而是返回上一次 commit 成功的状态：           cursor.execute(\"SELECT * FROM addresses\") for row in cursor:     print (row)                        (0, '515 Congress Ave', 'Austin', 'Texas', 'USA', '78701') (1, '245 Park Avenue', 'New York', 'New York', 'USA', '10167') (2, '21 J.J. Thompson Ave.', 'Cambridge', None, 'UK', 'CB3 0FA') (3, 'Supreme Business Park', 'Hiranandani Gardens, Powai, Mumbai', 'Maharashtra', 'India', '400076')                  contextlib 模块   很多的上下文管理器有很多相似的地方，为了防止写入很多重复的模式，可以使用 contextlib 模块来进行处理。   最简单的处理方式是使用 closing 函数确保对象的 close() 方法始终被调用：           from contextlib import closing import urllib  with closing(urllib.request.urlopen('http://www.baidu.com')) as url:     html = url.read()  print (html[:100])                        b'&lt;!DOCTYPE html&gt;\\n&lt;!--STATUS OK--&gt;\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r'                  另一个有用的方法是使用修饰符 @contextlib：           from contextlib import contextmanager  @contextmanager def my_contextmanager():     print (\"Enter\")     yield     print (\"Exit\")  with my_contextmanager():     print (\"  Inside the with statement\")                        Enter   Inside the with statement Exit                  yield 之前的部分可以看成是 __enter__ 的部分，yield 的值可以看成是 __enter__ 返回的值，yield 之后的部分可以看成是 __exit__ 的部分。   使用 yield 的值：           @contextmanager def my_contextmanager():     print (\"Enter\")     yield (\"my value\")     print (\"Exit\")      with my_contextmanager() as value:     print (value)                        Enter my value Exit                  错误处理可以用 try 块来完成：           @contextmanager def my_contextmanager():     print (\"Enter\")     try:         yield     except Exception as exc:         print (\"   Error:\", exc)     finally:         print (\"Exit\")                    with my_contextmanager():     print (1/0)                        Enter                                   ---------------------------------------------------------------------------      ZeroDivisionError                         Traceback (most recent call last)      &lt;ipython-input-31-cfbf6bbf1f10&gt; in &lt;module&gt;           1 with my_contextmanager():     ----&gt; 2     print (1/0)           ZeroDivisionError: division by zero                    对于之前的数据库 transaction 我们可以这样定义：           @contextmanager def transaction(connection):     cursor = connection.cursor()     try:         yield cursor     except:         connection.rollback()         raise     else:         connection.commit()           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/11.html",
        "teaser":null},{
        "title": "03-12 装饰器",
        
        "excerpt":
            "装饰器   函数是一种对象   在 Python 中，函数是也是一种对象。           def foo(x):     print (x)      print(type(foo))                        &lt;class 'function'&gt;                  查看函数拥有的方法：           dir(foo)                         ['__annotations__',  '__call__',  '__class__',  '__closure__',  '__code__',  '__defaults__',  '__delattr__',  '__dict__',  '__dir__',  '__doc__',  '__eq__',  '__format__',  '__ge__',  '__get__',  '__getattribute__',  '__globals__',  '__gt__',  '__hash__',  '__init__',  '__kwdefaults__',  '__le__',  '__lt__',  '__module__',  '__name__',  '__ne__',  '__new__',  '__qualname__',  '__reduce__',  '__reduce_ex__',  '__repr__',  '__setattr__',  '__sizeof__',  '__str__',  '__subclasshook__']                   在这些方法中，__call__ 是最重要的一种方法：           foo.__call__(42)                        42                  相当于：           foo(42)                        42                  因为函数是对象，所以函数可以作为参数传入另一个函数：           def bar(f, x):     x += 1     f(x)                    bar(foo, 4)                        5                  修饰符   修饰符是这样的一种函数，它接受一个函数作为输入，通常输出也是一个函数：           def dec(f):     print ('I am decorating function', id(f))     return f            将 len 函数作为参数传入这个修饰符函数：           declen = dec(len)                        I am decorating function 140245612639648                  使用这个新生成的函数：           declen([10,20,30])                         3                   上面的例子中，我们仅仅返回了函数的本身，也可以利用这个函数生成一个新的函数，看一个新的例子：           def loud(f):     def new_func(*args, **kw):         print ('calling with', args, kw)         rtn = f(*args, **kw)         print ('return value is', rtn)         return rtn     return new_func                    loudlen = loud(len)                    loudlen([10, 20, 30])                        calling with ([10, 20, 30],) {} return value is 3                               3                   用 @ 来使用修饰符   Python 使用 @ 符号来将某个函数替换为修饰符之后的函数：   例如这个函数：           def foo(x):     print (x)      foo = dec(foo)                        I am decorating function 140245448679904                  可以替换为：           @dec def foo(x):     print (x)                        I am decorating function 140245448683032                  事实上，如果修饰符返回的是一个函数，那么可以链式的使用修饰符：   @dec1 @dec2 def foo(x):     print (x)   使用修饰符 loud 来定义这个函数：           @loud def foo(x):     print (x)                    foo(42)                        calling with (42,) {} 42 return value is None                  例子   定义两个修饰器函数，一个将原来的函数值加一，另一个乘二：           def plus_one(f):     def new_func(x):         return f(x) + 1     return new_func  def times_two(f):     def new_func(x):         return f(x) * 2     return new_func            定义函数，先乘二再加一：           @plus_one @times_two def foo(x):     return int(x)                    foo(13)                         27                   修饰器工厂   decorators factories 是返回修饰器的函数，例如：           def super_dec(x, y, z):     def dec(f):         def new_func(*args, **kw):             print (x + y + z)             return f(*args, **kw)         return new_func     return dec            它的作用在于产生一个可以接受参数的修饰器，例如我们想将 loud 输出的内容写入一个文件去，可以这样做：           def super_loud(filename):     fp = open(filename, 'w')     def loud(f):         def new_func(*args, **kw):             fp.write('calling with' + str(args) + str(kw))             # 确保内容被写入             fp.flush()             fp.close()             rtn = f(*args, **kw)             return rtn         return new_func     return loud            可以这样使用这个修饰器工厂：           @super_loud('test.txt') def foo(x):     print (x)            调用 foo 就会在文件中写入内容：           foo(12)                        12                  查看文件内容：           with open('test.txt') as fp:     print (fp.read())                        calling with(12,){}                          import os os.remove('test.txt')           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/12.html",
        "teaser":null},{
        "title": "03-13 装饰器的使用",
        
        "excerpt":
            "装饰器的使用   @classmethod 修饰符   在 Python 标准库中，有很多自带的修饰符，例如 classmethod 将一个对象方法转换了类方法：           class Foo(object):     @classmethod     def bar(cls, x):         print ('the input is', x)              def __init__(self):         pass             类方法可以通过 类名.方法 来调用：           Foo.bar(12)                        the input is 12                  @property 修饰符   有时候，我们希望像 Java 一样支持 getters 和 setters 的方法，这时候就可以使用 property 修饰符：           class Foo(object):     def __init__(self, data):         self.data = data          @property     def x(self):         return self.data            此时可以使用 .x 这个属性查看数据（不需要加上括号）：           foo = Foo(23) foo.x                         23                   这样做的好处在于，这个属性是只读的：           foo.x = 1                             ---------------------------------------------------------------------------      AttributeError                            Traceback (most recent call last)      &lt;ipython-input-5-840818df7af3&gt; in &lt;module&gt;     ----&gt; 1 foo.x = 1           AttributeError: can't set attribute                    如果想让它变成可读写，可以加上一个修饰符 @x.setter：           class Foo(object):     def __init__(self, data):         self.data = data          @property     def x(self):         return self.data          @x.setter     def x(self, value):         self.data = value                    foo = Foo(23) print (foo.x)                        23                  可以通过属性改变它的值：           foo.x = 1 print (foo.x)                        1                  Numpy 的 @vectorize 修饰符   numpy 的 vectorize 函数讲一个函数转换为 ufunc，事实上它也是一个修饰符：           from numpy import vectorize, arange  @vectorize def f(x):     if x &lt;= 0:         return x     else:         return 0  f(arange(-10.0,10.0))                         array([-10.,  -9.,  -8.,  -7.,  -6.,  -5.,  -4.,  -3.,  -2.,  -1.,   0.,          0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.])                   注册一个函数   来看这样的一个例子，定义一个类：           class Registry(object):     def __init__(self):         self._data = {}     def register(self, f, name=None):         if name == None:             name = f.__name__         self._data[name] = f         setattr(self, name, f)            register 方法接受一个函数，将这个函数名作为属性注册到对象中。   产生该类的一个对象：           registry = Registry()            使用该对象的 register 方法作为修饰符：           @registry.register def greeting():     print (\"hello world\")            这样这个函数就被注册到 registry 这个对象中去了：           registry._data                         {'greeting': &lt;function __main__.greeting()&gt;}                           registry.greeting                         &lt;function __main__.greeting()&gt;                   flask ，一个常用的网络应用，处理 url 的机制跟这个类似。   使用 @wraps   一个通常的问题在于：           def logging_call(f):     def wrapper(*a, **kw):         print ('calling {}'.format(f.__name__))         return f(*a, **kw)     return wrapper  @logging_call def square(x):     '''     square function.     '''     return x ** 2  print (square.__doc__, square.__name__)                        None wrapper                  我们使用修饰符之后，square 的 metadata 完全丢失了，返回的函数名与函数的 docstring 都不对。   一个解决的方法是从 functools 模块导入 wraps 修饰符来修饰我们的修饰符：           import functools  def logging_call(f):     @functools.wraps(f)     def wrapper(*a, **kw):         print ('calling {}'.format(f.__name__))         return f(*a, **kw)     return wrapper  @logging_call def square(x):     '''     square function.     '''     return x ** 2  print (square.__doc__, square.__name__)                             square function.      square                  现在这个问题解决了，所以在自定义修饰符方法的时候为了避免出现不必要的麻烦，尽量使用 wraps 来修饰修饰符！   Class 修饰符   与函数修饰符类似，类修饰符是这样一类函数，接受一个类作为参数，通常返回一个新的类。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/13.html",
        "teaser":null},{
        "title": "03-14 Python 常用模块",
        
        "excerpt":
            "operator, functools, itertools, toolz, fn, funcy 模块   operator 模块           import operator as op            operator 模块提供了各种操作符（+,*,[]）的函数版本方便使用：   加法：           from functools import reduce print (reduce(op.add, range(10)))                        45                  乘法：           print (reduce(op.mul, range(1,10)))                        362880                  []：           my_list = [('a', 1), ('bb', 4), ('ccc', 2), ('dddd', 3)]  # 标准排序 print (sorted(my_list))  # 使用元素的第二个元素排序 print (sorted(my_list, key=op.itemgetter(1)))  # 使用第一个元素的长度进行排序： print (sorted(my_list, key=lambda x: len(x[0])))                        [('a', 1), ('bb', 4), ('ccc', 2), ('dddd', 3)] [('a', 1), ('ccc', 2), ('dddd', 3), ('bb', 4)] [('a', 1), ('bb', 4), ('ccc', 2), ('dddd', 3)]                  functools 模块   functools 包含很多跟函数相关的工具，比如之前看到的 wraps 函数，不过最常用的是 partial 函数，这个函数允许我们使用一个函数中生成一个新函数，这个函数使用原来的函数，不过某些参数被指定了：           from functools import partial  # 将 reduce 的第一个参数指定为加法，得到的是类似求和的函数 sum_ = partial(reduce, op.add)  # 将 reduce 的第一个参数指定为乘法，得到的是类似求连乘的函数 prod_ = partial(reduce, op.mul)  print (sum_([1,2,3,4])) print (prod_([1,2,3,4]))                        10 24                  partial 函数还可以按照键值对传入固定参数。   itertools 模块   itertools 包含很多与迭代器对象相关的工具，其中比较常用的是排列组合生成器 permutations 和 combinations，还有在数据分析中常用的 groupby 生成器：           from itertools import cycle, groupby, islice, permutations, combinations            cycle 返回一个无限的迭代器，按照顺序重复输出输入迭代器中的内容，islice 则返回一个迭代器中的一段内容：           print (list(islice(cycle('abcd'), 0, 10)))                        ['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd', 'a', 'b']                  groupby 返回一个字典，按照指定的 key 对一组数据进行分组，字典的键是 key，值是一个迭代器：           animals = sorted(['pig', 'cow', 'giraffe', 'elephant',                   'dog', 'cat', 'hippo', 'lion', 'tiger'], key=len)  # 按照长度进行分组 for k, g in groupby(animals, key=len):     print (k, list(g))                         3 ['pig', 'cow', 'dog', 'cat'] 4 ['lion'] 5 ['hippo', 'tiger'] 7 ['giraffe'] 8 ['elephant']                  排列：           print ([''.join(p) for p in permutations('abc')])                        ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']                  组合：           print ([list(c) for c in combinations([1,2,3,4], r=2)])                        [[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]                  toolz, fn 和 funcy 模块   这三个模块的作用是方便我们在编程的时候使用函数式编程的风格。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/14.html",
        "teaser":null},{
        "title": "03-15 作用域",
        
        "excerpt":
            "作用域   在函数中，Python 从命名空间中寻找变量的顺序如下：      local function scope   enclosing scope   global scope   builtin scope   例子：   local 作用域           def foo(a,b):     c = 1     d = a + b + c            这里所有的变量都在 local 作用域。   global 作用域           c = 1 def foo(a,b):     d = a + b + c            这里的 c 就在 global 作用域。   global 关键词   使用 global 关键词可以在 local 作用域中修改 global 作用域的值。           c = 1 def foo():     global c     c = 2      print (c) foo() print (c)                        1 2                  其作用是将 c 指向 global 中的 c。   如果不加关键词，那么 local 作用域的 c 不会影响 global 作用域中的值：           c = 1 def foo():     c = 2      print (c) foo() print (c)                        1 1                  built-in 作用域           def list_length(a):     return len(a)  a = [1,2,3] print (list_length(a))                        3                  这里函数 len 就是在 built-in 作用域中：           import builtins  builtins.len                         &lt;function len(obj, /)&gt;                   class 中的作用域                  Global       MyClass                       var = 0   MyClass   access_class       var = 1 access_class                   # global var = 0  class MyClass(object):     # class variable     var = 1          def access_class_c(self):         print ('class var:', self.var)          def write_class_c(self):         MyClass.var = 2         print ('class var:', self.var)              def access_global_c(self):         print ('global var:', var)          def write_instance_c(self):         self.var = 3         print ('instance var:', self.var)                           Global       MyClass       obj                       var = 0   MyClass   [access_class]   obj       var = 1 access_class                           obj = MyClass()            查询 self.var 时，由于 obj 不存在 var，所以跳到 MyClass 中：                  Global       MyClass       obj                       var = 0   MyClass   [access_class   self]   obj       var = 1 access_class                           obj.access_class_c()                        class var: 1                  查询 var 直接跳到 global 作用域：                  Global       MyClass       obj                       var = 0   MyClass   [access_class   self]   obj       var = 1 access_class                           obj.access_global_c()                        global var: 0                  修改类中的 MyClass.var：                  Global       MyClass       obj                       var = 0   MyClass   [access_class   self]   obj       var = 2 access_class                           obj.write_class_c()                        class var: 2                  修改实例中的 var 时，会直接在 obj 域中创建一个：                  Global       MyClass       obj                       var = 0   MyClass   [access_class   self]   obj       var = 2 access_class       var = 3                   obj.write_instance_c()                        instance var: 3                          MyClass.var                         2                   MyClass 中的 var 并没有改变。   词法作用域   对于嵌套函数：           def outer():     a = 1     def inner():         print (\"a =\", a)     inner()      outer()                        a = 1                  如果里面的函数没有找到变量，那么会向外一层寻找变量，如果再找不到，则到 global 作用域。   返回的是函数的情况：           def outer():     a = 1     def inner():         return a     return inner      func = outer()  print ('a (1):', func())                        a (1): 1                  func() 函数中调用的 a 要从它定义的地方开始寻找，而不是在 func 所在的作用域寻找。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/15.html",
        "teaser":null},{
        "title": "03-16 动态编译",
        
        "excerpt":
            "动态编译   标准编程语言   对于 C 语言，代码一般要先编译，再执行。   .c -&gt; .exe   解释器语言   shell 脚本   .sh -&gt; interpreter   Byte Code 编译   Python, Java 等语言先将代码编译为 byte code（不是机器码），然后再处理：   .py -&gt; .pyc -&gt; interpreter   eval 函数   eval(statement, glob, local)   使用 eval 函数动态执行代码，返回执行的值：           a = 1  eval(\"a+1\")                         2                   可以接收明明空间参数：           local = dict(a=2) glob = {} eval(\"a+1\", glob, local)                         3                   这里 local 中的 a 先被找到。   exec 函数   exec(statement, glob, local)   使用 exec 可以添加修改原有的变量。           a = 1  exec(\"b = a+1\")  print (b)                        2                          local = dict(a=2) glob = {} exec(\"b = a+1\", glob, local)  print (local)                        {'a': 2, 'b': 3}                  执行之后，b 在 local 命名空间中。   警告   动态执行的时候要注意，不要执行不信任的用户输入，因为它们拥有 Python 的全部权限。   compile 函数生成 byte code   compile(str, filename, mode)           a = 1 c = compile(\"a+2\", \"\", 'eval')  eval(c)                         3                           a = 1 c = compile(\"b=a+2\", \"\", 'exec')  exec(c) b                         3                   abstract syntax trees           import ast                    tree = ast.parse(\"a+2\", \"\", \"eval\")  ast.dump(tree)                         \"Expression(body=BinOp(left=Name(id='a', ctx=Load()), op=Add(), right=Num(n=2)))\"                   改变常数的值：           tree.body.right.n = 3  ast.dump(tree)                         \"Expression(body=BinOp(left=Name(id='a', ctx=Load()), op=Add(), right=Num(n=3)))\"                           a = 1 c = compile(tree, '', 'eval')  eval(c)                         4                   安全的使用方法 literal_eval ，只支持基本值的操作：           ast.literal_eval(\"[10.0, 2, True, 'foo']\")                         [10.0, 2, True, 'foo']                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/16.html",
        "teaser":null},{
        "title": "第3章 Python 进阶",
        
        "excerpt":
            "第3章 Python 进阶   03-1-sys 模块简介   03-2-与操作系统进行交互：os 模块   03-3-CSV 文件和 csv 模块   03-4-正则表达式和 re 模块   03-5-datetime 模块   03-6-SQL 数据库   03-7-对象关系映射   03-8-函数进阶   03-9-迭代器   03-10-生成器   03-11-with 语句和上下文管理器   03-12-装饰器   03-13-装饰器的使用   03-14-Python 常用模块   03-15-作用域   03-16-动态编译  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/03/features.html",
        "teaser":null},{
        "title": "04-01 Numpy 简介",
        
        "excerpt":
            "Numpy 简介   导入numpy   Numpy是Python的一个很重要的第三方库，很多其他科学计算的第三方库都是以Numpy为基础建立的。   Numpy的一个重要特性是它的数组计算。   在使用Numpy之前，我们需要导入numpy包：           from numpy import *            使用前一定要先导入 Numpy 包，导入的方法有以下几种：       import numpy     import numpy as np     from numpy import *     from numpy import array, sin   数组上的数学操作   假如我们想将列表中的每个元素增加1，但列表不支持这样的操作（报错）：           a = [1, 2, 3, 4] a + 1                             ---------------------------------------------------------------------------      TypeError                                 Traceback (most recent call last)      &lt;ipython-input-3-bf98811c06e5&gt; in &lt;module&gt;           1 a = [1, 2, 3, 4]     ----&gt; 2 a + 1           TypeError: can only concatenate list (not \"int\") to list                    转成 array ：           a = array(a) a                         array([1, 2, 3, 4])                   array 数组支持每个元素加 1 这样的操作：           a + 1                         array([2, 3, 4, 5])                   与另一个 array 相加，得到对应元素相加的结果：           b = array([2, 3, 4, 5]) a + b                         array([3, 5, 7, 9])                   对应元素相乘：           a * b                         array([ 2,  6, 12, 20])                   对应元素乘方：           a ** b                         array([   1,    8,   81, 1024])                   提取数组中的元素   提取第一个元素：           a[0]                         1                   提取前两个元素：           a[:2]                         array([1, 2])                   最后两个元素：           a[-2:]                         array([3, 4])                   将它们相加：           a[:2] + a[-2:]                         array([4, 6])                   修改数组形状   查看 array 的形状：           a.shape                         (4,)                   修改 array 的形状：           a.shape = 2,2 a                         array([[1, 2],        [3, 4]])                   多维数组   a 现在变成了一个二维的数组，可以进行加法：           a + a                         array([[2, 4],        [6, 8]])                   乘法仍然是对应元素的乘积，并不是按照矩阵乘法来计算：           a * a                         array([[ 1,  4],        [ 9, 16]])                   画图   linspace 用来生成一组等间隔的数据：           a = linspace(0, 2*pi, 21) %precision 3 a                         array([0.   , 0.314, 0.628, 0.942, 1.257, 1.571, 1.885, 2.199, 2.513,        2.827, 3.142, 3.456, 3.77 , 4.084, 4.398, 4.712, 5.027, 5.341,        5.655, 5.969, 6.283])                   三角函数：           b = sin(a) b                         array([ 0.000e+00,  3.090e-01,  5.878e-01,  8.090e-01,  9.511e-01,         1.000e+00,  9.511e-01,  8.090e-01,  5.878e-01,  3.090e-01,         1.225e-16, -3.090e-01, -5.878e-01, -8.090e-01, -9.511e-01,        -1.000e+00, -9.511e-01, -8.090e-01, -5.878e-01, -3.090e-01,        -2.449e-16])                   画出图像：           import matplotlib.pyplot as plt plt.plot(a, b)                         [&lt;matplotlib.lines.Line2D at 0x7f193322a128&gt;]                                             从数组中选择元素   假设我们想选取数组b中所有非负的部分，首先可以利用 b 产生一组布尔值：           b &gt;= 0                         array([ True,  True,  True,  True,  True,  True,  True,  True,  True,         True,  True, False, False, False, False, False, False, False,        False, False, False])                           mask = b &gt;= 0            画出所有对应的非负值对应的点：           plt.plot(a[mask], b[mask], 'ro')                         [&lt;matplotlib.lines.Line2D at 0x7f19069646d8&gt;]                                            ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/01.html",
        "teaser":null},{
        "title": "04-02 Matplotlib基础",
        
        "excerpt":
            "Matplotlib 基础   在使用Numpy之前，需要了解一些画图的基础。   Matplotlib是一个类似Matlab的工具包，主页地址为   http://matplotlib.org   导入 matplotlib 和 numpy：           import matplotlib.pyplot as plt from numpy import *            plot 二维图   plt.plot(y) plt.plot(x, y) plt.plot(x, y, format_string)   只给定 y 值，默认以下标为 x 轴：           x = linspace(0, 2 * pi, 50) plt.plot(sin(x))                         [&lt;matplotlib.lines.Line2D at 0x7f71aac0a1d0&gt;]                                             给定 x 和 y 值：           plt.plot(x, sin(x))                         [&lt;matplotlib.lines.Line2D at 0x7f71aab81320&gt;]                                             多条数据线：           plt.plot(x, sin(x),     x, sin(2 * x))                         [&lt;matplotlib.lines.Line2D at 0x7f71aab47860&gt;,  &lt;matplotlib.lines.Line2D at 0x7f71aab479b0&gt;]                                             使用字符串，给定线条参数：           plt.plot(x, sin(x), 'r-^')                         [&lt;matplotlib.lines.Line2D at 0x7f71aab0bb00&gt;]                                             多线条：           plt.plot(x, sin(x), 'b-o',     x, sin(2 * x), 'r-^')                         [&lt;matplotlib.lines.Line2D at 0x7f71aaac9c88&gt;,  &lt;matplotlib.lines.Line2D at 0x7f71aaac9e10&gt;]                                             更多参数设置，请查阅帮助。事实上，字符串使用的格式与Matlab相同。   scatter 散点图   scatter(x, y) scatter(x, y, size) scatter(x, y, size, color)   假设我们想画二维散点图：           plt.plot(x, sin(x), 'bo')                         [&lt;matplotlib.lines.Line2D at 0x7f71aaa46160&gt;]                                             可以使用 scatter 达到同样的效果：           plt.scatter(x, sin(x))                         &lt;matplotlib.collections.PathCollection at 0x7f71aaa00128&gt;                                             事实上，scatter函数与Matlab的用法相同，还可以指定它的大小，颜色等参数：           x = np.random.rand(200) y = np.random.rand(200) size = np.random.rand(200) * 30 color = np.random.rand(200) plt.scatter(x, y, size, color) # 显示颜色条 plt.colorbar()                         &lt;matplotlib.colorbar.Colorbar at 0x7f71aa9772e8&gt;                                             多图   使用figure()命令产生新的图像：           t = linspace(0, 2*pi, 50) x = sin(t) y = cos(t) plt.figure() plt.plot(x) plt.figure() plt.plot(y)                         [&lt;matplotlib.lines.Line2D at 0x7f71aa8e0eb8&gt;]                                                                       或者使用 subplot 在一幅图中画多幅子图：   subplot(row, column, index)           plt.subplot(1, 2, 1) plt.plot(x) plt.subplot(1, 2, 2) plt.plot(y)                         [&lt;matplotlib.lines.Line2D at 0x7f71aa9962b0&gt;]                                             向图中添加数据   默认多次 plot 会叠加：           plt.plot(x) plt.plot(y)                         [&lt;matplotlib.lines.Line2D at 0x7f71aa944cf8&gt;]                                             标签   可以在 plot 中加入 label ，使用 legend 加上图例：           plt.plot(x, label='sin') plt.plot(y, label='cos') plt.legend()                         &lt;matplotlib.legend.Legend at 0x7f71aa73a0f0&gt;                                             或者直接在 legend中加入：           plt.plot(x) plt.plot(y) plt.legend(['sin', 'cos'])                         &lt;matplotlib.legend.Legend at 0x7f71aa78a898&gt;                                             坐标轴，标题，网格   可以设置坐标轴的标签和标题：           plt.plot(x, sin(x)) plt.xlabel('radians') # 可以设置字体大小 plt.ylabel('amplitude', fontsize='large') plt.title('Sin(x)')                         Text(0.5, 1.0, 'Sin(x)')                                             用 ‘grid()’ 来显示网格：           plt.plot(x, sin(x)) plt.xlabel('radians') plt.ylabel('amplitude', fontsize='large') plt.title('Sin(x)') plt.grid()                                      清除、关闭图像   清除已有的图像使用：   clf()   关闭当前图像：   close()   关闭所有图像：   close('all')   imshow 显示图片   灰度图片可以看成二维数组：           # 导入lena图片 from scipy.misc import ascent img = ascent() img                         array([[ 83,  83,  83, ..., 117, 117, 117],        [ 82,  82,  83, ..., 117, 117, 117],        [ 80,  81,  83, ..., 117, 117, 117],        ...,        [178, 178, 178, ...,  57,  59,  57],        [178, 178, 178, ...,  56,  57,  57],        [178, 178, 178, ...,  57,  57,  58]])                   我们可以用 imshow() 来显示图片数据：           plt.imshow(img,        # 设置坐标范围       extent = [-25, 25, -25, 25]) plt.colorbar()                         &lt;matplotlib.colorbar.Colorbar at 0x7f7199a56a58&gt;                                             更多参数和用法可以参阅帮助。   从脚本中运行   在脚本中使用 plot 时，通常图像是不会直接显示的，需要增加 show() 选项，只有在遇到 show() 命令之后，图像才会显示。   直方图   从高斯分布随机生成1000个点得到的直方图：           plt.hist(np.random.randn(1000))                         (array([  9.,  42.,  88., 151., 229., 196., 169.,  86.,  24.,   6.]),  array([-2.93034107, -2.34197965, -1.75361823, -1.16525681, -0.57689539,          0.01146603,  0.59982745,  1.18818887,  1.77655029,  2.36491171,          2.95327313]),  &lt;a list of 10 Patch objects&gt;)                                             更多例子请参考下列网站：   http://matplotlib.org/gallery.html  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/02.html",
        "teaser":null},{
        "title": "04-03 Numpy 数组及其索引",
        
        "excerpt":
            "Numpy 数组及其索引   先导入numpy：           from numpy import *            产生数组   从列表产生数组：           lst = [0, 1, 2, 3] a = array(lst) a                         array([0, 1, 2, 3])                   或者直接将列表传入：           a = array([1, 2, 3, 4]) a                         array([1, 2, 3, 4])                   数组属性   查看类型：           type(a)                         numpy.ndarray                   查看数组中的数据类型：           # 32比特的整数 a.dtype                         dtype('int64')                   查看每个元素所占的字节：           a.itemsize                         8                   查看形状，会返回一个元组，每个元素代表这一维的元素数目：           # 1维数组，返回一个元组 a.shape                         (4,)                   或者使用：           shape(a)                         (4,)                   shape 的使用历史要比 a.shape 久，而且还可以作用于别的类型：           lst = [1,2,3,4] shape(lst)                         (4,)                   查看元素数目：           a.size                         4                           size(a)                         4                   查看所有元素所占的空间：           a.nbytes                         32                   但事实上，数组所占的存储空间要比这个数字大，因为要用一个header来保存shape，dtype这样的信息。   查看数组维数：           a.ndim                         1                   使用fill方法设定初始值   可以使用 fill 方法将数组设为指定值：           a.fill(-4.8) a                         array([-4, -4, -4, -4])                   但是与列表不同，数组中要求所有元素的 dtype 是一样的，如果传入参数的类型与数组类型不一样，需要按照已有的类型进行转换。   索引与切片   和列表相似，数组也支持索引和切片操作。   索引第一个元素：           a = array([0, 1, 2, 3]) a[0]                         0                   修改第一个元素的值：           a[0] = 10 a                         array([10,  1,  2,  3])                   切片，支持负索引：           a = array([11,12,13,14,15]) a[1:3]                         array([12, 13])                           a[1:-2]                         array([12, 13])                           a[-4:3]                         array([12, 13])                   省略参数：           a[::2]                         array([11, 13, 15])                           a[-2:]                         array([14, 15])                   假设我们记录一辆汽车表盘上每天显示的里程数：           od = array([21000, 21180, 21240, 22100, 22400])            可以这样计算每天的旅程：           dist = od[1:] - od[:-1] dist                         array([180,  60, 860, 300])                   在本质上，Python会将array的各种计算转换为类似这样的C代码：   int compute_sum(int *arr, int N) {     int sum = 0;     int i;     for (i = 0; i &lt; N; i++) {         sum += arr[i];     }     return sum; }   多维数组及其属性   array 还可以用来生成多维数组：           a = array([[ 0, 1, 2, 3],            [10,11,12,13]]) a                         array([[ 0,  1,  2,  3],        [10, 11, 12, 13]])                   事实上我们传入的是一个以列表为元素的列表，最终得到一个二维数组。   甚至可以扩展到3D或者4D的情景。   查看形状：           a.shape                         (2, 4)                   这里2代表行数，4代表列数。   查看总的元素个数：           # 2 * 4 = 8 a.size                         8                   查看维数：           a.ndim                         2                   多维数组索引   对于二维数组，可以传入两个数字来索引：           a[1, 3]                         13                   其中，1是行索引，3是列索引，中间用逗号隔开，事实上，Python会将它们看成一个元组(1,3)，然后按照顺序进行对应。   可以利用索引给它赋值：           a[1, 3] = -1 a                         array([[ 0,  1,  2,  3],        [10, 11, 12, -1]])                   事实上，我们还可以使用单个索引来索引一整行内容：           # 返回第二行元组组成的array a[1]                         array([10, 11, 12, -1])                   Python会将这单个元组当成对第一维的索引，然后返回对应的内容。   多维数组切片   多维数组，也支持切片操作：           a = array([[ 0, 1, 2, 3, 4, 5],            [10,11,12,13,14,15],            [20,21,22,23,24,25],            [30,31,32,33,34,35],            [40,41,42,43,44,45],            [50,51,52,53,54,55]]) a                         array([[ 0,  1,  2,  3,  4,  5],        [10, 11, 12, 13, 14, 15],        [20, 21, 22, 23, 24, 25],        [30, 31, 32, 33, 34, 35],        [40, 41, 42, 43, 44, 45],        [50, 51, 52, 53, 54, 55]])                   想得到第一行的第 4 和第 5 两个元素：           a[0, 3:5]                         array([3, 4])                   得到最后两行的最后两列：           a[4:, 4:]                         array([[44, 45],        [54, 55]])                   得到第三列：           a[:, 2]                         array([ 2, 12, 22, 32, 42, 52])                   每一维都支持切片的规则，包括负索引，省略：   [lower:upper:step]   例如，取出3，5行的奇数列：           a[2::2, ::2]                         array([[20, 22, 24],        [40, 42, 44]])                   切片是引用   切片在内存中使用的是引用机制。           a = array([0,1,2,3,4]) b = a[2:4] print (b)                        [2 3]                  引用机制意味着，Python并没有为 b 分配新的空间来存储它的值，而是让 b 指向了 a 所分配的内存空间，因此，改变 b 会改变 a 的值：           b[0] = 10 a                         array([ 0,  1, 10,  3,  4])                   而这种现象在列表中并不会出现：           a = [1,2,3,4,5] b = a[2:3] b[0] = 13234 print (a)                        [1, 2, 3, 4, 5]                  这样做的好处在于，对于很大的数组，不用大量复制多余的值，节约了空间。   缺点在于，可能出现改变一个值改变另一个值的情况。   一个解决方法是使用copy()方法产生一个复制，这个复制会申请新的内存：           a = array([0,1,2,3,4]) b = a[2:4].copy() b[0] = 10 a                         array([0, 1, 2, 3, 4])                   花式索引   切片只能支持连续或者等间隔的切片操作，要想实现任意位置的操作，需要使用花式索引 fancy slicing 。   一维花式索引   与 range 函数类似，我们可以使用 arange 函数来产生等差数组。           a = arange(0, 80, 10) a                         array([ 0, 10, 20, 30, 40, 50, 60, 70])                   花式索引需要指定索引位置：           indices = [1, 2, -3] y = a[indices] print (y)                        [10 20 50]                  还可以使用布尔数组来花式索引：           mask = array([0,1,1,0,0,1,0,0],             dtype=bool)                    a[mask]                         array([10, 20, 50])                   或者用布尔表达式生成 mask，选出了所有大于0.5的值：           from numpy.random import rand a = rand(10) a                         array([0.30855819, 0.05557439, 0.86525128, 0.00160451, 0.89064744,        0.07488939, 0.07780041, 0.87250863, 0.80284702, 0.29153922])                           mask = a &gt; 0.5 a[mask]                         array([0.86525128, 0.89064744, 0.87250863, 0.80284702])                   mask 必须是布尔数组。   二维花式索引           a = array([[ 0, 1, 2, 3, 4, 5],            [10,11,12,13,14,15],            [20,21,22,23,24,25],            [30,31,32,33,34,35],            [40,41,42,43,44,45],            [50,51,52,53,54,55]]) a                         array([[ 0,  1,  2,  3,  4,  5],        [10, 11, 12, 13, 14, 15],        [20, 21, 22, 23, 24, 25],        [30, 31, 32, 33, 34, 35],        [40, 41, 42, 43, 44, 45],        [50, 51, 52, 53, 54, 55]])                   对于二维花式索引，我们需要给定 row 和 col 的值：           a[(0,1,2,3,4), (1,2,3,4,5)]                         array([ 1, 12, 23, 34, 45])                   返回的是一条次对角线上的5个值。           a[3:, [0,2,5]]                         array([[30, 32, 35],        [40, 42, 45],        [50, 52, 55]])                   返回的是最后三行的第1，3，5列。   也可以使用mask进行索引：           mask = array([1,0,1,0,0,1],             dtype=bool) a[mask, 2]                         array([ 2, 22, 52])                   与切片不同，花式索引返回的是原对象的一个复制而不是引用。   “不完全”索引   只给定行索引的时候，返回整行：           y = a[:3] y                         array([[ 0,  1,  2,  3,  4,  5],        [10, 11, 12, 13, 14, 15],        [20, 21, 22, 23, 24, 25]])                   这时候也可以使用花式索引取出第2，3，5行：           condition = array([0,1,1,0,1]) a[condition]                         array([[ 0,  1,  2,  3,  4,  5],        [10, 11, 12, 13, 14, 15],        [10, 11, 12, 13, 14, 15],        [ 0,  1,  2,  3,  4,  5],        [10, 11, 12, 13, 14, 15]])                   三维花式索引           a = arange(64) a.shape = 4,4,4 a                         array([[[ 0,  1,  2,  3],         [ 4,  5,  6,  7],         [ 8,  9, 10, 11],         [12, 13, 14, 15]],         [[16, 17, 18, 19],         [20, 21, 22, 23],         [24, 25, 26, 27],         [28, 29, 30, 31]],         [[32, 33, 34, 35],         [36, 37, 38, 39],         [40, 41, 42, 43],         [44, 45, 46, 47]],         [[48, 49, 50, 51],         [52, 53, 54, 55],         [56, 57, 58, 59],         [60, 61, 62, 63]]])                           y = a[:,:,[2, -1]] y                         array([[[ 2,  3],         [ 6,  7],         [10, 11],         [14, 15]],         [[18, 19],         [22, 23],         [26, 27],         [30, 31]],         [[34, 35],         [38, 39],         [42, 43],         [46, 47]],         [[50, 51],         [54, 55],         [58, 59],         [62, 63]]])                   where语句   where(array)   where 函数会返回所有非零元素的索引。   一维数组   先看一维的例子：           a = array([0, 12, 5, 20])            判断数组中的元素是不是大于10：           a &gt; 10                         array([False,  True, False,  True])                   数组中所有大于10的元素的索引位置：           where(a &gt; 10)                         (array([1, 3]),)                   注意到 where 的返回值是一个元组。   使用元组是由于 where 可以对多维数组使用，此时返回值就是多维的。   在使用的时候，我们可以这样：           indices = where(a &gt; 10) indices = indices[0] indices                         array([1, 3])                   或者：           indices = where(a&gt;10)[0] indices                         array([1, 3])                   可以直接用 where 的返回值进行索引：           loc = where(a &gt; 10) a[loc]                         array([12, 20])                   多维数组   考虑二维数组：           a = array([[0, 12, 5, 20],            [1, 2, 11, 15]]) loc = where(a &gt; 10)            返回结果是一个二维的元组，每一维代表这一维的索引值：           loc                         (array([0, 0, 1, 1]), array([1, 3, 2, 3]))                   也可以直接用来索引a：           a[loc]                         array([12, 20, 11, 15])                   或者可以这样：           rows, cols = where(a&gt;10)                    rows                         array([0, 0, 1, 1])                           cols                         array([1, 3, 2, 3])                           a[rows, cols]                         array([12, 20, 11, 15])                   再看另一个例子：           a = arange(25) a.shape = 5,5 a                         array([[ 0,  1,  2,  3,  4],        [ 5,  6,  7,  8,  9],        [10, 11, 12, 13, 14],        [15, 16, 17, 18, 19],        [20, 21, 22, 23, 24]])                           a &gt; 12                         array([[False, False, False, False, False],        [False, False, False, False, False],        [False, False, False,  True,  True],        [ True,  True,  True,  True,  True],        [ True,  True,  True,  True,  True]])                           where(a &gt; 12)                         (array([2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4]),  array([3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4]))                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/03.html",
        "teaser":null},{
        "title": "04-04 数组类型",
        
        "excerpt":
            "数组类型           from numpy import *            之前已经看过整数数组和布尔数组，除此之外还有浮点数数组和复数数组。   复数数组   产生一个复数数组：           a = array([1 + 1j, 2, 3, 4])            Python会自动判断数组的类型：           a.dtype                         dtype('complex128')                   对于复数我们可以查看它的实部和虚部：           a.real                         array([1., 2., 3., 4.])                           a.imag                         array([1., 0., 0., 0.])                   还可以设置它们的值：           a.imag = [1,2,3,4]            查看 a：           a                         array([1.+1.j, 2.+2.j, 3.+3.j, 4.+4.j])                   查看复共轭：           a.conj()                         array([1.-1.j, 2.-2.j, 3.-3.j, 4.-4.j])                   事实上，这些属性方法可以用在浮点数或者整数数组上：           a = array([0.,1,2,3]) a.dtype                         dtype('float64')                           a.real                         array([0., 1., 2., 3.])                           a.imag                         array([0., 0., 0., 0.])                           a.conj()                         array([0., 1., 2., 3.])                   但这里，虚部是只读的，并不能修改它的值：           # 会报错 a.imag = [1,2,3,4]                             ---------------------------------------------------------------------------      TypeError                                 Traceback (most recent call last)      &lt;ipython-input-13-cf65e0088418&gt; in &lt;module&gt;           1 # 会报错     ----&gt; 2 a.imag = [1,2,3,4]           TypeError: array does not have imaginary part to set                    指定数组类型   之前已经知道，构建数组的时候，数组会根据传入的内容自动判断类型：           a = array([0,1.0,2,3])            对于浮点数，默认为双精度：           a.dtype                         dtype('float64')                   查看所用字节（8 bytes * 4）：           a.nbytes                         32                   当然，我们也可以在构建的时候指定类型：           a = array([0,1.0,2,3],          dtype=float32)            此时类型为单精度浮点数：           a.dtype                         dtype('float32')                   查看所用字节（4 bytes * 4）：           a.nbytes                         16                   除此之外，还可以指定有无符号，例如无符号整数：           a = array([0,1,2,3],          dtype=uint8) a.dtype                         dtype('uint8')                   uint8 只使用一个字节，表示 0 到 255 的整数。   还可以从二进制数据中读取。   先写入二进制数据：           a = array([102,111,212],            dtype=uint8) a.tofile('foo.dat')            清理数据文件：           import os os.remove('foo.dat')            0-255 的数字可以表示ASCⅡ码，我们可以用 ord 函数来查看字符的ASCⅡ码值：           ord('f')                         102                           ord('S')                         83                   Numpy 类型   具体如下：                  基本类型       可用的Numpy类型       备注                       布尔型       bool       占1个字节                 整型       int8, int16, int32, int64, int128, int       int 跟C语言中的 long 一样大                 无符号整型       uint8, uint16, uint32, uint64, uint128, uint       uint 跟C语言中的 unsigned long 一样大                 浮点数       float16, float32, float64, float, longfloat       默认为双精度 float64 ，longfloat 精度大小与系统有关                 复数       complex64, complex128, complex, longcomplex       默认为 complex128 ，即实部虚部都为双精度                 字符串       string, unicode       可以使用 dtype=S4 表示一个4字节字符串的数组                 对象       object       数组中可以使用任意值                 Records       void                         时间       datetime64, timedelta64                   任意类型的数组：           a = array([1,1.2,'hello', [10,20,30]],            dtype=object)            乘法：           a * 2                         array([2, 2.4, 'hellohello', list([10, 20, 30, 10, 20, 30])], dtype=object)                   类型转换   转换数组的类型：           a = array([1.5, -3],           dtype=float32) a                         array([ 1.5, -3. ], dtype=float32)                   asarray 函数   使用 asarray 函数：           asarray(a, dtype=float64)                         array([ 1.5, -3. ])                           asarray(a, dtype=uint8)                         array([  1, 253], dtype=uint8)                   asarray 不会修改原来数组的值：           a                         array([ 1.5, -3. ], dtype=float32)                   但当类型相同的时候，asarray 并不会产生新的对象，而是使用同一个引用：           b = asarray(a, dtype=float32)                    b is a                          True                   这么做的好处在与，asarray 不仅可以作用于数组，还可以将其他类型转化为数组。   有些时候为了保证我们的输入值是数组，我们需要将其使用 asarray 转化，当它已经是数组的时候，并不会产生新的对象，这样保证了效率。           asarray([1,2,3,4])                         array([1, 2, 3, 4])                   astype 方法   astype 方法返回一个新数组：           a.astype(float64)                         array([ 1.5, -3. ])                           a.astype(uint8)                         array([  1, 253], dtype=uint8)                   astype也不会改变原来数组的值：           a                         array([ 1.5, -3. ], dtype=float32)                   另外，astype 总是返回原来数组的一份复制，即使转换的类型是相同的：           b = a.astype(float32) print (a) print (b)                        [ 1.5 -3. ] [ 1.5 -3. ]                          a is b                         False                   view 方法           a = array((1,2,3,4), dtype=int32) a                         array([1, 2, 3, 4], dtype=int32)                   view 会将 a 在内存中的表示看成是 uint8 进行解析：           b = a.view(uint8) b                         array([1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0], dtype=uint8)                           a[0] = 2**30 a                         array([1073741824,          2,          3,          4], dtype=int32)                   修改 a 会修改 b 的值，因为共用一块内存：           b                         array([ 0,  0,  0, 64,  2,  0,  0,  0,  3,  0,  0,  0,  4,  0,  0,  0],       dtype=uint8)                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/04.html",
        "teaser":null},{
        "title": "04-05 数组方法",
        
        "excerpt":
            "数组方法           %pylab                        Using matplotlib backend: Qt4Agg Populating the interactive namespace from numpy and matplotlib                  求和           a = array([[1,2,3],             [4,5,6]])            求所有元素的和：           sum(a)                         21                   指定求和的维度：   沿着第一维求和：           sum(a, axis=0)                         array([5, 7, 9])                   沿着第二维求和：           sum(a, axis=1)                         array([ 6, 15])                   沿着最后一维求和：           sum(a, axis=-1)                         array([ 6, 15])                   或者使用 sum 方法：           a.sum()                         21                           a.sum(axis=0)                         array([5, 7, 9])                           a.sum(axis=-1)                         array([ 6, 15])                   求积   求所有元素的乘积：           a.prod()                         720                   或者使用函数形式：           prod(a, axis=0)                         array([ 4, 10, 18])                   求最大最小值           from numpy.random import rand a = rand(3, 4) %precision 3 a                         array([[ 0.444,  0.06 ,  0.668,  0.02 ],        [ 0.793,  0.302,  0.81 ,  0.381],        [ 0.296,  0.182,  0.345,  0.686]])                   全局最小：           a.min()                         0.020                   沿着某个轴的最小：           a.min(axis=0)                         array([ 0.296,  0.06 ,  0.345,  0.02 ])                   全局最大：           a.max()                         0.810                   沿着某个轴的最大：           a.max(axis=-1)                         array([ 0.668,  0.81 ,  0.686])                   最大最小值的位置   使用 argmin, argmax 方法：           a.argmin()                         3                           a.argmin(axis=0)                         array([2, 0, 2, 0], dtype=int64)                   均值   可以使用 mean 方法：           a = array([[1,2,3],[4,5,6]])                    a.mean()                         3.500                           a.mean(axis=-1)                         array([ 2.,  5.])                   也可以使用 mean 函数：           mean(a)                         3.500                   还可以使用 average 函数：           average(a, axis = 0)                         array([ 2.5,  3.5,  4.5])                   average 函数还支持加权平均：           average(a, axis = 0, weights=[1,2])                         array([ 3.,  4.,  5.])                   标准差   用 std 方法计算标准差：           a.std(axis=1)                         array([ 0.816,  0.816])                   用 var 方法计算方差：           a.var(axis=1)                         array([ 0.667,  0.667])                   或者使用函数：           var(a, axis=1)                         array([ 0.667,  0.667])                           std(a, axis=1)                         array([ 0.816,  0.816])                   clip 方法   将数值限制在某个范围：           a                         array([[1, 2, 3],        [4, 5, 6]])                           a.clip(3,5)                         array([[3, 3, 3],        [4, 5, 5]])                   小于3的变成3，大于5的变成5。   ptp 方法   计算最大值和最小值之差：           a.ptp(axis=1)                         array([2, 2])                           a.ptp()                         5                   round 方法   近似，默认到整数：           a = array([1.35, 2.5, 1.5])            这里，.5的近似规则为近似到偶数值，可以参考：   https://en.wikipedia.org/wiki/Rounding#Round_half_to_odd           a.round()                         array([ 1.,  2.,  2.])                   近似到一位小数：           a.round(decimals=1)                         array([ 1.4,  2.5,  1.5])                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/05.html",
        "teaser":null},{
        "title": "04-06 数组排序",
        
        "excerpt":
            "数组排序           %pylab                        Using matplotlib backend: Qt4Agg Populating the interactive namespace from numpy and matplotlib                  sort 函数   先看这个例子：           names = array(['bob', 'sue', 'jan', 'ad']) weights = array([20.8, 93.2, 53.4, 61.8])  sort(weights)                         array([ 20.8,  53.4,  61.8,  93.2])                   sort 返回的结果是从小到大排列的。   argsort 函数   argsort 返回从小到大的排列在数组中的索引位置：           ordered_indices = argsort(weights) ordered_indices                         array([0, 2, 3, 1], dtype=int64)                   可以用它来进行索引：           weights[ordered_indices]                         array([ 20.8,  53.4,  61.8,  93.2])                           names[ordered_indices]                         array(['bob', 'jan', 'ad', 'sue'],        dtype='|S3')                   使用函数并不会改变原来数组的值：           weights                         array([ 20.8,  93.2,  53.4,  61.8])                   sort 和 argsort 方法   数组也支持方法操作：           data = array([20.8,  93.2,  53.4,  61.8]) data.argsort()                         array([0, 2, 3, 1], dtype=int64)                   argsort 方法与 argsort 函数的使用没什么区别，也不会改变数组的值。           data                         array([ 20.8,  93.2,  53.4,  61.8])                   但是 sort方法会改变数组的值：           data.sort()                    data                         array([ 20.8,  53.4,  61.8,  93.2])                   二维数组排序   对于多维数组，sort方法默认沿着最后一维开始排序：           a = array([         [.2, .1, .5],          [.4, .8, .3],         [.9, .6, .7]     ]) a                         array([[ 0.2,  0.1,  0.5],        [ 0.4,  0.8,  0.3],        [ 0.9,  0.6,  0.7]])                   对于二维数组，默认相当于对每一行进行排序：           sort(a)                         array([[ 0.1,  0.2,  0.5],        [ 0.3,  0.4,  0.8],        [ 0.6,  0.7,  0.9]])                   改变轴，对每一列进行排序：           sort(a, axis = 0)                         array([[ 0.2,  0.1,  0.3],        [ 0.4,  0.6,  0.5],        [ 0.9,  0.8,  0.7]])                   searchsorted 函数   searchsorted(sorted_array, values)   searchsorted 接受两个参数，其中，第一个必需是已排序的数组。           sorted_array = linspace(0,1,5) values = array([.1,.8,.3,.12,.5,.25])                    searchsorted(sorted_array, values)                         array([1, 4, 2, 1, 2, 1], dtype=int64)                   排序数组：                  0       1       2       3       4                       0.0       0.25       0.5       0.75       1.0           数值：                  值       0.1       0.8       0.3       0.12       0.5       0.25                       插入位置       1       4       2       1       2       1           searchsorted 返回的值相当于保持第一个数组的排序性质不变，将第二个数组中的值插入第一个数组中的位置：   例如 0.1 在 [0.0, 0.25) 之间，所以插入时应当放在第一个数组的索引 1 处，故第一个返回值为 1。           from numpy.random import rand data = rand(100) data.sort()            不加括号，默认是元组：           bounds = .4, .6 bounds                         (0.4, 0.6)                   返回这两个值对应的插入位置：           low_idx, high_idx = searchsorted(data, bounds)            利用插入位置，将数组中所有在这两个值之间的值提取出来：           data[low_idx:high_idx]                         array([ 0.41122674,  0.4395727 ,  0.45609773,  0.45707137,  0.45772076,         0.46029997,  0.46757401,  0.47525517,  0.4969198 ,  0.53068779,         0.55764166,  0.56288568,  0.56506548,  0.57003042,  0.58035233,         0.59279233,  0.59548555])                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/06.html",
        "teaser":null},{
        "title": "04-07 数组形状",
        
        "excerpt":
            "数组形状           %pylab                        Using matplotlib backend: Qt4Agg Populating the interactive namespace from numpy and matplotlib                  修改数组的形状           a = arange(6) a                         array([0, 1, 2, 3, 4, 5])                   将形状修改为2乘3：           a.shape = 2,3 a                         array([[0, 1, 2],        [3, 4, 5]])                   与之对应的方法是 reshape ，但它不会修改原来数组的值，而是返回一个新的数组：           a.reshape(3,2)                         array([[0, 1],        [2, 3],        [4, 5]])                           a                         array([[0, 1, 2],        [3, 4, 5]])                   shape 和 reshape 方法不能改变数组中元素的总数，否则会报错：           a.reshape(4,2)                             ---------------------------------------------------------------------------      ValueError                                Traceback (most recent call last)      &lt;ipython-input-6-1a35a76a1693&gt; in &lt;module&gt;()     ----&gt; 1 a.reshape(4,2)           ValueError: total size of new array must be unchanged                    使用 newaxis 增加数组维数           a = arange(3) shape(a)                         (3L,)                           y = a[newaxis, :] shape(y)                         (1L, 3L)                   根据插入位置的不同，可以返回不同形状的数组：           y = a[:, newaxis] shape(y)                         (3L, 1L)                   插入多个新维度：           y = a[newaxis, newaxis, :] shape(y)                         (1L, 1L, 3L)                   squeeze 方法去除多余的轴           a = arange(6) a.shape = (2,1,3)                    b = a.squeeze() b.shape                         (2L, 3L)                   squeeze 返回一个将所有长度为1的维度去除的新数组。   数组转置   使用 transpose 返回数组的转置，本质上是将所有维度反过来：           a                         array([[[0, 1, 2]],         [[3, 4, 5]]])                   对于二维数组，这相当于交换行和列：           a.transpose()                         array([[[0, 3]],         [[1, 4]],         [[2, 5]]])                   或者使用缩写属性：           a.T                         array([[[0, 3]],         [[1, 4]],         [[2, 5]]])                   注意：     对于复数数组，转置并不返回复共轭，只是单纯的交换轴的位置   转置可以作用于多维数组           a = arange(60) a                         array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,        34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,        51, 52, 53, 54, 55, 56, 57, 58, 59])                           a.shape = 3,4,5 a                         array([[[ 0,  1,  2,  3,  4],         [ 5,  6,  7,  8,  9],         [10, 11, 12, 13, 14],         [15, 16, 17, 18, 19]],         [[20, 21, 22, 23, 24],         [25, 26, 27, 28, 29],         [30, 31, 32, 33, 34],         [35, 36, 37, 38, 39]],         [[40, 41, 42, 43, 44],         [45, 46, 47, 48, 49],         [50, 51, 52, 53, 54],         [55, 56, 57, 58, 59]]])                           b = a.T b.shape                         (5L, 4L, 3L)                   转置只是交换了轴的位置。   另一方面，转置返回的是对原数组的另一种view，所以改变转置会改变原来数组的值。           a = arange(6) a.shape = (2,3) a                         array([[0, 1, 2],        [3, 4, 5]])                   修改转置：           b = a.T b[0,1] = 30            原数组的值也改变：           a                         array([[ 0,  1,  2],        [30,  4,  5]])                   数组连接   有时我们需要将不同的数组按照一定的顺序连接起来：   concatenate((a0,a1,...,aN), axis=0)   注意，这些数组要用 () 包括到一个元组中去。   除了给定的轴外，这些数组其他轴的长度必须是一样的。           x = array([         [0,1,2],         [10,11,12]     ]) y = array([         [50,51,52],         [60,61,62]     ]) print x.shape print y.shape                        (2L, 3L) (2L, 3L)                  默认沿着第一维进行连接：           z = concatenate((x,y)) z                         array([[ 0,  1,  2],        [10, 11, 12],        [50, 51, 52],        [60, 61, 62]])                           z.shape                         (4L, 3L)                   沿着第二维进行连接：           z = concatenate((x,y), axis=1) z                         array([[ 0,  1,  2, 50, 51, 52],        [10, 11, 12, 60, 61, 62]])                           z.shape                         (2L, 6L)                   注意到这里 x 和 y 的形状是一样的，还可以将它们连接成三维的数组，但是 concatenate 不能提供这样的功能，不过可以这样：           z = array((x,y))                    z.shape                         (2L, 2L, 3L)                   事实上，Numpy提供了分别对应这三种情况的函数：      vstack   hstack   dstack           vstack((x, y)).shape                         (4L, 3L)                           hstack((x, y)).shape                         (2L, 6L)                           dstack((x, y)).shape                         (2L, 3L, 2L)                   Flatten 数组   flatten 方法的作用是将多维数组转化为1维数组：           a = array([[0,1],            [2,3]]) b = a.flatten() b                         array([0, 1, 2, 3])                   返回的是数组的复制，因此，改变 b 并不会影响 a 的值：           b[0] = 10 print b print a                        [10  1  2  3] [[0 1]  [2 3]]                  flat 属性   还可以使用数组自带的 flat 属性：           a.flat                         &lt;numpy.flatiter at 0x3d546a0&gt;                   a.flat 相当于返回了所有元组组成的一个迭代器：           b = a.flat                    b[0]                         0                   但此时修改 b 的值会影响 a ：           b[0] = 10 print a                        [[10  1]  [ 2  3]]                          a.flat[:]                         array([10,  1,  2,  3])                   ravel 方法   除此之外，还可以使用 ravel 方法，ravel 使用高效的表示方式：           a = array([[0,1],            [2,3]]) b = a.ravel() b                         array([0, 1, 2, 3])                   修改 b 会改变 a ：           b[0] = 10 a                         array([[10,  1],        [ 2,  3]])                   但另一种情况下：           a = array([[0,1],            [2,3]]) aa = a.transpose() b = aa.ravel() b                         array([0, 2, 1, 3])                           b[0] = 10                    aa                         array([[0, 2],        [1, 3]])                           a                         array([[0, 1],        [2, 3]])                   可以看到，在这种情况下，修改 b 并不会改变 aa 的值，原因是我们用来 ravel 的对象 aa 本身是 a 的一个view。   atleast_xd 函数   保证数组至少有 x 维：           x = 1 atleast_1d(x)                         array([1])                           a = array([1,2,3]) b = atleast_2d(a) b.shape                         (1L, 3L)                           b                         array([[1, 2, 3]])                           c = atleast_3d(b)                    c.shape                         (1L, 3L, 1L)                   x 可以取值 1，2，3。   在Scipy库中，这些函数被用来保证输入满足一定的条件：“                  用法       Scipy中出现次数                       value.flaten()   value.flat    value.ravel()       ~2000次                 atleast_1d(value)   atleast_2d(value)       ~700次                 asarray(value)       ~4000次          ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/07.html",
        "teaser":null},{
        "title": "04-08 对角线",
        
        "excerpt":
            "对角线   这里，使用与之前不同的导入方法：           import numpy as np            使用numpy中的函数前，需要加上 np.：           a = np.array([11,21,31,12,22,32,13,23,33]) a.shape = 3,3 a                         array([[11, 21, 31],        [12, 22, 32],        [13, 23, 33]])                   查看它的对角线元素：           a.diagonal()                         array([11, 22, 33])                   可以使用偏移来查看它的次对角线，正数表示右移，负数表示左移：           a.diagonal(offset=1)                         array([21, 32])                           a.diagonal(offset=-1)                         array([12, 23])                   可以使用花式索引来得到对角线：           i = [0,1,2] a[i, i]                         array([11, 22, 33])                   可以更新对角线的值：           a[i, i] = 2 a                         array([[ 2, 21, 31],        [12,  2, 32],        [13, 23,  2]])                   修改次对角线的值：           i = np.array([0,1]) a[i, i + 1] = 1 a                         array([[ 2,  1, 31],        [12,  2,  1],        [13, 23,  2]])                           a[i + 1, i] = -1 a                         array([[ 2,  1, 31],        [-1,  2,  1],        [13, -1,  2]])                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/08.html",
        "teaser":null},{
        "title": "04-09 数组与字符串的转换",
        
        "excerpt":
            "数组与字符串的转换   tostring 方法           import numpy as np                    a = np.array([[1,2],            [3,4]],            dtype = np.uint8)            转化为字符串：           a.tostring()                         '\\x01\\x02\\x03\\x04'                   我们可以使用不同的顺序来转换字符串：           a.tostring(order='F')                         '\\x01\\x03\\x02\\x04'                   这里使用了Fortran的格式，按照列来读数据。   fromstring 函数   可以使用 fromstring 函数从字符串中读出数据，不过要指定类型：           s = a.tostring() a = np.fromstring(s,                    dtype=np.uint8) a                         array([1, 2, 3, 4], dtype=uint8)                   此时，返回的数组是一维的，需要重新设定维度：           a.shape = 2,2 a                         array([[1, 2],        [3, 4]], dtype=uint8)                   对于文本文件，推荐使用     loadtxt   genfromtxt   savetxt   对于二进制文本文件，推荐使用     save   load   savez  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/09.html",
        "teaser":null},{
        "title": "04-10 数组属性方法总结",
        
        "excerpt":
            "数组属性方法总结                  方法       作用                       1       基本属性                 a.dtype       数组元素类型 float32,uint8,...                 a.shape       数组形状 (m,n,o,...)                 a.size       数组元素数                 a.itemsize       每个元素占字节数                 a.nbytes       所有元素占的字节                 a.ndim       数组维度                 2       形状相关                 a.flat       所有元素的迭代器                 a.flatten()       返回一个1维数组的复制                 a.ravel()       返回一个1维数组，高效                 a.resize(new_size)       改变形状                 a.swapaxes(axis1, axis2)       交换两个维度的位置                 a.transpose(*axex)       交换所有维度的位置                 a.T       转置，a.transpose()                 a.squeeze()       去除所有长度为1的维度                 3       填充复制                 a.copy()       返回数组的一个复制                 a.fill(value)       将数组的元组设置为特定值                 4       转化                 a.tolist()       将数组转化为列表                 a.tostring()       转换为字符串                 a.astype(dtype)       转化为指定类型                 a.byteswap(False)       转换大小字节序                 a.view(type_or_dtype)       生成一个使用相同内存，但使用不同的表示方法的数组                 5       复数                 a.imag       虚部                 a.real       实部                 a.conjugate()       复共轭                 a.conj()       复共轭（缩写）                 6       保存                 a.dump(file)       将二进制数据存在file中                 a.dump()       将二进制数据表示成字符串                 a.tofile(fid, sep=\"\",format=\"%s\")       格式化ASCⅡ码写入文件                 7       查找排序                 a.nonzero()       返回所有非零元素的索引                 a.sort(axis=-1)       沿某个轴排序                 a.argsort(axis=-1)       沿某个轴，返回按排序的索引                 a.searchsorted(b)       返回将b中元素插入a后能保持有序的索引值                 8       元素数学操作                 a.clip(low, high)       将数值限制在一定范围内                 a.round(decimals=0)       近似到指定精度                 a.cumsum(axis=None)       累加和                 a.cumprod(axis=None)       累乘积                 9       约简操作                 a.sum(axis=None)       求和                 a.prod(axis=None)       求积                 a.min(axis=None)       最小值                 a.max(axis=None)       最大值                 a.argmin(axis=None)       最小值索引                 a.argmax(axis=None)       最大值索引                 a.ptp(axis=None)       最大值减最小值                 a.mean(axis=None)       平均值                 a.std(axis=None)       标准差                 a.var(axis=None)       方差                 a.any(axis=None)       只要有一个不为0，返回真，逻辑或                 a.all(axis=None)       所有都不为0，返回真，逻辑与                   from numpy import *            基本属性           a = array([[0, 1, 2, 3], [4, 5, 6, 7]]) a                         array([[0, 1, 2, 3],        [4, 5, 6, 7]])                   数组元素属性：           a.dtype                         dtype('int32')                   形状：           a.shape                         (2L, 4L)                   元素数目：           a.size                         8                   元素占字节大小：           a.itemsize                         4                   所有元素所占字节：           a.nbytes                         32                   数据维度：           a.ndim                         2                   形状相关           for row in a:     print row                        [0 1 2 3] [4 5 6 7]                  所有元素的迭代器：           for elt in a.flat:     print elt                        0 1 2 3 4 5 6 7                  所有元素组成的一维数组，按照行排列：           a.flatten()                         array([0, 1, 2, 3, 4, 5, 6, 7])                           a.ravel()                         array([0, 1, 2, 3, 4, 5, 6, 7])                   重新改变形状：           a.resize((4,2)) a                         array([[0, 1],        [2, 3],        [4, 5],        [6, 7]])                   交换这两个轴的顺序：           a.swapaxes(0,1)                         array([[0, 2, 4, 6],        [1, 3, 5, 7]])                   转置：           a.transpose()                         array([[0, 2, 4, 6],        [1, 3, 5, 7]])                   转置：           a.T                         array([[0, 2, 4, 6],        [1, 3, 5, 7]])                           a2 = array([1,2,3]) a2.shape                         (3L,)                           a2.resize((1,3,1)) a2.shape                         (1L, 3L, 1L)                   去除长度为1的维度：           a2 = a2.squeeze() a2.shape                         (3L,)                   填充复制   复制：           b = a.copy() b                         array([[0, 1],        [2, 3],        [4, 5],        [6, 7]])                   复制不影响原来的数组：           b[0][0] = -1 b # First value changed                         array([[-1,  1],        [ 2,  3],        [ 4,  5],        [ 6,  7]])                           a # original not changed because b is a copy                         array([[0, 1],        [2, 3],        [4, 5],        [6, 7]])                   填充：           b.fill(4) b                         array([[4, 4],        [4, 4],        [4, 4],        [4, 4]])                   转化   转化为列表：           a.tolist()                         [[0, 1], [2, 3], [4, 5], [6, 7]]                   转化为字符串：           a.tostring()                         '\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x00\\x00'                   改变数组元素类型：           a.astype(float)                         array([[ 0.,  1.],        [ 2.,  3.],        [ 4.,  5.],        [ 6.,  7.]])                           b = a.copy() b.byteswap(False)                         array([[        0,  16777216],        [ 33554432,  50331648],        [ 67108864,  83886080],        [100663296, 117440512]])                   将它看成16位整数：           a.view(dtype=int16)                         array([[0, 0, 1, 0],        [2, 0, 3, 0],        [4, 0, 5, 0],        [6, 0, 7, 0]], dtype=int16)                   复数   实部：           b = array([1+2j, 3+4j, 5+6j]) b.real                         array([ 1.,  3.,  5.])                   虚部：           b.imag                         array([ 2.,  4.,  6.])                   共轭：           b.conj()                         array([ 1.-2.j,  3.-4.j,  5.-6.j])                           b.conjugate()                         array([ 1.-2.j,  3.-4.j,  5.-6.j])                   保存   保存成文本：           a.dump(\"file.txt\")            字符串：           a.dumps()                         '\\x80\\x02cnumpy.core.multiarray\\n_reconstruct\\nq\\x01cnumpy\\nndarray\\nq\\x02K\\x00\\x85U\\x01b\\x87Rq\\x03(K\\x01\\x8a\\x01\\x04\\x8a\\x01\\x02\\x86cnumpy\\ndtype\\nq\\x04U\\x02i4K\\x00K\\x01\\x87Rq\\x05(K\\x03U\\x01&lt;NNNJ\\xff\\xff\\xff\\xffJ\\xff\\xff\\xff\\xffK\\x00tb\\x89U \\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x07\\x00\\x00\\x00tb.'                   写入文件：           a.tofile('foo.csv', sep=',', format=\"%s\")            查找排序   非零元素的索引：           a.nonzero()                         (array([0, 1, 1, 2, 2, 3, 3], dtype=int64),  array([1, 0, 1, 0, 1, 0, 1], dtype=int64))                   排序：           b = array([3,2,7,4,1]) b.sort() b                         array([1, 2, 3, 4, 7])                   排序的索引位置：           b = array([2,3,1]) b.argsort(axis=-1)                         array([2, 0, 1], dtype=int64)                   将 b 插入 a 中的索引，使得 a 保持有序：           a = array([1,3,4,6]) b = array([0,2,5]) a.searchsorted(b)                         array([0, 1, 3], dtype=int64)                   元素数学操作   限制在一定范围：           a = array([[4,1,3],[2,1,5]]) a.clip(0,2)                         array([[2, 1, 2],        [2, 1, 2]])                   近似：           a = array([1.344, 2.449, 2.558]) a.round(decimals=2)                         array([ 1.34,  2.45,  2.56])                   累加和：           a = array([[4,1,3],[2,1,5]]) a.cumsum(axis=None)                         array([ 4,  5,  8, 10, 11, 16])                   累乘积：           a.cumprod(axis=None)                         array([  4,   4,  12,  24,  24, 120])                   约简操作   求和：           a = array([[4,1,3],[2,1,5]]) a.sum(axis=None)                         16                   求积：           a.prod(axis=None)                         120                   最小值：           a.min(axis=None)                         1                   最大值：           a.max(axis=None)                         5                   最小值索引：           a.argmin(axis=None)                         1                   最大值索引：           a.argmax(axis=None)                         5                   最大间隔：           a.ptp(axis=None)                         4                   均值：           a.mean(axis=None)                         2.6666666666666665                   标准差：           a.std(axis=None)                         1.49071198499986                   方差：           a.var(axis=None)                         2.2222222222222228                   是否有非零元素：           a.any(axis=None)                         True                   是否全部非零：           a.all()                         True                   删除生成的文件：           import os os.remove('foo.csv') os.remove('file.txt')           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/10.html",
        "teaser":null},{
        "title": "04-11 生成数组的函数",
        
        "excerpt":
            "生成数组的函数   arange   arange 类似于Python中的 range 函数，只不过返回的不是列表，而是数组：   arange(start, stop=None, step=1, dtype=None)   产生一个在区间 [start, stop) 之间，以 step 为间隔的数组，如果只输入一个参数，则默认从 0 开始，并以这个值为结束：           import numpy as np np.arange(4)                         array([0, 1, 2, 3])                   与 range 不同， arange 允许非整数值输入，产生一个非整型的数组：           np.arange(0, 2 * np.pi, np.pi / 4)                         array([ 0.        ,  0.78539816,  1.57079633,  2.35619449,  3.14159265,         3.92699082,  4.71238898,  5.49778714])                   数组的类型默认由参数 start, stop, step 来确定，也可以指定：           np.arange(0, 2 * np.pi, np.pi / 4, dtype=np.float32)                         array([ 0.        ,  0.78539819,  1.57079637,  2.3561945 ,  3.14159274,         3.92699099,  4.71238899,  5.49778748], dtype=float32)                   由于存在精度问题，使用浮点数可能出现问题：           np.arange(1.5, 2.1, 0.3)                         array([ 1.5,  1.8,  2.1])                   stop 的值 2.1 出现在了数组中，所以使用浮点数的时候需要注意。   linspace   linspace(start, stop, N)   产生 N 个等距分布在 [start, stop]间的元素组成的数组，包括 start, stop。           np.linspace(0, 1, 5)                         array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])                   logspace   logspace(start, stop, N)   产生 N 个对数等距分布的数组，默认以10为底：           np.logspace(0, 1, 5)                         array([  1.        ,   1.77827941,   3.16227766,   5.62341325,  10.        ])                   产生的值为$\\left[10^0, 10^{0.25},10^{0.5},10^{0.75},10^1\\right]$。   meshgrid   有时候需要在二维平面中生成一个网格，这时候可以使用 meshgrid 来完成这样的工作：           x_ticks = np.linspace(-1, 1, 5) y_ticks = np.linspace(-1, 1, 5)  x, y = np.meshgrid(x_ticks, y_ticks)            这里产生的 x, y如下：           x                         array([[-1. , -0.5,  0. ,  0.5,  1. ],        [-1. , -0.5,  0. ,  0.5,  1. ],        [-1. , -0.5,  0. ,  0.5,  1. ],        [-1. , -0.5,  0. ,  0.5,  1. ],        [-1. , -0.5,  0. ,  0.5,  1. ]])                           y                         array([[-1. , -1. , -1. , -1. , -1. ],        [-0.5, -0.5, -0.5, -0.5, -0.5],        [ 0. ,  0. ,  0. ,  0. ,  0. ],        [ 0.5,  0.5,  0.5,  0.5,  0.5],        [ 1. ,  1. ,  1. ,  1. ,  1. ]])                   x 对应网格的第一维，y 对应网格的第二维。   图例：           %matplotlib inline import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm  def f(x, y):     # sinc 函数     r = np.sqrt(x ** 2 + y ** 2)     result = np.sin(r) / r     result[r == 0] = 1.0     return result  x_ticks = np.linspace(-10, 10, 51) y_ticks = np.linspace(-10, 10, 51)  x, y = np.meshgrid(x_ticks, y_ticks)  z = f(x, y)  fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z,                 rstride=1, cstride=1,                 cmap=cm.YlGnBu_r) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z')                         &lt;matplotlib.text.Text at 0x9ac1630&gt;                                             事实上，x, y 中有很多冗余的元素，这里提供了一个 sparse 的选项：           x_ticks = np.linspace(-1, 1, 5) y_ticks = np.linspace(-1, 1, 5)  x, y = np.meshgrid(x_ticks, y_ticks, sparse=True)                    x                         array([[-1. , -0.5,  0. ,  0.5,  1. ]])                           y                         array([[-1. ],        [-0.5],        [ 0. ],        [ 0.5],        [ 1. ]])                   在这个选项下，x, y 变成了单一的行向量和列向量。   但这并不影响结果：           x_ticks = np.linspace(-10, 10, 51) y_ticks = np.linspace(-10, 10, 51)  x, y = np.meshgrid(x_ticks, y_ticks, sparse=True)  z = f(x, y)  fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z,                 rstride=1, cstride=1,                 cmap=cm.YlGnBu_r) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z')                         &lt;matplotlib.text.Text at 0xba147f0&gt;                                             meshgrid 可以设置轴排列的先后顺序：     默认为 indexing='xy' 即笛卡尔坐标，对于2维数组，返回行向量 x 和列向量 y   或者使用 indexing='ij' 即矩阵坐标，对于2维数组，返回列向量 x 和行向量 y。   ogrid , mgrid   Matlab中有 meshgrid 的用法：   meshgrid(-1:.5:1, -1:.5:1)   Numpy的 meshgrid 并不支持这样的用法，但我们可以使用 ogrid / mgrid 来实现类似这样的用法。   ogrid 与 mgrid 的区别在于：     ogrid 相当于 meshgrid(indexing='ij', sparse=True)   mgrid 相当于 meshgrid(indexing='ij', sparse=False)           x, y = np.ogrid[-1:1:.5, -1:1:.5]                    x                         array([[-1. ],        [-0.5],        [ 0. ],        [ 0.5]])                           y                         array([[-1. , -0.5,  0. ,  0.5]])                   注意：     这里使用的是中括号   Matlab 使用的是 start:step:end 的表示，Numpy 使用的是 start:end:step 的表示   这里的结果不包括 end 的值   为了包含 end 的值，我们可以使用这样的技巧：           x, y = np.ogrid[-1:1:5j, -1:1:5j]                    x, y                         (array([[-1. ],         [-0.5],         [ 0. ],         [ 0.5],         [ 1. ]]), array([[-1. , -0.5,  0. ,  0.5,  1. ]]))                   我们在 step 的位置传入一个复数 5j ，表示我们需要一个 5 个值的数组，此时返回值就会包含 end 的值。   重复之前的画图：           # exchange here y, x = np.ogrid[-10:10:51j, -10:10:51j]  z = f(x, y)  fig = plt.figure() ax = fig.add_subplot(111, projection='3d') ax.plot_surface(x, y, z,                 rstride=1, cstride=1,                 cmap=cm.YlGnBu_r) ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('z')                         &lt;matplotlib.text.Text at 0x9e34278&gt;                                             这里，我们交换了 x, y 输出值的顺序。   r_ , c_   我们可以使用 r_ / c_ 来产生行向量或者列向量。   使用切片产生：           np.r_[0:1:.1]                         array([ 0. ,  0.1,  0.2,  0.3,  0.4,  0.5,  0.6,  0.7,  0.8,  0.9])                   复数步长制定数组长度：           np.r_[0:1:5j]                         array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])                   连接多个序列，产生数组：           np.r_[(3,22,11), 4.0, [15, 6]]                         array([  3.,  22.,  11.,   4.,  15.,   6.])                   列向量：           np.c_[1:3:5j]                         array([[ 1. ],        [ 1.5],        [ 2. ],        [ 2.5],        [ 3. ]])                   ones , zeros   ones(shape, dtype=float64) zeros(shape, dtype=float64)   产生一个制定形状的全 0 或全 1 的数组，还可以制定数组类型：           np.zeros(3)                         array([ 0.,  0.,  0.])                           np.ones([2,3], dtype=np.float32)                         array([[ 1.,  1.,  1.],        [ 1.,  1.,  1.]], dtype=float32)                   产生一个全是 5 的数组：           np.ones([2,3]) * 5                         array([[ 5.,  5.,  5.],        [ 5.,  5.,  5.]])                   empty   empty(shape, dtype=float64, order='C')   也可以使用 empty 方法产生一个制定大小的数组（数组所指向的内存未被初始化，所以值随机），再用 fill 方法填充：           a = np.empty(2) a                         array([-0.03412165,  0.05516321])                           a.fill(5) a                         array([ 5.,  5.])                   另一种替代方法使用索引，不过速度会稍微慢一些：           a[:] = 5 a                         array([ 5.,  5.])                   empty_like, ones_like, zeros_like   empty_like(a) ones_like(a) zeros_like(a)   产生一个跟 a 大小一样，类型一样的对应数组。           a = np.arange(0, 10, 2.5) a                         array([ 0. ,  2.5,  5. ,  7.5])                           np.empty_like(a)                         array([ 0.,  0.,  0.,  0.])                           np.zeros_like(a)                         array([ 0.,  0.,  0.,  0.])                           np.ones_like(a)                         array([ 1.,  1.,  1.,  1.])                   identity   indentity(n, dtype=float64) 产生一个 `n` 乘 `n` 的单位矩阵：           np.identity(3)                         array([[ 1.,  0.,  0.],        [ 0.,  1.,  0.],        [ 0.,  0.,  1.]])                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/11.html",
        "teaser":null},{
        "title": "04-12 矩阵",
        
        "excerpt":
            "矩阵   使用 mat 方法将 2 维数组转化为矩阵：           import numpy as np a = np.array([[1,2,4],               [2,5,3],                [7,8,9]]) A = np.mat(a) A                         matrix([[1, 2, 4],         [2, 5, 3],         [7, 8, 9]])                   也可以使用 Matlab 的语法传入一个字符串来生成矩阵：           A = np.mat('1,2,4;2,5,3;7,8,9') A                         matrix([[1, 2, 4],         [2, 5, 3],         [7, 8, 9]])                   利用分块创造新的矩阵：           a = np.array([[ 1, 2],               [ 3, 4]]) b = np.array([[10,20],                [30,40]])  np.bmat('a,b;b,a')                         matrix([[ 1,  2, 10, 20],         [ 3,  4, 30, 40],         [10, 20,  1,  2],         [30, 40,  3,  4]])                   矩阵与向量的乘法：           x = np.array([[1], [2], [3]]) x                         array([[1],        [2],        [3]])                           A * x                         matrix([[17],         [21],         [50]])                   A.I 表示 A 矩阵的逆矩阵：           print A * A.I                        [[  1.00000000e+00   0.00000000e+00   0.00000000e+00]  [  0.00000000e+00   1.00000000e+00   2.08166817e-17]  [  2.22044605e-16  -8.32667268e-17   1.00000000e+00]]                  矩阵指数表示矩阵连乘：           print A ** 4                        [[ 6497  9580  9836]  [ 7138 10561 10818]  [18434 27220 27945]]                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/12.html",
        "teaser":null},{
        "title": "04-13 一般函数",
        
        "excerpt":
            "一般函数           import numpy as np            三角函数   sin(x) cos(x) tan(x) sinh(x) conh(x) tanh(x) arccos(x) arctan(x) arcsin(x) arccosh(x) arctanh(x) arcsinh(x) arctan2(x,y)   arctan2(x,y) 返回 arctan(x/y) 。   向量操作   dot(x,y) inner(x,y) cross(x,y) vdot(x,y) outer(x,y) kron(x,y) tensordot(x,y[,axis])   其他操作   exp(x) log(x) log10(x) sqrt(x) absolute(x) conjugate(x) negative(x) ceil(x) floor(x) fabs(x) hypot(x) fmod(x) maximum(x,y) minimum(x,y)   hypot 返回对应点 (x,y) 到原点的距离。           x = np.array([1,2,3]) y = np.array([4,5,6]) np.hypot(x,y)                         array([ 4.12310563,  5.38516481,  6.70820393])                   类型处理   iscomplexobj iscomplex isrealobj isreal imag real real_if_close isscalar isneginf isposinf isinf isfinite isnan nan_to_num common_type typename   正无穷：           np.inf                         inf                   负无穷：           -np.inf                         -inf                   非法值（Not a number）：           np.nan                         nan                   检查是否为无穷：           np.isinf(1.0)                         False                           np.isinf(np.inf)                         True                           np.isinf(-np.inf)                         True                   非法值：           np.array([0]) / 0.0                         array([ nan])                   这并不会报错，而是返回一个非法值。   只有 0/0 会得到 nan，非0值除以0会得到无穷：           a = np.arange(5.0) b = a / 0.0 b                         array([ nan,  inf,  inf,  inf,  inf])                   nan 与任何数进行比较都是 False：           b == np.nan                         array([False, False, False, False, False], dtype=bool)                   想要找出 nan 值需要使用 isnan：           np.isnan(b)                         array([ True, False, False, False, False], dtype=bool)                   修改形状   atleast_1d atleast_2d atleast_3d expand_dims apply_over_axes apply_along_axis hstack vstack dstack column_stack hsplit vsplit dsplit split squeeze   其他有用函数   fix mod amax amin ptp sum cumsum prod cumprod diff angle  unwrap sort_complex trim_zeros fliplr flipud rot90 diag eye select extract insert  roots poly any all disp unique nansum nanmax nanargmax nanargmin nanmin   nan 开头的函数会进行相应的操作，但是忽略 nan 值。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/13.html",
        "teaser":null},{
        "title": "04-14 向量化函数",
        
        "excerpt":
            "向量化函数   自定义的 sinc 函数：           ```import numpy as np       def sinc(x):     if x == 0.0:         return 1.0     else:         w = np.pi * x         return np.sin(w) / w      &lt;/div&gt;  &lt;/div&gt;  作用于单个数值：  &lt;div markdown=\"1\" class=\"cell code_cell\"&gt; &lt;div class=\"input_area\" markdown=\"1\"&gt; ```sinc(0.0)                         1.0                                                3.8981718325193755e-17                   但这个函数不能作用于数组：           ```x = np.array([1,2,3]) sinc(x)      &lt;/div&gt;  &lt;div class=\"output_wrapper\" markdown=\"1\"&gt; &lt;div class=\"output_subarea\" markdown=\"1\"&gt; {:.output_traceback_line}           ---------------------------------------------------------------------------  ValueError                                Traceback (most recent call last)  &lt;ipython-input-4-9d4f36f2aa7a&gt; in &lt;module&gt;()       1 x = np.array([1,2,3]) ----&gt; 2 sinc(x)   &lt;ipython-input-1-dffe464e3332&gt; in sinc(x)       2        3 def sinc(x): ----&gt; 4     if x == 0.0:       5         return 1.0       6     else:   ValueError: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()           &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;  可以使用 `numpy` 的 `vectorize` 将函数 `sinc` 向量化，产生一个新的函数：  &lt;div markdown=\"1\" class=\"cell code_cell\"&gt; &lt;div class=\"input_area\" markdown=\"1\"&gt; ```vsinc = np.vectorize(sinc) vsinc(x)                         array([  3.89817183e-17,  -3.89817183e-17,   3.89817183e-17])                   其作用是为 x 中的每一个值调用 sinc 函数：           ```import matplotlib.pyplot as plt %matplotlib inline       x = np.linspace(-5,5,101) plt.plot(x, vsinc(x))      &lt;/div&gt;  &lt;div class=\"output_wrapper\" markdown=\"1\"&gt; &lt;div class=\"output_subarea\" markdown=\"1\"&gt;   {:.output_data_text}          [&lt;matplotlib.lines.Line2D at 0xa24e4e0&gt;] ```                       &lt;/div&gt;   因为这样的用法涉及大量的函数调用，因此，向量化函数的效率并不高。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/14.html",
        "teaser":null},{
        "title": "04-15 二元运算",
        
        "excerpt":
            "二元运算           import numpy as np            四则运算                  运算       函数                       a + b       add(a,b)                 a - b       subtract(a,b)                 a * b       multiply(a,b)                 a / b       divide(a,b)                 a ** b       power(a,b)                 a % b       remainder(a,b)           以乘法为例，数组与标量相乘，相当于数组的每个元素乘以这个标量：           a = np.array([1,2]) a * 3                         array([3, 6])                   数组逐元素相乘：           a = np.array([1,2]) b = np.array([3,4]) a * b                         array([3, 8])                   使用函数：           np.multiply(a, b)                         array([3, 8])                   事实上，函数还可以接受第三个参数，表示将结果存入第三个参数中：           np.multiply(a, b, a)                         array([3, 8])                           a                         array([3, 8])                   比较和逻辑运算                  运算       函数&lt;                       ==       equal                 !=       not_equal                 &gt;       greater                 &gt;=       greater_equal                 &lt;       less                 &lt;=       less_equal                         logical_and                         logical_or                         logical_xor                         logical_not                 &amp;       bitwise_and                         bitwise_or                 ^       bitwise_xor                 ~       invert                 &gt;&gt;       right_shift                 &lt;&lt;       left_shift           等于操作也是逐元素比较的：           a = np.array([[1,2,3,4],               [2,3,4,5]]) b = np.array([[1,2,5,4],               [1,3,4,5]]) a == b                         array([[ True,  True, False,  True],        [False,  True,  True,  True]], dtype=bool)                   这意味着，如果我们在条件中要判断两个数组是否一样时，不能直接使用   if a == b:   而要使用：   if all(a==b):   对于浮点数，由于存在精度问题，使用函数 allclose 会更好：   if allclose(a,b):   logical_and 也是逐元素的 and 操作：           a = np.array([0,1,2]) b = np.array([0,10,0])  np.logical_and(a, b)                         array([False,  True, False], dtype=bool)                   0 被认为是 False，非零则是 True。   比特操作：           a = np.array([1,2,4,8]) b = np.array([16,32,64,128])  a | b                         array([ 17,  34,  68, 136])                   取反：           a = np.array([1,2,3,4], np.uint8) ~a                         array([254, 253, 252, 251], dtype=uint8)                   左移：           a &lt;&lt; 3                         array([ 8, 16, 24, 32], dtype=uint8)                   要注意的是 &amp; 的运算优先于比较运算如 &gt; 等，所以必要时候需要加上括号：           a = np.array([1,2,4,8]) b = np.array([16,32,64,128])  (a &gt; 3) &amp; (b &lt; 100)                         array([False, False,  True, False], dtype=bool)                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/15.html",
        "teaser":null},{
        "title": "04-16 ufunc 对象",
        
        "excerpt":
            "ufunc 对象   Numpy 有两种基本对象：ndarray (N-dimensional array object) 和 ufunc (universal function object)。ndarray 是存储单一数据类型的多维数组，而 ufunc 则是能够对数组进行处理的函数。   例如，我们之前所接触到的二元操作符对应的 Numpy 函数，如 add，就是一种 ufunc 对象，它可以作用于数组的每个元素。           import numpy as np                    a = np.array([0,1,2]) b = np.array([2,3,4])  np.add(a, b)                         array([2, 4, 6])                   查看支持的方法：           dir(np.add)                         ['__call__',  '__class__',  '__delattr__',  '__doc__',  '__format__',  '__getattribute__',  '__hash__',  '__init__',  '__name__',  '__new__',  '__reduce__',  '__reduce_ex__',  '__repr__',  '__setattr__',  '__sizeof__',  '__str__',  '__subclasshook__',  'accumulate',  'at',  'identity',  'nargs',  'nin',  'nout',  'ntypes',  'outer',  'reduce',  'reduceat',  'signature',  'types']                   除此之外，大部分能够作用于数组的数学函数如三角函数等，都是 ufunc 对象。   特别地，对于二元操作符所对应的 ufunc 对象，支持以下方法：   reduce 方法   op.reduce(a)   将op沿着某个轴应用，使得数组 a 的维数降低一维。   add 作用到一维数组上相当于求和：             a = np.array([1,2,3,4])  np.add.reduce(a)                         10                   多维数组默认只按照第一维进行运算：           a = np.array([[1,2,3],[4,5,6]])  np.add.reduce(a)                         array([5, 7, 9])                   指定维度：           np.add.reduce(a, 1)                         array([ 6, 15])                   作用于字符串：           a = np.array(['ab', 'cd', 'ef'], np.object)  np.add.reduce(a)                         'abcdef'                   逻辑运算：           a = np.array([1,1,0,1])  np.logical_and.reduce(a)                         False                           np.logical_or.reduce(a)                         True                   accumulate 方法   op.accumulate(a)   accumulate 可以看成保存 reduce 每一步的结果所形成的数组。     与之前类似：           a = np.array([1,2,3,4])  np.add.accumulate(a)                         array([ 1,  3,  6, 10])                           a = np.array(['ab', 'cd', 'ef'], np.object)  np.add.accumulate(a)                         array(['ab', 'abcd', 'abcdef'], dtype=object)                           a = np.array([1,1,0,1])  np.logical_and.accumulate(a)                         array([ True,  True, False, False], dtype=bool)                           np.logical_or.accumulate(a)                         array([ True,  True,  True,  True], dtype=bool)                   reduceat 方法   op.reduceat(a, indices)   reduceat 方法将操作符运用到指定的下标上，返回一个与 indices 大小相同的数组：             a = np.array([0, 10, 20, 30, 40, 50]) indices = np.array([1,4])  np.add.reduceat(a, indices)                         array([60, 90])                   这里，indices 为 [1, 4]，所以 60 表示从下标1（包括）加到下标4（不包括）的结果，90 表示从下标4（包括）加到结尾的结果。   outer 方法   op.outer(a, b)   对于 a 中每个元素，将 op 运用到它和 b 的每一个元素上所得到的结果：           a = np.array([0,1]) b = np.array([1,2,3])  np.add.outer(a, b)                         array([[1, 2, 3],        [2, 3, 4]])                   注意有顺序的区别：           np.add.outer(b, a)                         array([[1, 2],        [2, 3],        [3, 4]])                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/16.html",
        "teaser":null},{
        "title": "04-17 choose 函数",
        
        "excerpt":
            "choose 函数实现条件筛选   对于数组，我们有时候需要进行类似 switch 和 case 进行条件选择，此时使用 choose 函数十分方便：           import numpy as np                    control = np.array([[1,0,1],                     [2,1,0],                     [1,2,2]])  np.choose(control, [10, 11, 12])                         array([[11, 10, 11],        [12, 11, 10],        [11, 12, 12]])                   在上面的例子中，choose 将 0,1,2 对应的值映射为了 10, 11, 12，这里的 0,1,2 表示对应的下标。   事实上， choose 不仅仅能接受下标参数，还可以接受下标所在的位置：           i0 = np.array([[0,1,2],                [3,4,5],                [6,7,8]]) i2 = np.array([[20,21,22],                [23,24,25],                [26,27,28]]) control = np.array([[1,0,1],                     [2,1,0],                     [1,2,2]])  np.choose(control, [i0, 10, i2])                         array([[10,  1, 10],        [23, 10,  5],        [10, 27, 28]])                   这里，control 传入第一个 1 对应的是 10，传入的第一个 0 对应于 i0 相应位置的值即 1，剩下的以此类推。   下面的例子将数组中所有小于 10 的值变成了 10。           a = np.array([[ 0, 1, 2],                [10,11,12],                [20,21,22]])  a &lt; 10                         array([[ True,  True,  True],        [False, False, False],        [False, False, False]], dtype=bool)                           np.choose(a &lt; 10, (a, 10))                         array([[10, 10, 10],        [10, 11, 12],        [20, 21, 22]])                   下面的例子将数组中所有小于 10 的值变成了 10，大于 15 的值变成了 15。           a = np.array([[ 0, 1, 2],                [10,11,12],                [20,21,22]])  lt = a &lt; 10 gt = a &gt; 15  choice = lt + 2 * gt choice                         array([[1, 1, 1],        [0, 0, 0],        [2, 2, 2]])                           np.choose(choice, (a, 10, 15))                         array([[10, 10, 10],        [10, 11, 12],        [15, 15, 15]])                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/17.html",
        "teaser":null},{
        "title": "04-18 数组广播机制",
        
        "excerpt":
            "数组广播机制           import numpy as np            正常的加法：           a = np.array([[ 0, 0, 0],               [10,10,10],               [20,20,20],               [30,30,30]]) b = np.array([[ 0, 1, 2],               [ 0, 1, 2],               [ 0, 1, 2],               [ 0, 1, 2]]) a + b                         array([[ 0,  1,  2],        [10, 11, 12],        [20, 21, 22],        [30, 31, 32]])                   将 b 的值变成一维的 [0,1,2] 之后的加法：           b = np.array([0,1,2])  a + b                         array([[ 0,  1,  2],        [10, 11, 12],        [20, 21, 22],        [30, 31, 32]])                   结果一样，虽然两个数组的维数不一样，但是 Numpy 检测到 b 的维度与 a 的维度匹配，所以将 b 扩展为之前的形式，得到相同的形状。   对于更高维度，这样的扩展依然有效。   如果我们再将 a 变成一个列向量呢？           a = np.array([0,10,20,30]) a.shape = 4,1 a                         array([[ 0],        [10],        [20],        [30]])                           b                         array([0, 1, 2])                           a + b                         array([[ 0,  1,  2],        [10, 11, 12],        [20, 21, 22],        [30, 31, 32]])                   可以看到，虽然两者的维度并不相同，但是Numpy还是根据两者的维度，自动将它们进行扩展然后进行计算。   对于 Numpy 来说，维度匹配当且仅当：      维度相同   有一个的维度是1   匹配会从最后一维开始进行，直到某一个的维度全部匹配为止，因此对于以下情况，Numpy 都会进行相应的匹配：                  A       B       Result                       3d array: 256 x 256 x 3       1d array: 3       3d array: 256 x 256 x 3                 4d array: 8 x 1 x 6 x 1       3d array: 7 x 1 x 5       3d array: 8 x 7 x 6 x 5                 3d array: 5 x 4 x 3       1d array: 1       3d array: 5 x 4 x 3                 3d array: 15 x 4 x 13       1d array: 15 x 1 x 13       3d array: 15 x 4 x 13                 2d array: 4 x 1       1d array: 3       2d array: 4 x 3           匹配成功后，Numpy 会进行运算得到相应的结果。   当然，如果相应的维度不匹配，那么Numpy会报错：           a = np.array([0,10,20,30]) a.shape                         (4L,)                           b.shape                         (3L,)                           a + b                             ---------------------------------------------------------------------------      ValueError                                Traceback (most recent call last)      &lt;ipython-input-9-f96fb8f649b6&gt; in &lt;module&gt;()     ----&gt; 1 a + b           ValueError: operands could not be broadcast together with shapes (4,) (3,)                     将 a 转换为列向量，还是可以计算出结果：           a[:, np.newaxis] + b                         array([[ 0,  1,  2],        [10, 11, 12],        [20, 21, 22],        [30, 31, 32]])                   例子           x = np.linspace(-.5,.5, 21)                    y = x[:, np.newaxis]                    x.shape                         (21L,)                           y.shape                         (21L, 1L)                   先形成一个 21 乘 21 的网格，再计算网格到原点的距离：           radius = np.sqrt(x ** 2 + y ** 2)                    import matplotlib.pyplot as plt %matplotlib inline  plt.imshow(radius)                         &lt;matplotlib.image.AxesImage at 0xa2cb358&gt;                                            ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/18.html",
        "teaser":null},{
        "title": "04-19 数组读写",
        
        "excerpt":
            "数组读写   从文本中读取数组           import numpy as np            空格（制表符）分割的文本   假设我们有这样的一个空白分割的文件：           %%writefile myfile.txt 2.1 2.3 3.2 1.3 3.1 6.1 3.1 4.2 2.3 1.8                        Writing myfile.txt                  为了生成数组，我们首先将数据转化成一个列表组成的列表，再将这个列表转换为数组：           data = []  with open('myfile.txt') as f:     # 每次读一行     for line in f:         fileds = line.split()         row_data = [float(x) for x in fileds]         data.append(row_data)  data = np.array(data)                    data                         array([[ 2.1,  2.3,  3.2,  1.3,  3.1],        [ 6.1,  3.1,  4.2,  2.3,  1.8]])                   不过，更简便的是使用 loadtxt 方法：           data = np.loadtxt('myfile.txt') data                         array([[ 2.1,  2.3,  3.2,  1.3,  3.1],        [ 6.1,  3.1,  4.2,  2.3,  1.8]])                   逗号分隔文件           %%writefile myfile.txt 2.1, 2.3, 3.2, 1.3, 3.1 6.1, 3.1, 4.2, 2.3, 1.8                        Overwriting myfile.txt                  对于逗号分隔的文件（通常为.csv格式）,我们可以稍微修改之前繁琐的过程，将 split 的参数变成 ','即可。   不过，loadtxt 函数也可以读这样的文件，只需要制定分割符的参数即可：           data = np.loadtxt('myfile.txt', delimiter=',') data                         array([[ 2.1,  2.3,  3.2,  1.3,  3.1],        [ 6.1,  3.1,  4.2,  2.3,  1.8]])                   loadtxt 函数   loadtxt(fname, dtype=&lt;type 'float'&gt;,          comments='#', delimiter=None,          converters=None, skiprows=0,          usecols=None, unpack=False, ndmin=0)   loadtxt 有很多可选参数，其中 delimiter 就是刚才用到的分隔符参数。   skiprows 参数表示忽略开头的行数，可以用来读写含有标题的文本           %%writefile myfile.txt X Y Z MAG ANG 2.1 2.3 3.2 1.3 3.1 6.1 3.1 4.2 2.3 1.8                        Overwriting myfile.txt                          np.loadtxt('myfile.txt', skiprows=1)                         array([[ 2.1,  2.3,  3.2,  1.3,  3.1],        [ 6.1,  3.1,  4.2,  2.3,  1.8]])                   此外，有一个功能更为全面的 genfromtxt 函数，能处理更多的情况，但相应的速度和效率会慢一些。   genfromtxt(fname, dtype=&lt;type 'float'&gt;, comments='#', delimiter=None,             skiprows=0, skip_header=0, skip_footer=0, converters=None,             missing='', missing_values=None, filling_values=None, usecols=None,             names=None, excludelist=None, deletechars=None, replace_space='_',             autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None,             usemask=False, loose=True, invalid_raise=True)   loadtxt 的更多特性   对于这样一个文件：           %%writefile myfile.txt  -- BEGINNING OF THE FILE % Day, Month, Year, Skip, Power 01, 01, 2000, x876, 13 % wow! % we don't want have Jan 03rd 04, 01, 2000, xfed, 55                        Overwriting myfile.txt                          data = np.loadtxt('myfile.txt',                    skiprows=1,         #忽略第一行                   dtype=np.int,      #数组类型                   delimiter=',',     #逗号分割                   usecols=(0,1,2,4), #指定使用哪几列数据                   comments='%'       #百分号为注释符                  ) data                         array([[   1,    1, 2000,   13],        [   4,    1, 2000,   55]])                   loadtxt 自定义转换方法           %%writefile myfile.txt 2010-01-01 2.3 3.2 2011-01-01 6.1 3.1                        Overwriting myfile.txt                  假设我们的文本包含日期，我们可以使用 datetime 在 loadtxt 中处理：           import datetime  def date_converter(s):     return datetime.datetime.strptime(s, \"%Y-%m-%d\")  data = np.loadtxt('myfile.txt',                   dtype=np.object, #数据类型为对象                   converters={0:date_converter,  #第一列使用自定义转换方法                               1:float,           #第二第三使用浮点数转换                               2:float})  data                         array([[datetime.datetime(2010, 1, 1, 0, 0), 2.3, 3.2],        [datetime.datetime(2011, 1, 1, 0, 0), 6.1, 3.1]], dtype=object)                   移除 myfile.txt：           import os os.remove('myfile.txt')            读写各种格式的文件   如下表所示：                  文件格式       使用的包       函数                       txt       numpy       loadtxt, genfromtxt, fromfile, savetxt, tofile                 csv       csv       reader, writer                 Matlab       scipy.io       loadmat, savemat                 hdf       pytables, h5py                         NetCDF       netCDF4, scipy.io.netcdf       netCDF4.Dataset, scipy.io.netcdf.netcdf_file                 文件格式       使用的包       备注                 wav       scipy.io.wavfile       音频文件                 jpeg,png,…       PIL, scipy.misc.pilutil       图像文件                 fits       pyfits       天文图像           此外， pandas ——一个用来处理时间序列的包中包含处理各种文件的方法，具体可参见它的文档：   http://pandas.pydata.org/pandas-docs/stable/io.html   将数组写入文件   savetxt 可以将数组写入文件，默认使用科学计数法的形式保存：           data = np.array([[1,2],                   [3,4]])  np.savetxt('out.txt', data)                    with open('out.txt') as f:     for line in f:         print line,                        1.000000000000000000e+00 2.000000000000000000e+00 3.000000000000000000e+00 4.000000000000000000e+00                  也可以使用类似C语言中 printf 的方式指定输出的格式：           data = np.array([[1,2],                   [3,4]])  np.savetxt('out.txt', data, fmt=\"%d\") #保存为整数                    with open('out.txt') as f:     for line in f:         print line,                        1 2 3 4                  逗号分隔的输出：           data = np.array([[1,2],                   [3,4]])  np.savetxt('out.txt', data, fmt=\"%.2f\", delimiter=',') #保存为2位小数的浮点数，用逗号分隔                    with open('out.txt') as f:     for line in f:         print line,                        1.00,2.00 3.00,4.00                  复数值默认会加上括号：           data = np.array([[1+1j,2],                   [3,4]])  np.savetxt('out.txt', data, fmt=\"%.2f\", delimiter=',') #保存为2位小数的浮点数，用逗号分隔                    with open('out.txt') as f:     for line in f:         print line,                         (1.00+1.00j), (2.00+0.00j)  (3.00+0.00j), (4.00+0.00j)                  更多参数：   savetxt(fname,          X,          fmt='%.18e',          delimiter=' ',          newline='\\n',          header='',          footer='',          comments='# ')   移除 out.txt：           import os os.remove('out.txt')            Numpy 二进制格式   数组可以储存成二进制格式，单个的数组保存为 .npy 格式，多个数组保存为多个.npy文件组成的 .npz 格式，每个 .npy 文件包含一个数组。   与文本格式不同，二进制格式保存了数组的 shape, dtype 信息，以便完全重构出保存的数组。   保存的方法：      save(file, arr) 保存单个数组，.npy 格式   savez(file, *args, **kwds) 保存多个数组，无压缩的 .npz 格式   savez_compressed(file, *args, **kwds) 保存多个数组，有压缩的 .npz 格式   读取的方法：      load(file, mmap_mode=None) 对于 .npy，返回保存的数组，对于 .npz，返回一个名称-数组对组成的字典。   单个数组的读写           a = np.array([[1.0,2.0], [3.0,4.0]])  fname = 'afile.npy' np.save(fname, a)                    aa = np.load(fname) aa                         array([[ 1.,  2.],        [ 3.,  4.]])                   删除生成的文件：           import os os.remove('afile.npy')            二进制与文本大小比较           a = np.arange(10000.)            保存为文本：           np.savetxt('a.txt', a)            查看大小：           import os os.stat('a.txt').st_size                         260000L                   保存为二进制：           np.save('a.npy', a)            查看大小：           os.stat('a.npy').st_size                         80080L                   删除生成的文件：           os.remove('a.npy') os.remove('a.txt')            可以看到，二进制文件大约是文本文件的三分之一。   保存多个数组           a = np.array([[1.0,2.0],                [3.0,4.0]]) b = np.arange(1000)            保存多个数组：           np.savez('data.npz', a=a, b=b)            查看里面包含的文件：           !unzip -l data.npz                        Archive:  data.npz   Length      Date    Time    Name ---------  ---------- -----   ----       112  2015/08/10 00:46   a.npy      4080  2015/08/10 00:46   b.npy ---------                     -------      4192                     2 files                  载入数据：           data = np.load('data.npz')            载入后可以像字典一样进行操作：           data.keys()                         ['a', 'b']                           data['a']                         array([[ 1.,  2.],        [ 3.,  4.]])                           data['b'].shape                         (1000L,)                   删除文件：           # 要先删除 data，否则删除时会报错 del data  os.remove('data.npz')            压缩文件   当数据比较整齐时：           a = np.arange(20000.)            无压缩大小：           np.savez('a.npz', a=a) os.stat('a.npz').st_size                         160188L                   有压缩大小：           np.savez_compressed('a2.npz', a=a) os.stat('a2.npz').st_size                         26885L                   大约有 6x 的压缩效果。   当数据比较混乱时：           a = np.random.rand(20000.)            无压缩大小：           np.savez('a.npz', a=a) os.stat('a.npz').st_size                         160188L                   有压缩大小：           np.savez_compressed('a2.npz', a=a) os.stat('a2.npz').st_size                         151105L                   只有大约 1.06x 的压缩效果。           os.remove('a.npz') os.remove('a2.npz')           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/19.html",
        "teaser":null},{
        "title": "04-20 结构化数组",
        
        "excerpt":
            "结构化数组   假设我们要保存这样的数据：                  name       age       wgt                               0       dan       1       23.1                 1       ann       0       25.1                 2       sam       2       8.3           希望定义一个一维数组，每个元素有三个属性 name, age, wgt，此时我们需要使用结构化数组。           import numpy as np            定义数组 a：                  0       1       2       3                       1.0       2.0       3.0       4.0                   a = np.array([1.0,2.0,3.0,4.0], np.float32)            使用 view 方法，将 a 对应的内存按照复数来解释：           a.view(np.complex64)                         array([ 1.+2.j,  3.+4.j], dtype=complex64)                                  0       1       2       3                       1.0       2.0       3.0       4.0                 real       imag       real       imag           事实上，我们可以把复数看成一个结构体，第一部分是实部，第二部分是虚部，这样这个数组便可以看成是一个结构化数组。   换句话说，我们只需要换种方式解释这段内存，便可以得到结构化数组的效果！                  0       1       2       3                       1.0       2.0       3.0       4.0                 mass       vol       mass       vol           例如，我们可以将第一个浮点数解释为质量，第二个浮点数解释为速度，则这段内存还可以看成是包含两个域（质量和速度）的结构体。           my_dtype = np.dtype([('mass', 'float32'), ('vol', 'float32')])                    a.view(my_dtype)                         array([(1.0, 2.0), (3.0, 4.0)],        dtype=[('mass', '&lt;f4'), ('vol', '&lt;f4')])                   这里，我们使用 dtype 创造了自定义的结构类型，然后用自定义的结构来解释数组 a 所占的内存。   这里 f4 表示四字节浮点数，&lt; 表示小字节序。   利用这个自定义的结构类型，我们可以这样初始化结构化数组：           my_data = np.array([(1,1), (1,2), (2,1), (1,3)], my_dtype)  print my_data                        [(1.0, 1.0) (1.0, 2.0) (2.0, 1.0) (1.0, 3.0)]                  第一个元素：           my_data[0]                         (1.0, 1.0)                   得到第一个元素的速度信息，可以使用域的名称来索引：           my_data[0]['vol']                         1.0                   得到所有的质量信息：           my_data['mass']                         array([ 1.,  1.,  2.,  1.], dtype=float32)                   自定义排序规则，先按速度，再按质量：           my_data.sort(order=('vol', 'mass'))  print my_data                        [(1.0, 1.0) (2.0, 1.0) (1.0, 2.0) (1.0, 3.0)]                  回到最初的例子，定义一个人的结构类型：           person_dtype = np.dtype([('name', 'S10'), ('age', 'int'), ('weight', 'float')])            查看类型所占字节数：           person_dtype.itemsize                         22                   产生一个 3 x 4 共12人的空结构体数组：           people = np.empty((3,4), person_dtype)            分别赋值：           people['name'] = [['Brad', 'Jane', 'John', 'Fred'],                   ['Henry', 'George', 'Brain', 'Amy'],                   ['Ron', 'Susan', 'Jennife', 'Jill']]                    people['age'] = [[33, 25, 47, 54],                  [29, 61, 32, 27],                  [19, 33, 18, 54]]                    people['weight'] = [[135., 105., 255., 140.],                     [154., 202., 137., 187.],                     [188., 135., 88., 145.]]                    print people                        [[('Brad', 33, 135.0) ('Jane', 25, 105.0) ('John', 47, 255.0)   ('Fred', 54, 140.0)]  [('Henry', 29, 154.0) ('George', 61, 202.0) ('Brain', 32, 137.0)   ('Amy', 27, 187.0)]  [('Ron', 19, 188.0) ('Susan', 33, 135.0) ('Jennife', 18, 88.0)   ('Jill', 54, 145.0)]]                          people[-1,-1]                         ('Jill', 54, 145.0)                   从文本中读取结构化数组   我们有这样一个文件：           %%writefile people.txt name age weight amy 11 38.2 john 10 40.3 bill 12 21.2                        Writing people.txt                  利用 loadtxt 指定数据类型，从这个文件中读取结构化数组：           person_dtype = np.dtype([('name', 'S10'), ('age', 'int'), ('weight', 'float')])  people = np.loadtxt('people.txt',                      skiprows=1,                     dtype=person_dtype)  people                         array([('amy', 11, 38.2), ('john', 10, 40.3), ('bill', 12, 21.2)],        dtype=[('name', 'S10'), ('age', '&lt;i4'), ('weight', '&lt;f8')])                   查看 name 域：           people['name']                         array(['amy', 'john', 'bill'],        dtype='|S10')                   删除文件：           import os os.remove('people.txt')            对于下面的文件：           %%writefile wood.csv item,material,number 100,oak,33 110,maple,14 120,oak,7 145,birch,3                        Writing wood.csv                  定义转换函数处理材料属性，使之对应一个整数：           tree_to_int = dict(oak = 1,                    maple=2,                    birch=3)  def convert(s):     return tree_to_int.get(s, 0)            使用 genfromtxt 载入数据，可以自动从第一行读入属性名称：           data = np.genfromtxt('wood.csv',                      delimiter=',', # 逗号分隔                      dtype=np.int, # 数据类型                      names=True,   # 从第一行读入域名                      converters={1:convert}                     )                    data                         array([(100, 1, 33), (110, 2, 14), (120, 1, 7), (145, 3, 3)],        dtype=[('item', '&lt;i4'), ('material', '&lt;i4'), ('number', '&lt;i4')])                   查看域：           data['material']                         array([1, 2, 1, 3])                   删除文件：           os.remove('wood.csv')            嵌套类型   有时候，结构数组中的域可能包含嵌套的结构，例如，在我们希望在二维平面上纪录一个质点的位置和质量：       position   mass   xy &lt;/table&gt;  那么它的类型可以这样嵌套定义：                                  particle_dtype = np.dtype([('position', [('x', 'float'),                                           ('y', 'float')]),                            ('mass', 'float')                           ])                                                假设数据文件如下：                                  %%writefile data.txt 2.0 3.0 42.0 2.1 4.3 32.5 1.2 4.6 32.3 4.5 -6.4 23.3                                                                                    Overwriting data.txt                                                                  读取数据：                                  data = np.loadtxt('data.txt', dtype=particle_dtype)                                                                                data                                                                                     array([((2.0, 3.0), 42.0), ((2.1, 4.3), 32.5), ((1.2, 4.6), 32.3),        ((4.5, -6.4), 23.3)],        dtype=[('position', [('x', '&lt;f8'), ('y', '&lt;f8')]), ('mass', '&lt;f8')])                                                                   查看位置的 `x` 轴：                                  data['position']['x']                                                                                     array([ 2. ,  2.1,  1.2,  4.5])                                                                   删除生成的文件：                                  os.remove('data.txt')                                                ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/20.html",
        "teaser":null},{
        "title": "04-21 记录数组",
        
        "excerpt":
            "记录数组   记录数组（record array）与结构数组类似：           import numpy as np            质点类型：           partical_dtype = np.dtype([('mass', 'float'),                             ('velocity', 'float')])            生成记录数组要使用 numpy.rec 里的 fromrecords 方法：           from numpy import rec  particals_rec = rec.fromrecords([(1,1), (1,2), (2,1), (1,3)],                                  dtype = partical_dtype)                    particals_rec                         rec.array([(1.0, 1.0), (1.0, 2.0), (2.0, 1.0), (1.0, 3.0)],        dtype=[('mass', '&lt;f8'), ('velocity', '&lt;f8')])                   在记录数组中，域可以通过属性来获得：           particals_rec.mass                         array([ 1.,  1.,  2.,  1.])                   也可以通过域来查询：           particals_rec['mass']                         array([ 1.,  1.,  2.,  1.])                   不过，记录数组的运行效率要比结构化数组要慢一些。   也可以通过将一个结构化数组看成记录数组：           particals = np.array([(1,1), (1,2), (2,1), (1,3)],                      dtype = partical_dtype)            使用 view 方法看成 recarray ：           particals_rec = particals.view(np.recarray)                    particals_rec.mass                         array([ 1.,  1.,  2.,  1.])                           particals_rec.velocity                         array([ 1.,  2.,  1.,  3.])                   对于自定义的类型，可以通过它的 names 属性查看它有哪些域：           particals.dtype.names                         ('mass', 'velocity')                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/21.html",
        "teaser":null},{
        "title": "04-22 内存映射",
        
        "excerpt":
            "内存映射   Numpy 有对内存映射的支持。   内存映射也是一种处理文件的方法，主要的函数有：      memmap   frombuffer   ndarray constructor   内存映射文件与虚拟内存有些类似，通过内存映射文件可以保留一个地址空间的区域，同时将物理存储器提交给此区域，内存文件映射的物理存储器来自一个已经存在于磁盘上的文件，而且在对该文件进行操作之前必须首先对文件进行映射。   使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行I/O操作，使得内存映射文件在处理大数据量的文件时能起到相当重要的作用。   memmap   memmap(filename,        dtype=uint8,        mode='r+'        offset=0        shape=None        order=0)   mode 表示文件被打开的类型：      r 只读   c 复制+写，但是不改变源文件   r+ 读写，使用 flush 方法会将更改的内容写入文件   w+ 写，如果存在则将数据覆盖   offset 表示从第几个位置开始。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/22.html",
        "teaser":null},{
        "title": "04-23 从 Matlab 到 Numpy",
        
        "excerpt":
            "从 Matlab 到 Numpy   Numpy  和 Matlab 比较   Numpy 和 Matlab 有很多相似的地方，但 Numpy 并非 Matlab 的克隆，它们之间存在很多差异，例如：                  MATLAB®       Numpy                       基本类型为双精度浮点数组，以二维矩阵为主       基本类型为 ndarray，有特殊的 matrix 类                 1-based 索引       0-based 索引                 脚本主要用于线性代数计算       可以使用其他的 Python 特性                 采用值传递的方式进行计算 切片返回复制       采用引用传递的方式进行计算 切片返回引用                 文件名必须和函数名相同       函数可以在任何地方任何文件中定义                 收费       免费                 2D，3D图像支持       依赖第三方库如 matplotlib 等                 完全的编译环境       依赖于 Python 提供的编译环境           array 还是 matrix？   Numpy 中不仅提供了 array 这个基本类型，还提供了支持矩阵操作的类 matrix，但是一般推荐使用 array：      很多 numpy 函数返回的是 array，不是 matrix   在 array 中，逐元素操作和矩阵操作有着明显的不同   向量可以不被视为矩阵   具体说来：      *， dot(), multiply()            array：* -逐元素乘法，dot() -矩阵乘法       matrix：* -矩阵乘法，multiply() -逐元素乘法           处理向量            array：形状为 1xN, Nx1, N 的向量的意义是不同的，类似于 A[:,1] 的操作返回的是一维数组，形状为 N，一维数组的转置仍是自己本身       matrix：形状为 1xN, Nx1，A[:,1] 返回的是二维 Nx1 矩阵           高维数组            array：支持大于2的维度       matrix：维度只能为2           属性            array：.T 表示转置       matrix：.H 表示复共轭转置，.I 表示逆，.A 表示转化为 array 类型           构造函数            array：array 函数接受一个（嵌套）序列作为参数——array([[1,2,3],[4,5,6]])       matrix：matrix 函数额外支持字符串参数——matrix(\"[1 2 3; 4 5 6]\")           其优缺点各自如下：      array            [GOOD] 一维数组既可以看成列向量，也可以看成行向量。v 在 dot(A,v) 被看成列向量，在 dot(v,A) 中被看成行向量，这样省去了转置的麻烦       [BAD!] 矩阵乘法需要使用 dot() 函数，如： dot(dot(A,B),C) vs A*B*C       [GOOD] 逐元素乘法很简单： A*B       [GOOD] 作为基本类型，是很多基于 numpy 的第三方库函数的返回类型       [GOOD] 所有的操作 *,/,+,**,... 都是逐元素的       [GOOD] 可以处理任意维度的数据       [GOOD] 张量运算           matrix            [GOOD] 类似与 MATLAB 的操作       [BAD!] 最高维度为2       [BAD!] 最低维度也为2       [BAD!] 很多函数返回的是 array，即使传入的参数是 matrix       [GOOD] A*B 是矩阵乘法       [BAD!] 逐元素乘法需要调用 multiply 函数       [BAD!] / 是逐元素操作           当然在实际使用中，二者的使用取决于具体情况。   二者可以互相转化：      asarray ：返回数组   asmatrix（或者mat） ：返回矩阵   asanyarray ：返回数组或者数组的子类，注意到矩阵是数组的一个子类，所以输入是矩阵的时候返回的也是矩阵   类 Matlab 函数   有很多类似的函数：      ones, zeros, empty, eye, rand, repmat   通常这些函数的返回值是 array，不过 numpy 提供了一个 matlib 的子模块，子模块中的这些函数返回值为 matrix：           import numpy import numpy.matlib                    a = numpy.ones(7)  print a.shape print type(a)                        (7L,) &lt;type 'numpy.ndarray'&gt;                          a = numpy.matlib.ones(7)  print a.shape print type(a)                        (1L, 7L) &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;                  mat 函数将一个数组转化为矩阵：           a = numpy.array([1,2,3])  b = numpy.mat(a)  print type(b)                        &lt;class 'numpy.matrixlib.defmatrix.matrix'&gt;                  有些函数被放到子模块中了，例如调用 rand() 函数需要使用 numpy.random.rand() （或者从 matlib 模块中生成矩阵）：           a = numpy.random.rand(10) print a                        [ 0.66007267  0.34794294  0.5040946   0.65044648  0.74763248  0.42486999   0.90922612  0.69071747  0.33541076  0.08570178]                  等效操作   假定我们已经这样导入了 Numpy：           from numpy import * import scipy.linalg            以下 linalg 表示的是 numpy.linalg，与 scipy.linalg 不同。   注意：MATLAB 与 Numpy 下标之间有这样几处不同：     1-base vs 0-base   () vs []   MATLAB：beg(:step):end，包含结束值 end   Numpy：beg:end(:step)，不包含结束值 end                  MATLAB       Numpy       注释                       help func       info(func)， help(func)， func?(IPython)       查看函数帮助                 which func               查看函数在什么地方定义                 type func       source(func)， func?？(IPython)       查看函数源代码                 a &amp;&amp; b       a and b       逻辑 AND                 1*i, 1*j, 1i, 1j       1j       复数                 eps       spacing(1)       1 与最近浮点数的距离                 ndims(a)       ndim(a), a.ndim       a 的维数                 numel(a)       size(a), a.size       a 的元素个数                 size(a)       shape(a), a.shape       a 的形状                 size(a,n)       a.shape[n-1]       第 n 维的大小                 a(2,5)       a[1,4]       第 2 行第 5 列元素                 a(2,:)       a[1], a[1,:]       第 2 行                 a(1:5,:)       a[0:5]       第 1 至 5 行                 a(end-4:end,:)       a[-5:]       后 5 行                 a(1:3,5:9)       a[0:3][:,4:9]       特定行列（1~3 行，5~9 列）                 a([2,4,5],[1,3])       a[ix_([1,3,4],[0,2])]       特定行列（2,4,5 行的 1,3 列）                 a(3:2:21,:)       a[2:21:2,:]       特定行列（3,5,…,21 行）                 a(1:2:end,:)       a[ ::2,:]       奇数行                 a([1:end 1],:)       a[r_[:len(a),0]]       将第一行添加到末尾                 a.'       a.T       转置                 a ./ b       a/b       逐元素除法                 (a&gt;0.5)       (a&gt;0.5)       各个元素是否大于 0.5                 find(a&gt;0.5)       nonzero(a&gt;0.5)       大于 0.5 的位置                 a(a&lt;0.5)=0       a[a&lt;0.5]=0       小于 0.5 的设为 0                 a(:) = 3       a[:] = 3       所有元素设为 3                 y=x       y=x.copy()       将 y 设为 x                 y=x(2,:)       y=x[1,:].copy()       注意值传递和引用传递的区别                 y=x(:)       y=x.flatten(1)       将矩阵变为一个向量，这里 1 表示沿着列进行转化                 max(max(a))       a.max()       最大值                 max(a)       a.max(0)       每一列的最大值                 max(a,[],2)       a.max(1)       每一行的最大值                 max(a,b)       maximum(a,b)       逐元素比较，取较大的值                 a &amp; b       logical_and(a, b)       逻辑 AND                 bitand(a, b)       a &amp; b       逐比特 AND                 inv(a)       linalg.inv(a)       a 的逆                 pinv(a)       linalg.inv(a)       伪逆                 rank(a)       linalg.matrix_rank(a)       秩                 a\\b       linalg.solve(a,b)(如果a是方阵),linalg.lstsq(a,b)       解 a x = b                 b/a       求解 a.T x.T = b.T       解 x a = b                 [U,S,V]=svd(a)       U, S, Vh = linalg.svd(a), V = Vh.T       奇异值分解                 chol(a)       linalg.cholesky(a).T       Cholesky 分解                 [V,D]=eig(a)       D,V = linalg.eig(a)       特征值分解                 [V,D]=eig(a,b)       V,D = scipy.linalg.eig(a,b)                         [V,D]=eigs(a,k)               前 k 大特征值对应的特征向量                 |                                 |                                 |                                 |                                          MATLAB       numpy.array       numpy.matrix       注释                       [1,2,3;4,5,6]       array([[1.,2.,3.],[4.,5.,6.]])       mat([[1.,2.,3.],[4.,5.,6.]]), mat('1,2,3;4,5,6')       2x3 矩阵                 [a b;c d]       vstack([hstack([a,b]), hsatck([c,d])]])       bmat('a b;c d')       分块矩阵构造                 a(end)       a[-1]       a[:,-1][0,0]       最后一个元素                 a'       a.conj().T       a.H       复共轭转置                 a * b       dot(a,b)       a * b       矩阵乘法                 a .* b       a * b       multiply(a,b)       逐元素乘法                 a.^3       a**3       power(a,3)       逐元素立方                 a(:,find(v&gt;0.5))       a[:,nonzero(v&gt;0.5)[0]]       a[:,nonzero(v.A&gt;0.5)[0]]       找出行向量 v&gt;0.5 对应的 a 中的列                 a(:,find(v&gt;0.5))       a[:,v.T&gt;0.5]       a[:,v.T&gt;0.5)]       找出列向量 v&gt;0.5 对应的 a 中的列                 a .* (a&gt;0.5)       a * (a&gt;0.5)       mat(a.A * (a&gt;0.5).A)       将所有小于 0.5 的元素设为 0                 1:10       arange(1.,11.), r_[1.:11.], r_[1:10:10j]       mat(arange(1.,11.)), r_[1.:11., 'r']       这里 1. 是为了将其转化为浮点数组                 0:9       arange(10.), r_[:10.], r_[:9:10j]       mat(arange(10.)), r_[:10., 'r']                         [1:10]'       arange(1.,11.)[:,newaxis]       r_[1.:11.,'c']       列向量                 zeros, ones, eye, diag, linspace       zeros, ones, eye, diag, linspace       mat(...)                         rand(3,4)       random.rand(3,4)       mat(...)       0~1 随机数                 [x,y]=meshgrid(0:8,0:5)       mgrid[0:9., 0:6.], meshgrid(r_[0:9.],r_[0:6.])       mat(...)       网格                         ogrid[0:9.,0:6.], ix_(r_[0:9.],r_[0:6.])       mat()       建议在 Numpy 中使用                 [x,y]=meshgrid([1,2,4],[2,4,5])       meshgrid([1,2,4],[2,4,5])       mat(...)                                 ix_([1,2,4],[2,4,5])       mat(...)                         repmat(a, m, n)       tile(a, (m,n))       mat(...)       产生 m x n 个 a                 [a b]       c_[a,b]       concatenate((a,b),1)       列对齐连接                 [a; b]       r_[a,b]       concatenate((a,b))       行对齐连接                 norm(v)       sqrt(dot(v,v)), linalg.norm(v)       sqrt(dot(v.A,v.A)), linalg.norm(v)       模                 [Q,R,P]=qr(a,0)       Q,R = scipy.linalg.qr(a)       mat(...)       QR 分解                 [L,U,P]=lu(a)       L,U = Sci.linalg.lu(a)       mat(...)       LU 分解                 fft(a)       fft(a)       mat(...)       FFT                 ifft(a)       ifft(a)       mat(...)       IFFT                 sort(a)       sort(a),a.sort       mat(...)       排序           参考：http://wiki.scipy.org/NumPy_for_Matlab_Users#whichNotes  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/23.html",
        "teaser":null},{
        "title": "第4章 Numpy",
        
        "excerpt":
            "第4章 Numpy   04-1-Numpy 简介   04-2-Matplotlib基础   04-3-Numpy 数组及其索引   04-4-数组类型   04-5-数组方法   04-6-数组排序   04-7-数组形状   04-8-对角线   04-9-数组与字符串的转换   04-10-数组属性方法总结   04-11-生成数组的函数   04-12-矩阵   04-13-一般函数   04-14-向量化函数   04-15-二元运算   04-16-ufunc 对象   04-17-choose 函数   04-18-数组广播机制   04-19-数组读写   04-20-结构化数组   04-21-记录数组   04-22-内存映射   04-23-从 Matlab 到 Numpy  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/04/features.html",
        "teaser":null},{
        "title": "05-01 十分钟上手 Pandas",
        
        "excerpt":
            "十分钟上手 Pandas pandas 是一个 Python Data Analysis Library。 安装请参考官网的教程，如果安装了 Anaconda，则不需要安装 pandas 库。 %matplotlib inline import pandas as pd import numpy as np import matplotlib.pyplot as plt 产生 Pandas 对象 pandas 中有三种基本结构： Series 1D labeled homogeneously-typed array DataFrame General 2D labeled, size-mutable tabular structure with potentially heterogeneously-typed columns Panel General 3D labeled, also size-mutable array Series 一维 Series 可以用一维列表初始化： s = pd.Series([1,3,5,np.nan,6,8]) print s 0 1 1 3 2 5 3 NaN 4 6 5 8 dtype: float64 默认情况下，Series 的下标都是数字（可以使用额外参数指定），类型是统一的。 DataFrame DataFrame 则是个二维结构，这里首先构造一组时间序列，作为我们第一维的下标： dates = pd.date_range('20130101', periods=6) print dates DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D') 然后创建一个 DataFrame 结构： df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD')) df A B C D 2013-01-01 -0.605936 -0.861658 -1.001924 1.528584 2013-01-02 -0.165408 0.388338 1.187187 1.819818 2013-01-03 0.065255 -1.608074 -1.282331 -0.286067 2013-01-04 1.289305 0.497115 -0.225351 0.040239 2013-01-05 0.038232 0.875057 -0.092526 0.934432 2013-01-06 -2.163453 -0.010279 1.699886 1.291653 默认情况下，如果不指定 index 参数和 columns，那么他们的值将用从 0 开始的数字替代。 除了向 DataFrame 中传入二维数组，我们也可以使用字典传入数据： df2 = pd.DataFrame({'A' : 1., 'B' : pd.Timestamp('20130102'), 'C' : pd.Series(1,index=list(range(4)),dtype='float32'), 'D' : np.array([3] * 4,dtype='int32'), 'E' : pd.Categorical([\"test\",\"train\",\"test\",\"train\"]), 'F' : 'foo' }) df2 A B C D E F 0 1 2013-01-02 1 3 test foo 1 1 2013-01-02 1 3 train foo 2 1 2013-01-02 1 3 test foo 3 1 2013-01-02 1 3 train foo 字典的每个 key 代表一列，其 value 可以是各种能够转化为 Series 的对象。 与 Series 要求所有的类型都一致不同，DataFrame 值要求每一列数据的格式相同： df2.dtypes A float64 B datetime64[ns] C float32 D int32 E category F object dtype: object 查看数据 头尾数据 head 和 tail 方法可以分别查看最前面几行和最后面几行的数据（默认为 5）： df.head() A B C D 2013-01-01 -0.605936 -0.861658 -1.001924 1.528584 2013-01-02 -0.165408 0.388338 1.187187 1.819818 2013-01-03 0.065255 -1.608074 -1.282331 -0.286067 2013-01-04 1.289305 0.497115 -0.225351 0.040239 2013-01-05 0.038232 0.875057 -0.092526 0.934432 最后 3 行： df.tail(3) A B C D 2013-01-04 1.289305 0.497115 -0.225351 0.040239 2013-01-05 0.038232 0.875057 -0.092526 0.934432 2013-01-06 -2.163453 -0.010279 1.699886 1.291653 下标，列标，数据 下标使用 index 属性查看： df.index DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D') 列标使用 columns 属性查看： df.columns Index([u'A', u'B', u'C', u'D'], dtype='object') 数据值使用 values 查看： df.values array([[-0.60593585, -0.86165752, -1.00192387, 1.52858443], [-0.16540784, 0.38833783, 1.18718697, 1.81981793], [ 0.06525454, -1.60807414, -1.2823306 , -0.28606716], [ 1.28930486, 0.49711531, -0.22535143, 0.04023897], [ 0.03823179, 0.87505664, -0.0925258 , 0.93443212], [-2.16345271, -0.01027865, 1.69988608, 1.29165337]]) 统计数据 查看简单的统计数据： df.describe() A B C D count 6.000000 6.000000 6.000000 6.000000 mean -0.257001 -0.119917 0.047490 0.888110 std 1.126657 0.938705 1.182629 0.841529 min -2.163453 -1.608074 -1.282331 -0.286067 25% -0.495804 -0.648813 -0.807781 0.263787 50% -0.063588 0.189030 -0.158939 1.113043 75% 0.058499 0.469921 0.867259 1.469352 max 1.289305 0.875057 1.699886 1.819818 转置 df.T 2013-01-01 00:00:00 2013-01-02 00:00:00 2013-01-03 00:00:00 2013-01-04 00:00:00 2013-01-05 00:00:00 2013-01-06 00:00:00 A -0.605936 -0.165408 0.065255 1.289305 0.038232 -2.163453 B -0.861658 0.388338 -1.608074 0.497115 0.875057 -0.010279 C -1.001924 1.187187 -1.282331 -0.225351 -0.092526 1.699886 D 1.528584 1.819818 -0.286067 0.040239 0.934432 1.291653 排序 sort_index(axis=0, ascending=True) 方法按照下标大小进行排序，axis=0 表示按第 0 维进行排序。 df.sort_index(ascending=False) A B C D 2013-01-06 -2.163453 -0.010279 1.699886 1.291653 2013-01-05 0.038232 0.875057 -0.092526 0.934432 2013-01-04 1.289305 0.497115 -0.225351 0.040239 2013-01-03 0.065255 -1.608074 -1.282331 -0.286067 2013-01-02 -0.165408 0.388338 1.187187 1.819818 2013-01-01 -0.605936 -0.861658 -1.001924 1.528584 df.sort_index(axis=1, ascending=False) D C B A 2013-01-01 1.528584 -1.001924 -0.861658 -0.605936 2013-01-02 1.819818 1.187187 0.388338 -0.165408 2013-01-03 -0.286067 -1.282331 -1.608074 0.065255 2013-01-04 0.040239 -0.225351 0.497115 1.289305 2013-01-05 0.934432 -0.092526 0.875057 0.038232 2013-01-06 1.291653 1.699886 -0.010279 -2.163453 sort_values(by, axis=0, ascending=True) 方法按照 by 的值的大小进行排序，例如按照 B 列的大小： df.sort_values(by=\"B\") A B C D 2013-01-03 0.065255 -1.608074 -1.282331 -0.286067 2013-01-01 -0.605936 -0.861658 -1.001924 1.528584 2013-01-06 -2.163453 -0.010279 1.699886 1.291653 2013-01-02 -0.165408 0.388338 1.187187 1.819818 2013-01-04 1.289305 0.497115 -0.225351 0.040239 2013-01-05 0.038232 0.875057 -0.092526 0.934432 索引 虽然 DataFrame 支持 Python/Numpy 的索引语法，但是推荐使用 .at, .iat, .loc, .iloc 和 .ix 方法进行索引。 读取数据 选择单列数据： df[\"A\"] 2013-01-01 -0.605936 2013-01-02 -0.165408 2013-01-03 0.065255 2013-01-04 1.289305 2013-01-05 0.038232 2013-01-06 -2.163453 Freq: D, Name: A, dtype: float64 也可以用 df.A： df.A 2013-01-01 -0.605936 2013-01-02 -0.165408 2013-01-03 0.065255 2013-01-04 1.289305 2013-01-05 0.038232 2013-01-06 -2.163453 Freq: D, Name: A, dtype: float64 使用切片读取多行： df[0:3] A B C D 2013-01-01 -0.605936 -0.861658 -1.001924 1.528584 2013-01-02 -0.165408 0.388338 1.187187 1.819818 2013-01-03 0.065255 -1.608074 -1.282331 -0.286067 index 名字也可以进行切片： df[\"20130101\":\"20130103\"] A B C D 2013-01-01 -0.605936 -0.861658 -1.001924 1.528584 2013-01-02 -0.165408 0.388338 1.187187 1.819818 2013-01-03 0.065255 -1.608074 -1.282331 -0.286067 使用 label 索引 loc 可以方便的使用 label 进行索引： df.loc[dates[0]] A -0.605936 B -0.861658 C -1.001924 D 1.528584 Name: 2013-01-01 00:00:00, dtype: float64 多列数据： df.loc[:,['A','B']] A B 2013-01-01 -0.605936 -0.861658 2013-01-02 -0.165408 0.388338 2013-01-03 0.065255 -1.608074 2013-01-04 1.289305 0.497115 2013-01-05 0.038232 0.875057 2013-01-06 -2.163453 -0.010279 选择多行多列： df.loc['20130102':'20130104',['A','B']] A B 2013-01-02 -0.165408 0.388338 2013-01-03 0.065255 -1.608074 2013-01-04 1.289305 0.497115 数据降维： df.loc['20130102',['A','B']] A -0.165408 B 0.388338 Name: 2013-01-02 00:00:00, dtype: float64 得到标量值： df.loc[dates[0],'B'] -0.86165751902832299 不过得到标量值可以用 at，速度更快： %timeit -n100 df.loc[dates[0],'B'] %timeit -n100 df.at[dates[0],'B'] print df.at[dates[0],'B'] 100 loops, best of 3: 329 µs per loop 100 loops, best of 3: 31.1 µs per loop -0.861657519028 使用位置索引 iloc 使用位置进行索引： df.iloc[3] A 1.289305 B 0.497115 C -0.225351 D 0.040239 Name: 2013-01-04 00:00:00, dtype: float64 连续切片： df.iloc[3:5,0:2] A B 2013-01-04 1.289305 0.497115 2013-01-05 0.038232 0.875057 索引不连续的部分： df.iloc[[1,2,4],[0,2]] A C 2013-01-02 -0.165408 1.187187 2013-01-03 0.065255 -1.282331 2013-01-05 0.038232 -0.092526 索引整行： df.iloc[1:3,:] A B C D 2013-01-02 -0.165408 0.388338 1.187187 1.819818 2013-01-03 0.065255 -1.608074 -1.282331 -0.286067 整列： df.iloc[:, 1:3] B C 2013-01-01 -0.861658 -1.001924 2013-01-02 0.388338 1.187187 2013-01-03 -1.608074 -1.282331 2013-01-04 0.497115 -0.225351 2013-01-05 0.875057 -0.092526 2013-01-06 -0.010279 1.699886 标量值： df.iloc[1,1] 0.3883378290420279 当然，使用 iat 索引标量值更快： %timeit -n100 df.iloc[1,1] %timeit -n100 df.iat[1,1] df.iat[1,1] 100 loops, best of 3: 236 µs per loop 100 loops, best of 3: 14.5 µs per loop 0.3883378290420279 布尔型索引 所有 A 列大于 0 的行： df[df.A &gt; 0] A B C D 2013-01-03 0.065255 -1.608074 -1.282331 -0.286067 2013-01-04 1.289305 0.497115 -0.225351 0.040239 2013-01-05 0.038232 0.875057 -0.092526 0.934432 只留下所有大于 0 的数值： df[df &gt; 0] A B C D 2013-01-01 NaN NaN NaN 1.528584 2013-01-02 NaN 0.388338 1.187187 1.819818 2013-01-03 0.065255 NaN NaN NaN 2013-01-04 1.289305 0.497115 NaN 0.040239 2013-01-05 0.038232 0.875057 NaN 0.934432 2013-01-06 NaN NaN 1.699886 1.291653 使用 isin 方法做 filter 过滤： df2 = df.copy() df2['E'] = ['one', 'one','two','three','four','three'] df2 A B C D E 2013-01-01 -0.605936 -0.861658 -1.001924 1.528584 one 2013-01-02 -0.165408 0.388338 1.187187 1.819818 one 2013-01-03 0.065255 -1.608074 -1.282331 -0.286067 two 2013-01-04 1.289305 0.497115 -0.225351 0.040239 three 2013-01-05 0.038232 0.875057 -0.092526 0.934432 four 2013-01-06 -2.163453 -0.010279 1.699886 1.291653 three df2[df2['E'].isin(['two','four'])] A B C D E 2013-01-03 0.065255 -1.608074 -1.282331 -0.286067 two 2013-01-05...",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/05/01.html",
        "teaser":null},{
        "title": "05-02 Series",
        
        "excerpt":
            "一维数据结构：Series           import numpy as np import pandas as pd            Series 是一维带标记的数组结构，可以存储任意类型的数据（整数，浮点数，字符串，Python 对象等等）。   作为一维结构，它的索引叫做 index，基本调用方法为   s = pd.Series(data, index=index)   其中，data 可以是以下结构：      字典   ndarray   标量，例如 5   index 是一维坐标轴的索引列表。   从 ndarray 构建   如果 data 是个 ndarray，那么 index 的长度必须跟 data 一致：           s = pd.Series(np.random.randn(5), index=[\"a\", \"b\", \"c\", \"d\", \"e\"])  s                         a   -0.032806 b    0.050207 c   -1.909697 d   -1.127865 e   -0.073793 dtype: float64                   查看 index：           s.index                         Index([u'a', u'b', u'c', u'd', u'e'], dtype='object')                   如果 index 为空，那么 index 会使用 [0, ..., len(data) - 1]：           pd.Series(np.random.randn(5))                         0   -0.376233 1   -0.474349 2    1.660590 3    0.461434 4    0.190965 dtype: float64                   从字典中构造   如果 data 是个 dict，如果不给定 index，那么 index 将使用 dict 的 key 排序之后的结果：           d = {'a' : 0., 'b' : 1., 'c' : 2.}  pd.Series(d)                         a    0 b    1 c    2 dtype: float64                   如果给定了 index，那么将会按照 index 给定的值作为 key 从字典中读取相应的 value，如果 key 不存在，对应的值为 NaN（not a number, Pandas 中的缺失默认值）：           pd.Series(d, index=['b', 'd', 'a'])                         b     1 d   NaN a     0 dtype: float64                   从标量值构造   如果 data 是标量，那么 index 值必须被指定，得到一个值为 data 与 index 等长的 Series：           pd.Series(5., index=['a', 'b', 'c', 'd', 'e'])                         a    5 b    5 c    5 d    5 e    5 dtype: float64                   像 ndarray 一样使用 Series           s                         a   -0.032806 b    0.050207 c   -1.909697 d   -1.127865 e   -0.073793 dtype: float64                   支持数字索引操作：           s[0]                         -0.032806330572971713                   切片：           s[:3]                         a   -0.032806 b    0.050207 c   -1.909697 dtype: float64                   mask 索引：           s[s &gt; s.median()]                         a   -0.032806 b    0.050207 dtype: float64                   花式索引：           s[[4, 3, 1]]                         e   -0.073793 d   -1.127865 b    0.050207 dtype: float64                   支持 numpy 函数：           np.exp(s)                         a    0.967726 b    1.051488 c    0.148125 d    0.323724 e    0.928864 dtype: float64                   像字典一样使用 Series   也可以像字典一样使用 Series：           s[\"a\"]                         -0.032806330572971713                   修改数值：           s[\"e\"] = 12.  s                         a    -0.032806 b     0.050207 c    -1.909697 d    -1.127865 e    12.000000 dtype: float64                   查询 key：           \"e\" in s                         True                           \"f\" in s                         False                   使用 key 索引时，如果不确定 key 在不在里面，可以用 get 方法，如果不存在返回 None 或者指定的默认值：           s.get(\"f\", np.nan)                         nan                   向量化操作   简单的向量操作与 ndarray 的表现一致：           s + s                         a    -0.065613 b     0.100413 c    -3.819395 d    -2.255729 e    24.000000 dtype: float64                           s * 2                         a    -0.065613 b     0.100413 c    -3.819395 d    -2.255729 e    24.000000 dtype: float64                   但 Series 和 ndarray 不同的地方在于，Series 的操作默认是使用 index 的值进行对齐的，而不是相对位置：           s[1:] + s[:-1]                         a         NaN b    0.100413 c   -3.819395 d   -2.255729 e         NaN dtype: float64                   对于上面两个不能完全对齐的 Series，结果的 index 是两者 index 的并集，同时不能对齐的部分当作缺失值处理。   Name 属性   可以在定义时指定 name 属性：           s = pd.Series(np.random.randn(5), name='something') s.name                         'something'                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/05/02.html",
        "teaser":null},{
        "title": "05-03 Dataframe",
        
        "excerpt":
            "二维数据结构：DataFrame           import numpy as np import pandas as pd            DataFrame 是 pandas 中的二维数据结构，可以看成一个 Excel 中的工作表，或者一个 SQL 表，或者一个存储 Series 对象的字典。   DataFrame(data, index, columns) 中的 data 可以接受很多数据类型：      一个存储一维数组，字典，列表或者 Series 的字典   2-D 数组   结构或者记录数组   一个 Series   另一个 DataFrame   index 用于指定行的 label，columns 用于指定列的 label，如果参数不传入，那么会按照传入的内容进行设定。   从 Series 字典中构造   可以使用值为 Series 的字典进行构造：           d = {'one' : pd.Series([1., 2., 3.], index=['a', 'b', 'c']),      'two' : pd.Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])}            如果没有传入 columns 的值，那么 columns 的值默认为字典 key，index 默认为所有 value 中 index 的并集。           df = pd.DataFrame(d)  df                                                 one       two                       a       1       1                 b       2       2                 c       3       3                 d       NaN       4                       如果指定了 index 值，index 为指定的 index 值：           pd.DataFrame(d, index=['d', 'b', 'a'])                                                 one       two                       d       NaN       4                 b       2       2                 a       1       1                       如果指定了 columns 值，会去字典中寻找，找不到的值为 NaN：           pd.DataFrame(d, index=['d', 'b', 'a'], columns=['two', 'three'])                                                 two       three                       d       4       NaN                 b       2       NaN                 a       1       NaN                       查看 index 和 columns：           df.index                         Index([u'a', u'b', u'c', u'd'], dtype='object')                           df.columns                         Index([u'one', u'two'], dtype='object')                   从 ndarray 或者 list 字典中构造   如果字典是 ndarray 或者 list，那么它们的长度要严格保持一致：           d = {'one' : [1., 2., 3., 4.],      'two' : [4., 3., 2., 1.]}            index 默认为 range(n)，其中 n 为数组长度：           pd.DataFrame(d)                                                 one       two                       0       1       4                 1       2       3                 2       3       2                 3       4       1                       如果传入 index 参数，那么它必须与数组等长：           pd.DataFrame(d, index=['a', 'b', 'c', 'd'])                                                 one       two                       a       1       4                 b       2       3                 c       3       2                 d       4       1                       从结构数组中构造   numpy 支持结构数组的构造：           data = np.zeros((2,), dtype=[('A', 'i4'),('B', 'f4'),('C', 'a10')]) data[:] = [(1,2.,'Hello'), (2,3.,\"World\")]  data                         array([(1, 2.0, 'Hello'), (2, 3.0, 'World')],        dtype=[('A', '&lt;i4'), ('B', '&lt;f4'), ('C', 'S10')])                   参数处理的方式与数组字典类似：           pd.DataFrame(data)                                                 A       B       C                       0       1       2       Hello                 1       2       3       World                               pd.DataFrame(data, index=['first', 'second'])                                                 A       B       C                       first       1       2       Hello                 second       2       3       World                               pd.DataFrame(data, columns=['C', 'A', 'B'])                                                 C       A       B                       0       Hello       1       2                 1       World       2       3                       从字典列表中构造   字典中同一个键的值会被合并到同一列：           data2 = [{'a': 1, 'b': 2}, {'a': 5, 'b': 10, 'c': 20}]  pd.DataFrame(data2)                                                 a       b       c                       0       1       2       NaN                 1       5       10       20                               pd.DataFrame(data2, index=['first', 'second'])                                                 a       b       c                       first       1       2       NaN                 second       5       10       20                               pd.DataFrame(data2, columns=['a', 'b'])                                                 a       b                       0       1       2                 1       5       10                       从 Series 中构造   相当于将 Series 二维化。   其他构造方法   DataFrame.from_dict 从现有的一个字典中构造，DataFrame.from_records 从现有的一个记录数组中构造：           pd.DataFrame.from_records(data, index='C')                                                 A       B                 C                                     Hello       1       2                 World       2       3                       DataFrame.from_items 从字典的 item 对构造：           pd.DataFrame.from_items([('A', [1, 2, 3]), ('B', [4, 5, 6])])                                                 A       B                       0       1       4                 1       2       5                 2       3       6                       列操作   DataFrame 可以类似于字典一样对列进行操作：           df[\"one\"]                         a     1 b     2 c     3 d   NaN Name: one, dtype: float64                   添加新列：           df['three'] = df['one'] * df['two']  df['flag'] = df['one'] &gt; 2  df                                                 one       two       three       flag                       a       1       1       1       False                 b       2       2       4       False                 c       3       3       9       True                 d       NaN       4       NaN       False                       可以像字典一样删除：           del df[\"two\"]  three = df.pop(\"three\")  df                                                 one       flag                       a       1       False                 b       2       False                 c       3       True                 d       NaN       False                       给一行赋单一值：           df['foo'] = 'bar'  df                                                 one       flag       foo                       a       1       False       bar                 b       2       False       bar                 c       3       True       bar                 d       NaN       False       bar                       如果 index 不一致，那么会只保留公共的部分：           df['one_trunc'] = df['one'][:2]  df                                                 one       flag       foo       one_trunc                       a       1       False       bar       1                 b       2       False       bar       2                 c       3       True       bar       NaN                 d       NaN       False       bar       NaN                       也可以直接插入一维数组，但是数组的长度必须与 index 一致。   默认新列插入位置在最后，也可以指定位置插入：           df.insert(1, 'bar', df['one'])  df                                                 one       bar       flag       foo       one_trunc                       a       1       1       False       bar       1                 b       2       2       False       bar       2                 c       3       3       True       bar       NaN                 d       NaN       NaN       False       bar       NaN                       添加一个 test 新列：           df.assign(test=df[\"one\"] + df[\"bar\"])                                                 one       bar       flag       foo       one_trunc       test                       a       1       1       False       bar       1       2                 b       2       2       False       bar       2       4                 c       3       3       True       bar       NaN       6                 d       NaN       NaN       False       bar       NaN       NaN                       索引和选择   基本操作：                  Operation       Syntax       Result                       Select column       df[col]       Series                 Select row by label       df.loc[label]       Series                 Select row by integer location       df.iloc[loc]       Series                 Slice rows       df[5:10]       DataFrame                 Select rows by boolean vector       df[bool_vec]       DataFrame          ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/05/03.html",
        "teaser":null},{
        "title": "第5章 Pandas",
        
        "excerpt":
            "第5章 Pandas   05-1-十分钟上手 Pandas   05-2-Series   05-3-Dataframe  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/05/features.html",
        "teaser":null},{
        "title": "06-01 Pyplot 教程",
        
        "excerpt":
            "Pyplot 教程   Matplotlib 简介   matplotlib 是一个 Python 的 2D 图形包。   在线文档：http://matplotlib.org ，提供了 Examples, FAQ, API, Gallery，其中 Gallery 是很有用的一个部分，因为它提供了各种画图方式的可视化，方便用户根据需求进行选择。   使用 Pyplot   导入相关的包：           import numpy as np import matplotlib.pyplot as plt            matplotlib.pyplot 包含一系列类似 MATLAB 中绘图函数的相关函数。每个 matplotlib.pyplot 中的函数对当前的图像进行一些修改，例如：产生新的图像，在图像中产生新的绘图区域，在绘图区域中画线，给绘图加上标记，等等…… matplotlib.pyplot 会自动记住当前的图像和绘图区域，因此这些函数会直接作用在当前的图像上。   下文中，以 plt 作为 matplotlib.pyplot 的省略。   plt.show() 函数   默认情况下，matplotlib.pyplot 不会直接显示图像，只有调用 plt.show() 函数时，图像才会显示出来。   plt.show() 默认是在新窗口打开一幅图像，并且提供了对图像进行操作的按钮。   不过在 ipython 命令行中，我们可以使用 magic 命令将它插入 notebook 中，并且不需要调用 plt.show() 也可以显示：      %matplotlib notebook   %matplotlib inline   不过在实际写程序中，我们还是需要调用 plt.show() 函数将图像显示出来。   这里我们使图像输出在 notebook 中：           %matplotlib inline            plt.plot() 函数   例子   plt.plot() 函数可以用来绘图：           plt.plot([1,2,3,4]) plt.ylabel('some numbers')  plt.show()                                      基本用法   plot 函数基本的用法有以下四种：   默认参数     plt.plot(x,y)   指定参数     plt.plot(x,y, format_str)   默认参数，x 为 0~N-1     plt.plot(y)   指定参数，x 为 0~N-1     plt.plot(y, format_str)   因此，在上面的例子中，我们没有给定 x 的值，所以其默认值为 [0,1,2,3]。   传入 x 和 y：           plt.plot([1,2,3,4], [1,4,9,16])                         [&lt;matplotlib.lines.Line2D at 0xa48a550&gt;]                                             字符参数   和 MATLAB 中类似，我们还可以用字符来指定绘图的格式：   表示颜色的字符参数有：                  字符       颜色                       ‘b’       蓝色，blue                 ‘g’       绿色，green                 ‘r’       红色，red                 ‘c’       青色，cyan                 ‘m’       品红，magenta                 ‘y’       黄色，yellow                 ‘k’       黑色，black                 ‘w’       白色，white           表示类型的字符参数有：                  字符       类型       字符       类型                         '-'\t       实线       '--'       虚线                 '-.'       虚点线       ':'       点线                 '.'       点       ','       像素点                 'o'       圆点       'v'       下三角点                 '^'       上三角点       '&lt;'       左三角点                 '&gt;'       右三角点       '1'       下三叉点                 '2'       上三叉点       '3'       左三叉点                 '4'       右三叉点       's'       正方点                 'p'       五角点       '*'       星形点                 'h'       六边形点1       'H'       六边形点2                 '+'       加号点       'x'       乘号点                 'D'       实心菱形点       'd'       瘦菱形点                 '_'       横线点                           例如我们要画出红色圆点：           plt.plot([1,2,3,4], [1,4,9,16], 'ro') plt.show()                                      可以看出，有两个点在图像的边缘，因此，我们需要改变轴的显示范围。   显示范围   与 MATLAB 类似，这里可以使用 axis 函数指定坐标轴显示的范围：   plt.axis([xmin, xmax, ymin, ymax])           plt.plot([1,2,3,4], [1,4,9,16], 'ro') # 指定 x 轴显示区域为 0-6，y 轴为 0-20 plt.axis([0,6,0,20]) plt.show()                                      传入 Numpy 数组   之前我们传给 plot 的参数都是列表，事实上，向 plot 中传入 numpy 数组是更常用的做法。事实上，如果传入的是列表，matplotlib 会在内部将它转化成数组再进行处理：           import numpy as np import matplotlib.pyplot as plt  # evenly sampled time at 200ms intervals t = np.arange(0., 5., 0.2)  # red dashes, blue squares and green triangles plt.plot(t, t, 'r--',           t, t**2, 'bs',           t, t**3, 'g^')  plt.show()                                      传入多组数据   事实上，在上面的例子中，我们不仅仅向 plot 函数传入了数组，还传入了多组 (x,y,format_str) 参数，它们在同一张图上显示。   这意味着我们不需要使用多个 plot 函数来画多组数组，只需要可以将这些组合放到一个 plot 函数中去即可。   线条属性   之前提到，我们可以用字符串来控制线条的属性，事实上还可以通过关键词来改变线条的性质，例如 linwidth 可以改变线条的宽度，color 可以改变线条的颜色：           x = np.linspace(-np.pi,np.pi) y = np.sin(x)  plt.plot(x, y, linewidth=2.0, color='r')  plt.show()                                      使用 plt.plot() 的返回值来设置线条属性   plot 函数返回一个 Line2D 对象组成的列表，每个对象代表输入的一对组合，例如：           line1, line2 为两个 Line2D 对象       line1, line2 = plt.plot(x1, y1, x2, y2)            返回 3 个 Line2D 对象组成的列表       lines = plt.plot(x1, y1, x2, y2, x3, y3)       我们可以使用这个返回值来对线条属性进行设置：           # 加逗号 line 中得到的是 line2D 对象，不加逗号得到的是只有一个 line2D 对象的列表 line, = plt.plot(x, y, 'r-')  # 将抗锯齿关闭 line.set_antialiased(False)  plt.show()                                      plt.setp() 修改线条性质   更方便的做法是使用 plt 的 setp 函数：           lines = plt.plot(x, y)  # 使用键值对 plt.setp(lines, color='r', linewidth=2.0)  # 或者使用 MATLAB 风格的字符串对 plt.setp(lines, 'color', 'r', 'linewidth', 2.0)  plt.show()                                      可以设置的属性有很多，可以使用 plt.setp(lines) 查看 lines 可以设置的属性，各属性的含义可参考 matplotlib 的文档。           plt.setp(lines)                          agg_filter: unknown   alpha: float (0.0 transparent through 1.0 opaque)            animated: [True | False]            antialiased or aa: [True | False]            axes: an :class:`~matplotlib.axes.Axes` instance            clip_box: a :class:`matplotlib.transforms.Bbox` instance            clip_on: [True | False]            clip_path: [ (:class:`~matplotlib.path.Path`,         :class:`~matplotlib.transforms.Transform`) |         :class:`~matplotlib.patches.Patch` | None ]            color or c: any matplotlib color            contains: a callable function            dash_capstyle: ['butt' | 'round' | 'projecting']            dash_joinstyle: ['miter' | 'round' | 'bevel']            dashes: sequence of on/off ink in points            drawstyle: ['default' | 'steps' | 'steps-pre' | 'steps-mid' |                   'steps-post']            figure: a :class:`matplotlib.figure.Figure` instance            fillstyle: ['full' | 'left' | 'right' | 'bottom' | 'top' | 'none']            gid: an id string            label: string or anything printable with '%s' conversion.            linestyle or ls: [``'-'`` | ``'--'`` | ``'-.'`` | ``':'`` | ``'None'`` |                   ``' '`` | ``''``]   linewidth or lw: float value in points            lod: [True | False]            marker: :mod:`A valid marker style &lt;matplotlib.markers&gt;`   markeredgecolor or mec: any matplotlib color            markeredgewidth or mew: float value in points            markerfacecolor or mfc: any matplotlib color            markerfacecoloralt or mfcalt: any matplotlib color            markersize or ms: float            markevery: [None | int | length-2 tuple of int | slice |         list/array of int | float | length-2 tuple of float]   path_effects: unknown   picker: float distance in points or callable pick function         ``fn(artist, event)``            pickradius: float distance in points            rasterized: [True | False | None]            sketch_params: unknown   snap: unknown   solid_capstyle: ['butt' | 'round' |  'projecting']            solid_joinstyle: ['miter' | 'round' | 'bevel']            transform: a :class:`matplotlib.transforms.Transform` instance            url: a url string            visible: [True | False]            xdata: 1D array            ydata: 1D array            zorder: any number                           子图   figure() 函数会产生一个指定编号为 num 的图：   plt.figure(num)   这里，figure(1) 其实是可以省略的，因为默认情况下 plt 会自动产生一幅图像。   使用 subplot 可以在一副图中生成多个子图，其参数为：   plt.subplot(numrows, numcols, fignum)   当 numrows * numcols &lt; 10 时，中间的逗号可以省略，因此 plt.subplot(211) 就相当于 plt.subplot(2,1,1)。           def f(t):     return np.exp(-t) * np.cos(2*np.pi*t)  t1 = np.arange(0.0, 5.0, 0.1) t2 = np.arange(0.0, 5.0, 0.02)  plt.figure(1) plt.subplot(211) plt.plot(t1, f(t1), 'bo', t2, f(t2), 'k')  plt.subplot(212) plt.plot(t2, np.cos(2*np.pi*t2), 'r--') plt.show()                                      图形上加上文字   plt.hist() 可以用来画直方图。           mu, sigma = 100, 15 x = mu + sigma * np.random.randn(10000)  # the histogram of the data n, bins, patches = plt.hist(x, 50, normed=1, facecolor='g', alpha=0.75)   plt.xlabel('Smarts') plt.ylabel('Probability') plt.title('Histogram of IQ') plt.text(60, .025, r'$\\mu=100,\\ \\sigma=15$') plt.axis([40, 160, 0, 0.03]) plt.grid(True) plt.show()                                      对于这幅图形，我们使用 xlabel ，ylabel，title，text 方法设置了文字，其中：           xlabel ：x 轴标注            ylabel ：y 轴标注            title ：图形标题            text ：在指定位置放入文字       输入特殊符号支持使用 Tex 语法，用 $&lt;some Tex code&gt;$ 隔开。   除了使用 text 在指定位置标上文字之外，还可以使用 annotate 函数进行注释，annotate 主要有两个参数：      xy ：注释位置   xytext ：注释文字位置           ax = plt.subplot(111)  t = np.arange(0.0, 5.0, 0.01) s = np.cos(2*np.pi*t) line, = plt.plot(t, s, lw=2)  plt.annotate('local max', xy=(2, 1), xytext=(3, 1.5),             arrowprops=dict(facecolor='black', shrink=0.05),             )  plt.ylim(-2,2) plt.show()                                     ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/01.html",
        "teaser":null},{
        "title": "06-02 使用 style 来配置 pyplot 风格",
        
        "excerpt":
            "使用 style 来配置 pyplot 风格           import matplotlib.pyplot as plt import numpy as np  %matplotlib inline            style 是 pyplot 的一个子模块，方便进行风格转换， pyplot 有很多的预设风格，可以使用 plt.style.available 来查看：           plt.style.available                         [u'dark_background', u'bmh', u'grayscale', u'ggplot', u'fivethirtyeight']                           x = np.linspace(0, 2 * np.pi) y = np.sin(x)  plt.plot(x, y)  plt.show()                                      例如，我们可以模仿 R 语言中常用的 ggplot 风格：           plt.style.use('ggplot')  plt.plot(x, y)  plt.show()                                      有时候，我们不希望改变全局的风格，只是想暂时改变一下分隔，则可以使用 context 将风格改变限制在某一个代码块内：           with plt.style.context(('dark_background')):     plt.plot(x, y, 'r-o')     plt.show()                                      在代码块外绘图则仍然是全局的风格。           with plt.style.context(('dark_background')):     pass plt.plot(x, y, 'r-o') plt.show()                                      还可以混搭使用多种风格，不过最右边的一种风格会将最左边的覆盖：           plt.style.use(['dark_background', 'ggplot'])  plt.plot(x, y, 'r-o') plt.show()                                      事实上，我们还可以自定义风格文件。   自定义文件需要放在 matplotlib 的配置文件夹 mpl_configdir 的子文件夹 mpl_configdir/stylelib/ 下，以 .mplstyle 结尾。   mpl_configdir 的位置可以这样查看：           import matplotlib matplotlib.get_configdir()                         u'c:/Users/Jin\\\\.matplotlib'                   里面的内容以 属性：值 的形式保存：   axes.titlesize : 24 axes.labelsize : 20 lines.linewidth : 3 lines.markersize : 10 xtick.labelsize : 16 ytick.labelsize : 16   假设我们将其保存为 mpl_configdir/stylelib/presentation.mplstyle，那么使用这个风格的时候只需要调用：   plt.style.use('presentation')  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/02.html",
        "teaser":null},{
        "title": "06-03 处理文本（基础）",
        
        "excerpt":
            "处理文本（基础）           import matplotlib.pyplot as plt import numpy as np %matplotlib inline            matplotlib 对文本的支持十分完善，包括数学公式，Unicode 文字，栅格和向量化输出，文字换行，文字旋转等一系列操作。   基础文本函数   在 matplotlib.pyplot 中，基础的文本函数如下：      text() 在 Axes 对象的任意位置添加文本   xlabel() 添加 x 轴标题   ylabel() 添加 y 轴标题   title() 给 Axes 对象添加标题   figtext() 在 Figure 对象的任意位置添加文本   suptitle() 给 Figure 对象添加标题   anotate() 给 Axes 对象添加注释（可选择是否添加箭头标记）           # -*- coding: utf-8 -*- import matplotlib.pyplot as plt %matplotlib inline  # plt.figure() 返回一个 Figure() 对象 fig = plt.figure(figsize=(12, 9))  # 设置这个 Figure 对象的标题 # 事实上，如果我们直接调用 plt.suptitle() 函数，它会自动找到当前的 Figure 对象 fig.suptitle('bold figure suptitle', fontsize=14, fontweight='bold')  # Axes 对象表示 Figure 对象中的子图 # 这里只有一幅图像，所以使用 add_subplot(111) ax = fig.add_subplot(111) fig.subplots_adjust(top=0.85)  # 可以直接使用 set_xxx 的方法来设置标题 ax.set_title('axes title') # 也可以直接调用 title()，因为会自动定位到当前的 Axes 对象 # plt.title('axes title')  ax.set_xlabel('xlabel') ax.set_ylabel('ylabel')  # 添加文本，斜体加文本框 ax.text(3, 8, 'boxed italics text in data coords', style='italic',         bbox={'facecolor':'red', 'alpha':0.5, 'pad':10})  # 数学公式，用 $$ 输入 Tex 公式 ax.text(2, 6, r'an equation: $E=mc^2$', fontsize=15)  # Unicode 支持 ax.text(3, 2, unicode('unicode: Institut f\\374r Festk\\366rperphysik', 'latin-1'))  # 颜色，对齐方式 ax.text(0.95, 0.01, 'colored text in axes coords',         verticalalignment='bottom', horizontalalignment='right',         transform=ax.transAxes,         color='green', fontsize=15)  # 注释文本和箭头 ax.plot([2], [1], 'o') ax.annotate('annotate', xy=(2, 1), xytext=(3, 4),             arrowprops=dict(facecolor='black', shrink=0.05))  # 设置显示范围 ax.axis([0, 10, 0, 10])  plt.show()                                      文本属性和布局   我们可以通过下列关键词，在文本函数中设置文本的属性：                  关键词       值                       alpha       float                 backgroundcolor       any matplotlib color                 bbox       rectangle prop dict plus key 'pad' which is a pad in points                 clip_box       a matplotlib.transform.Bbox instance                 clip_on       [True ， False]                 clip_path       a Path instance and a Transform instance, a Patch                 color       any matplotlib color                 family       [ 'serif' , 'sans-serif' , 'cursive' , 'fantasy' , 'monospace' ]                 fontproperties       a matplotlib.font_manager.FontProperties instance                 horizontalalignment or ha       [ 'center' , 'right' , 'left' ]                 label       any string                 linespacing       float                 multialignment       ['left' , 'right' , 'center' ]                 name or fontname       string e.g., ['Sans' , 'Courier' , 'Helvetica' …]                 picker       [None,float,boolean,callable]                 position       (x,y)                 rotation       [ angle in degrees 'vertical' , 'horizontal'                 size or fontsize       [ size in points , relative size, e.g., 'smaller', 'x-large' ]                 style or fontstyle       [ 'normal' , 'italic' , 'oblique']                 text       string or anything printable with ‘%s’ conversion                 transform       a matplotlib.transform transformation instance                 variant       [ 'normal' , 'small-caps' ]                 verticalalignment or va       [ 'center' , 'top' , 'bottom' , 'baseline' ]                 visible       [True , False]                 weight or fontweight       [ 'normal' , 'bold' , 'heavy' , 'light' , 'ultrabold' , 'ultralight']                 x       float                 y       float                 zorder       any number           其中 va, ha, multialignment 可以用来控制布局。     horizontalalignment or ha ：x 位置参数表示的位置   verticalalignment or va：y 位置参数表示的位置   multialignment：多行位置控制           import matplotlib.pyplot as plt import matplotlib.patches as patches  # build a rectangle in axes coords left, width = .25, .5 bottom, height = .25, .5 right = left + width top = bottom + height  fig = plt.figure(figsize=(10,7)) ax = fig.add_axes([0,0,1,1])  # axes coordinates are 0,0 is bottom left and 1,1 is upper right p = patches.Rectangle(     (left, bottom), width, height,     fill=False, transform=ax.transAxes, clip_on=False     )  ax.add_patch(p)  ax.text(left, bottom, 'left top',         horizontalalignment='left',         verticalalignment='top',         transform=ax.transAxes,         size='xx-large')  ax.text(left, bottom, 'left bottom',         horizontalalignment='left',         verticalalignment='bottom',         transform=ax.transAxes,         size='xx-large')  ax.text(right, top, 'right bottom',         horizontalalignment='right',         verticalalignment='bottom',         transform=ax.transAxes,         size='xx-large')  ax.text(right, top, 'right top',         horizontalalignment='right',         verticalalignment='top',         transform=ax.transAxes,         size='xx-large')  ax.text(right, bottom, 'center top',         horizontalalignment='center',         verticalalignment='top',         transform=ax.transAxes,         size='xx-large')  ax.text(left, 0.5*(bottom+top), 'right center',         horizontalalignment='right',         verticalalignment='center',         rotation='vertical',         transform=ax.transAxes,         size='xx-large')  ax.text(left, 0.5*(bottom+top), 'left center',         horizontalalignment='left',         verticalalignment='center',         rotation='vertical',         transform=ax.transAxes,         size='xx-large')  ax.text(0.5*(left+right), 0.5*(bottom+top), 'middle',         horizontalalignment='center',         verticalalignment='center',         fontsize=20, color='red',         transform=ax.transAxes)  ax.text(right, 0.5*(bottom+top), 'centered',         horizontalalignment='center',         verticalalignment='center',         rotation='vertical',         transform=ax.transAxes,         size='xx-large')  ax.text(left, top, 'rotated\\nwith newlines',         horizontalalignment='center',         verticalalignment='center',         rotation=45,         transform=ax.transAxes,         size='xx-large')  ax.set_axis_off() plt.show()                                      注释文本   text() 函数在 Axes 对象的指定位置添加文本，而 annotate() 则是对某一点添加注释文本，需要考虑两个位置：一是注释点的坐标 xy ，二是注释文本的位置坐标 xytext：           fig = plt.figure() ax = fig.add_subplot(111)  t = np.arange(0.0, 5.0, 0.01) s = np.cos(2*np.pi*t) line, = ax.plot(t, s, lw=2)  ax.annotate('local max', xy=(2, 1), xytext=(3, 1.5),             arrowprops=dict(facecolor='black', shrink=0.05),             )  ax.set_ylim(-2,2) plt.show()                                      在上面的例子中，两个左边使用的都是原始数据的坐标系，不过我们还可以通过 xycoords 和 textcoords 来设置坐标系（默认是 'data'）：                  参数       坐标系                       ‘figure points’       points from the lower left corner of the figure                 ‘figure pixels’       pixels from the lower left corner of the figure                 ‘figure fraction’       0,0 is lower left of figure and 1,1 is upper right                 ‘axes points’       points from lower left corner of axes                 ‘axes pixels’       pixels from lower left corner of axes                 ‘axes fraction’       0,0 is lower left of axes and 1,1 is upper right                 ‘data’       use the axes data coordinate system           使用一个不同的坐标系：           fig = plt.figure() ax = fig.add_subplot(111)  t = np.arange(0.0, 5.0, 0.01) s = np.cos(2*np.pi*t) line, = ax.plot(t, s, lw=2)  ax.annotate('local max', xy=(3, 1),  xycoords='data',             xytext=(0.8, 0.95), textcoords='axes fraction',             arrowprops=dict(facecolor='black', shrink=0.05),             horizontalalignment='right', verticalalignment='top',             )  ax.set_ylim(-2,2) plt.show()                                      极坐标系注释文本   产生极坐标系需要在 subplot 的参数中设置 polar=True：           fig = plt.figure() ax = fig.add_subplot(111, polar=True) r = np.arange(0,1,0.001) theta = 2*2*np.pi*r line, = ax.plot(theta, r, color='#ee8d18', lw=3)  ind = 800 thisr, thistheta = r[ind], theta[ind] ax.plot([thistheta], [thisr], 'o') ax.annotate('a polar annotation',             xy=(thistheta, thisr),  # theta, radius             xytext=(0.05, 0.05),    # fraction, fraction             textcoords='figure fraction',             arrowprops=dict(facecolor='black', shrink=0.05),             horizontalalignment='left',             verticalalignment='bottom',             ) plt.show()                                     ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/03.html",
        "teaser":null},{
        "title": "06-04 处理文本（数学表达式）",
        
        "excerpt":
            "处理文本（数学表达式）   在字符串中使用一对 $$ 符号可以利用 Tex 语法打出数学表达式，而且并不需要预先安装 Tex。在使用时我们通常加上 r 标记表示它是一个原始字符串（raw string）           import matplotlib.pyplot as plt import numpy as np %matplotlib inline                    # plain text plt.title('alpha &gt; beta')  plt.show()                                              # math text plt.title(r'$\\alpha &gt; \\beta$')  plt.show()                                      上下标   使用 _ 和 ^ 表示上下标：   $\\alpha_i &gt; \\beta_i$：   r'$\\alpha_i &gt; \\beta_i$'   $\\sum\\limits_{i=0}^\\infty x_i$：   r'$\\sum_{i=0}^\\infty x_i$'   注：      希腊字母和特殊符号可以用 ‘\\ + 对应的名字’ 来显示   {} 中的内容属于一个部分；要打出花括号是需要使用 \\{\\}   分数，二项式系数，stacked numbers   $\\frac{3}{4}, \\binom{3}{4}, \\stackrel{3}{4}$：   r'$\\frac{3}{4}, \\binom{3}{4}, \\stackrel{3}{4}$'   $\\frac{5 - \\frac{1}{x}}{4}$：   r'$\\frac{5 - \\frac{1}{x}}{4}$'   在 Tex 语言中，括号始终是默认的大小，如果要使括号大小与括号内部的大小对应，可以使用 \\left 和 \\right 选项：   $(\\frac{5 - \\frac{1}{x}}{4})$   r'$(\\frac{5 - \\frac{1}{x}}{4})$'   $\\left(\\frac{5 - \\frac{1}{x}}{4}\\right)$：   r'$\\left(\\frac{5 - \\frac{1}{x}}{4}\\right)$'   根号   $\\sqrt{2}$：   r'$\\sqrt{2}$'   $\\sqrt[3]{x}$：   r'$\\sqrt[3]{x}$'   特殊字体   默认显示的字体是斜体，不过可以使用以下方法显示不同的字体：                  命令       显示                       \\mathrm{Roman}       $\\mathrm{Roman}$                 \\mathit{Italic}       $\\mathit{Italic}$                 \\mathtt{Typewriter}       $\\mathtt{Typewriter}$                 \\mathcal{CALLIGRAPHY}       $\\mathcal{CALLIGRAPHY}$                 \\mathbb{blackboard}       $\\mathbb{blackboard}$                 \\mathfrak{Fraktur}       $\\mathfrak{Fraktur}$                 \\mathsf{sansserif}       $\\mathsf{sansserif}$           $s(t) = \\mathcal{A}\\ \\sin(2 \\omega t)$：   s(t) = \\mathcal{A}\\ \\sin(2 \\omega t)   注：      Tex 语法默认忽略空格，要打出空格使用 '\\ '   \\sin 默认显示为 Roman 字体   音调                  命令       结果                       \\acute a       $\\acute a$                 \\bar a       $\\bar a$                 \\breve a       $\\breve a$                 \\ddot a       $\\ddot a$                 \\dot a       $\\dot a$                 \\grave a       $\\grave a$                 \\hat a       $\\hat a$                 \\tilde a       $\\tilde a$                 \\4vec a       $\\vec a$                 \\overline{abc}       $\\overline{abc}$                 \\widehat{xyz}       $\\widehat{xyz}$                 \\widetilde{xyz}       $\\widetilde{xyz}$           特殊字符表   参见：http://matplotlib.org/users/mathtext.html#symbols   例子           import numpy as np import matplotlib.pyplot as plt t = np.arange(0.0, 2.0, 0.01) s = np.sin(2*np.pi*t)  plt.plot(t,s) plt.title(r'$\\alpha_i &gt; \\beta_i$', fontsize=20) plt.text(1, -0.6, r'$\\sum_{i=0}^\\infty x_i$', fontsize=20) plt.text(0.6, 0.6, r'$\\mathcal{A}\\ \\mathrm{sin}(2 \\omega t)$',          fontsize=20) plt.xlabel('time (s)') plt.ylabel('volts (mV)') plt.show()                                     ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/04.html",
        "teaser":null},{
        "title": "06-05 图像基础",
        
        "excerpt":
            "图像基础   导入相应的包：           import matplotlib.pyplot as plt import matplotlib.image as mpimg import numpy as np %matplotlib inline               导入图像   我们首先导入上面的图像，注意 matplotlib 默认只支持 PNG 格式的图像，我们可以使用 mpimg.imread 方法读入这幅图像：           img = mpimg.imread('stinkbug.png')                    img.shape                         (375L, 500L, 3L)                   这是一个 375 x 500 x 3 的 RGB 图像，并且每个像素使用 uint8 分别表示 RGB 三个通道的值。不过在处理的时候，matplotlib 将它们的值归一化到 0.0~1.0 之间：           img.dtype                         dtype('float32')                   显示图像   使用 plt.imshow() 可以显示图像：           imgplot = plt.imshow(img)                                      伪彩色图像   从单通道模拟彩色图像：           lum_img = img[:,:,0] imgplot = plt.imshow(lum_img)                                      改变 colormap           imgplot = plt.imshow(lum_img) imgplot.set_cmap('hot')                                              imgplot = plt.imshow(lum_img) imgplot.set_cmap('spectral')                                      显示色度条：           imgplot = plt.imshow(lum_img) imgplot.set_cmap('spectral') plt.colorbar() plt.show()                                      限制显示范围   先查看直方图：           plt.hist(lum_img.flatten(), 256, range=(0.0,1.0), fc='k', ec='k') plt.show()                                      将显示范围设为 0.0-0.7：           imgplot = plt.imshow(lum_img) imgplot.set_clim(0.0,0.7)                                      resize 操作           from PIL import Image img = Image.open('stinkbug.png') rsize = img.resize((img.size[0]/10,img.size[1]/10)) rsizeArr = np.asarray(rsize)  imgplot = plt.imshow(rsizeArr)                                      上面我们将这个图像使用 PIL 的 Image 对象导入，并将其 resize 为原来的 1/100，可以看到很多细节都丢失了。   在画图时，由于画面的大小与实际像素的大小可能不一致，所以不一致的地方会进行插值处理，尝试一下不同的插值方法：           imgplot = plt.imshow(rsizeArr) imgplot.set_interpolation('nearest')                                              imgplot = plt.imshow(rsizeArr) imgplot.set_interpolation('bicubic')                                     ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/05.html",
        "teaser":null},{
        "title": "06-06 注释",
        
        "excerpt":
            "注释   使用文本框进行注释   先看一个简单的例子：           import numpy.random import matplotlib.pyplot as plt %matplotlib inline  fig = plt.figure(1, figsize=(5,5)) fig.clf()  ax = fig.add_subplot(111) ax.set_aspect(1)  x1 = -1 + numpy.random.randn(100) y1 = -1 + numpy.random.randn(100) x2 = 1. + numpy.random.randn(100) y2 = 1. + numpy.random.randn(100)  ax.scatter(x1, y1, color=\"r\") ax.scatter(x2, y2, color=\"g\")  # 加上两个文本框 bbox_props = dict(boxstyle=\"round\", fc=\"w\", ec=\"0.5\", alpha=0.9) ax.text(-2, -2, \"Sample A\", ha=\"center\", va=\"center\", size=20,         bbox=bbox_props) ax.text(2, 2, \"Sample B\", ha=\"center\", va=\"center\", size=20,         bbox=bbox_props)  # 加上一个箭头文本框 bbox_props = dict(boxstyle=\"rarrow\", fc=(0.8,0.9,0.9), ec=\"b\", lw=2) t = ax.text(0, 0, \"Direction\", ha=\"center\", va=\"center\", rotation=45,             size=15,             bbox=bbox_props)  bb = t.get_bbox_patch() bb.set_boxstyle(\"rarrow\", pad=0.6)  ax.set_xlim(-4, 4) ax.set_ylim(-4, 4)  plt.show()                                      text() 函数接受 bbox 参数来绘制文本框。  bbox_props = dict(boxstyle=\"rarrow,pad=0.3\", fc=\"cyan\", ec=\"b\", lw=2) t = ax.text(0, 0, \"Direction\", ha=\"center\", va=\"center\", rotation=45,             size=15,             bbox=bbox_props)   可以这样来获取这个文本框，并对其参数进行修改：  bb = t.get_bbox_patch() bb.set_boxstyle(\"rarrow\", pad=0.6)   可用的文本框风格有：                  class       name       attrs                       LArrow       larrow       pad=0.3                 RArrow       rarrow       pad=0.3                 Round       round       pad=0.3,rounding_size=None                 Round4       round4       pad=0.3,rounding_size=None                 Roundtooth       roundtooth       pad=0.3,tooth_size=None                 Sawtooth       sawtooth       pad=0.3,tooth_size=None                 Square       square       pad=0.3                   import matplotlib.patches as mpatch import matplotlib.pyplot as plt  styles = mpatch.BoxStyle.get_styles()  figheight = (len(styles)+.5) fig1 = plt.figure(figsize=(4/1.5, figheight/1.5)) fontsize = 0.3 * 72 ax = fig1.add_subplot(111)  for i, (stylename, styleclass) in enumerate(styles.items()):     ax.text(0.5, (float(len(styles)) - 0.5 - i)/figheight, stylename,               ha=\"center\",               size=fontsize,               transform=fig1.transFigure,               bbox=dict(boxstyle=stylename, fc=\"w\", ec=\"k\"))  # 去掉轴的显示 ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.spines['left'].set_color('none') ax.spines['bottom'].set_color('none') plt.xticks([]) plt.yticks([])  plt.show()                                      各个风格的文本框如上图所示。   使用箭头进行注释           plt.figure(1, figsize=(3,3)) ax = plt.subplot(111)  ax.annotate(\"\",             xy=(0.2, 0.2), xycoords='data',             xytext=(0.8, 0.8), textcoords='data',             arrowprops=dict(arrowstyle=\"-&gt;\",                             connectionstyle=\"arc3\"),              )  plt.show()                                      之前介绍了 annotate 中 xy, xycoords, xytext, textcoords 参数的含义，通常我们把 xy 设在 data 坐标系，把 xytext 设在 offset 即以注释点为原点的参考系。   箭头显示是可选的，用 arrowprops 参数来指定，接受一个字典作为参数。   不同类型的绘制箭头方式：           import matplotlib.pyplot as plt import matplotlib.patches as mpatches  x1, y1 = 0.3, 0.3 x2, y2 = 0.7, 0.7  fig = plt.figure(1, figsize=(8,3)) fig.clf() from mpl_toolkits.axes_grid.axes_grid import AxesGrid from mpl_toolkits.axes_grid.anchored_artists import AnchoredText  #from matplotlib.font_manager import FontProperties  def add_at(ax, t, loc=2):     fp = dict(size=10)     _at = AnchoredText(t, loc=loc, prop=fp)     ax.add_artist(_at)     return _at   grid = AxesGrid(fig, 111, (1, 4), label_mode=\"1\", share_all=True)  grid[0].set_autoscale_on(False)  ax = grid[0] ax.plot([x1, x2], [y1, y2], \".\") el = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2) ax.add_artist(el) ax.annotate(\"\",             xy=(x1, y1), xycoords='data',             xytext=(x2, y2), textcoords='data',             arrowprops=dict(arrowstyle=\"-\", #linestyle=\"dashed\",                             color=\"0.5\",                             patchB=None,                             shrinkB=0,                             connectionstyle=\"arc3,rad=0.3\",                             ),             )  add_at(ax, \"connect\", loc=2)  ax = grid[1] ax.plot([x1, x2], [y1, y2], \".\") el = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2) ax.add_artist(el) ax.annotate(\"\",             xy=(x1, y1), xycoords='data',             xytext=(x2, y2), textcoords='data',             arrowprops=dict(arrowstyle=\"-\", #linestyle=\"dashed\",                             color=\"0.5\",                             patchB=el,                             shrinkB=0,                             connectionstyle=\"arc3,rad=0.3\",                             ),             )  add_at(ax, \"clip\", loc=2)   ax = grid[2] ax.plot([x1, x2], [y1, y2], \".\") el = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2) ax.add_artist(el) ax.annotate(\"\",             xy=(x1, y1), xycoords='data',             xytext=(x2, y2), textcoords='data',             arrowprops=dict(arrowstyle=\"-\", #linestyle=\"dashed\",                             color=\"0.5\",                             patchB=el,                             shrinkB=5,                             connectionstyle=\"arc3,rad=0.3\",                             ),             )  add_at(ax, \"shrink\", loc=2)   ax = grid[3] ax.plot([x1, x2], [y1, y2], \".\") el = mpatches.Ellipse((x1, y1), 0.3, 0.4, angle=30, alpha=0.2) ax.add_artist(el) ax.annotate(\"\",             xy=(x1, y1), xycoords='data',             xytext=(x2, y2), textcoords='data',             arrowprops=dict(arrowstyle=\"fancy\", #linestyle=\"dashed\",                             color=\"0.5\",                             patchB=el,                             shrinkB=5,                             connectionstyle=\"arc3,rad=0.3\",                             ),             )  add_at(ax, \"mutate\", loc=2)  grid[0].set_xlim(0, 1) grid[0].set_ylim(0, 1) grid[0].axis[\"bottom\"].toggle(ticklabels=False) grid[0].axis[\"left\"].toggle(ticklabels=False) fig.subplots_adjust(left=0.05, right=0.95, bottom=0.05, top=0.95)  plt.draw() plt.show()                                      字典中，connectionstyle 参数控制路径的风格：                  Name       Attr                       angle       angleA=90,angleB=0,rad=0.0                 angle3       angleA=90,angleB=0                 arc       angleA=0,angleB=0,armA=None,armB=None,rad=0.0                 arc3       rad=0.0                 bar       armA=0.0,armB=0.0,fraction=0.3,angle=None                   import matplotlib.pyplot as plt import matplotlib.patches as mpatches  fig = plt.figure(1, figsize=(8,5)) fig.clf() from mpl_toolkits.axes_grid.axes_grid import AxesGrid from mpl_toolkits.axes_grid.anchored_artists import AnchoredText  #from matplotlib.font_manager import FontProperties  def add_at(ax, t, loc=2):     fp = dict(size=8)     _at = AnchoredText(t, loc=loc, prop=fp)     ax.add_artist(_at)     return _at   grid = AxesGrid(fig, 111, (3, 5), label_mode=\"1\", share_all=True)  grid[0].set_autoscale_on(False)   x1, y1 = 0.3, 0.3 x2, y2 = 0.7, 0.7   def demo_con_style(ax, connectionstyle, label=None):      if label is None:         label = connectionstyle      x1, y1 = 0.3, 0.2     x2, y2 = 0.8, 0.6      ax.plot([x1, x2], [y1, y2], \".\")     ax.annotate(\"\",                 xy=(x1, y1), xycoords='data',                 xytext=(x2, y2), textcoords='data',                 arrowprops=dict(arrowstyle=\"-&gt;\", #linestyle=\"dashed\",                                 color=\"0.5\",                                 shrinkA=5, shrinkB=5,                                 patchA=None,                                 patchB=None,                                 connectionstyle=connectionstyle,                                 ),                 )      add_at(ax, label, loc=2)  column = grid.axes_column[0]  demo_con_style(column[0], \"angle3,angleA=90,angleB=0\",                label=\"angle3,\\nangleA=90,\\nangleB=0\") demo_con_style(column[1], \"angle3,angleA=0,angleB=90\",                label=\"angle3,\\nangleA=0,\\nangleB=90\")    column = grid.axes_column[1]  demo_con_style(column[0], \"arc3,rad=0.\") demo_con_style(column[1], \"arc3,rad=0.3\") demo_con_style(column[2], \"arc3,rad=-0.3\")    column = grid.axes_column[2]  demo_con_style(column[0], \"angle,angleA=-90,angleB=180,rad=0\",                label=\"angle,\\nangleA=-90,\\nangleB=180,\\nrad=0\") demo_con_style(column[1], \"angle,angleA=-90,angleB=180,rad=5\",                label=\"angle,\\nangleA=-90,\\nangleB=180,\\nrad=5\") demo_con_style(column[2], \"angle,angleA=-90,angleB=10,rad=5\",                label=\"angle,\\nangleA=-90,\\nangleB=10,\\nrad=0\")   column = grid.axes_column[3]  demo_con_style(column[0], \"arc,angleA=-90,angleB=0,armA=30,armB=30,rad=0\",                label=\"arc,\\nangleA=-90,\\nangleB=0,\\narmA=30,\\narmB=30,\\nrad=0\") demo_con_style(column[1], \"arc,angleA=-90,angleB=0,armA=30,armB=30,rad=5\",                label=\"arc,\\nangleA=-90,\\nangleB=0,\\narmA=30,\\narmB=30,\\nrad=5\") demo_con_style(column[2], \"arc,angleA=-90,angleB=0,armA=0,armB=40,rad=0\",                label=\"arc,\\nangleA=-90,\\nangleB=0,\\narmA=0,\\narmB=40,\\nrad=0\")   column = grid.axes_column[4]  demo_con_style(column[0], \"bar,fraction=0.3\",                label=\"bar,\\nfraction=0.3\") demo_con_style(column[1], \"bar,fraction=-0.3\",                label=\"bar,\\nfraction=-0.3\") demo_con_style(column[2], \"bar,angle=180,fraction=-0.2\",                label=\"bar,\\nangle=180,\\nfraction=-0.2\")   #demo_con_style(column[1], \"arc3,rad=0.3\") #demo_con_style(column[2], \"arc3,rad=-0.3\")   grid[0].set_xlim(0, 1) grid[0].set_ylim(0, 1) grid.axes_llc.axis[\"bottom\"].toggle(ticklabels=False) grid.axes_llc.axis[\"left\"].toggle(ticklabels=False) fig.subplots_adjust(left=0.05, right=0.95, bottom=0.05, top=0.95)  plt.draw() plt.show()                                      arrowstyle 参数控制小箭头的风格：                  Name       Attrs                       -       None                 -&gt;       head_length=0.4,head_width=0.2                 -[       widthB=1.0,lengthB=0.2,angleB=None                 ¦-¦       widthA=1.0,widthB=1.0                 -¦&gt;       head_length=0.4,head_width=0.2                 &lt;-       head_length=0.4,head_width=0.2                 &lt;-&gt;       head_length=0.4,head_width=0.2                 &lt;¦-       head_length=0.4,head_width=0.2                 &lt;¦-¦&gt;       head_length=0.4,head_width=0.2                 fancy       head_length=0.4,head_width=0.4,tail_width=0.4                 simple       head_length=0.5,head_width=0.5,tail_width=0.2                 wedge       tail_width=0.3,shrink_factor=0.5                   import matplotlib.patches as mpatches import matplotlib.pyplot as plt  styles = mpatches.ArrowStyle.get_styles()  ncol=2 nrow = (len(styles)+1) // ncol figheight = (nrow+0.5) fig1 = plt.figure(1, (4.*ncol/1.5, figheight/1.5)) fontsize = 0.2 * 70   ax = fig1.add_axes([0, 0, 1, 1], frameon=False, aspect=1.)  ax.set_xlim(0, 4*ncol) ax.set_ylim(0, figheight)  def to_texstring(s):     s = s.replace(\"&lt;\", r\"$&lt;$\")     s = s.replace(\"&gt;\", r\"$&gt;$\")     s = s.replace(\"|\", r\"$|$\")     return s  for i, (stylename, styleclass) in enumerate(sorted(styles.items())):     x = 3.2 + (i//nrow)*4     y = (figheight - 0.7 - i%nrow) # /figheight     p = mpatches.Circle((x, y), 0.2, fc=\"w\")     ax.add_patch(p)      ax.annotate(to_texstring(stylename), (x, y),                 (x-1.2, y),                 #xycoords=\"figure fraction\", textcoords=\"figure fraction\",                 ha=\"right\", va=\"center\",                 size=fontsize,                 arrowprops=dict(arrowstyle=stylename,                                 patchB=p,                                 shrinkA=5,                                 shrinkB=5,                                 fc=\"w\", ec=\"k\",                                 connectionstyle=\"arc3,rad=-0.05\",                                 ),                 bbox=dict(boxstyle=\"square\", fc=\"w\"))  ax.xaxis.set_visible(False) ax.yaxis.set_visible(False)    plt.draw() plt.show()                                     ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/06.html",
        "teaser":null},{
        "title": "06-07 标签",
        
        "excerpt":
            "标签           import numpy as np import matplotlib as mpl import matplotlib.pyplot as plt  %matplotlib inline            legend() 函数被用来添加图像的标签，其主要相关的属性有：      legend entry - 一个 legend 包含一个或多个 entry，一个 entry 对应一个 key 和一个 label   legend key - marker 的标记   legend label - key 的说明   legend handle - 一个 entry 在图上对应的对象   使用 legend   调用 legend() 会自动获取当前的 Axes 对象，并且得到这些 handles 和 labels，相当于：   handles, labels = ax.get_legend_handles_labels() ax.legend(handles, labels)   我们可以在函数中指定 handles 的参数：           line_up, = plt.plot([1,2,3], label='Line 2') line_down, = plt.plot([3,2,1], label='Line 1') plt.legend(handles=[line_up, line_down]) plt.show()                                      可以将 labels 作为参数输入 legend 函数：           line_up, = plt.plot([1,2,3]) line_down, = plt.plot([3,2,1]) plt.legend([line_up, line_down], ['Line Up', 'Line Down']) plt.show()                                      产生特殊形状的 marker key   有时我们可以产生一些特殊形状的 marker：   块状：           import matplotlib.patches as mpatches  red_patch = mpatches.Patch(color='red', label='The red data') plt.legend(handles=[red_patch])  plt.show()                                      点线组合：           import matplotlib.lines as mlines import matplotlib.pyplot as plt  blue_line = mlines.Line2D([], [], color='blue', marker='*',                           markersize=15, label='Blue stars') plt.legend(handles=[blue_line])  plt.show()                                      指定 legend 的位置   bbox_to_anchor 关键词可以指定 legend 放置的位置，例如放到图像的右上角：           plt.plot([1,2,3], label=\"test1\") plt.plot([3,2,1], label=\"test2\") plt.legend(bbox_to_anchor=(1, 1),            bbox_transform=plt.gcf().transFigure)  plt.show()                                      更复杂的用法：           plt.subplot(211) plt.plot([1,2,3], label=\"test1\") plt.plot([3,2,1], label=\"test2\") # Place a legend above this legend, expanding itself to # fully use the given bounding box. plt.legend(bbox_to_anchor=(0., 1.02, 1., .102), loc=3,            ncol=2, mode=\"expand\", borderaxespad=0.)  plt.subplot(223) plt.plot([1,2,3], label=\"test1\") plt.plot([3,2,1], label=\"test2\") # Place a legend to the right of this smaller figure. plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)  plt.show()                                      同一个 Axes 中的多个 legend   可以这样添加多个 legend：           line1, = plt.plot([1,2,3], label=\"Line 1\", linestyle='--') line2, = plt.plot([3,2,1], label=\"Line 2\", linewidth=4)  # Create a legend for the first line. first_legend = plt.legend(handles=[line1], loc=1)  # Add the legend manually to the current Axes. ax = plt.gca().add_artist(first_legend)  # Create another legend for the second line. plt.legend(handles=[line2], loc=4)  plt.show()                                      其中 loc 参数可以取 0-10 或者 字符串，表示放置的位置：                  loc string       loc code                       'best'         0                 'upper right'        1                 'upper left'         2                 'lower left'         3                 'lower right'        4                 'right'              5                 'center left'        6                 'center right'       7                 'lower center'       8                 'upper center'       9                 'center'       10           更多用法   多个 handle 可以通过括号组合在一个 entry 中：           from numpy.random import randn  z = randn(10)  red_dot, = plt.plot(z, \"ro\", markersize=15) # Put a white cross over some of the data. white_cross, = plt.plot(z[:5], \"w+\", markeredgewidth=3, markersize=15)  plt.legend([red_dot, (red_dot, white_cross)], [\"Attr A\", \"Attr A+B\"])  plt.show()                                      自定义 handle：           import matplotlib.pyplot as plt import matplotlib.patches as mpatches  class AnyObject(object):     pass  class AnyObjectHandler(object):     def legend_artist(self, legend, orig_handle, fontsize, handlebox):         x0, y0 = handlebox.xdescent, handlebox.ydescent         width, height = handlebox.width, handlebox.height         patch = mpatches.Rectangle([x0, y0], width, height, facecolor='red',                                    edgecolor='black', hatch='xx', lw=3,                                    transform=handlebox.get_transform())         handlebox.add_artist(patch)         return patch  plt.legend([AnyObject()], ['My first handler'],            handler_map={AnyObject: AnyObjectHandler()})  plt.show()                                      椭圆：           from matplotlib.legend_handler import HandlerPatch import matplotlib.pyplot as plt import matplotlib.patches as mpatches   class HandlerEllipse(HandlerPatch):     def create_artists(self, legend, orig_handle,                        xdescent, ydescent, width, height, fontsize, trans):         center = 0.5 * width - 0.5 * xdescent, 0.5 * height - 0.5 * ydescent         p = mpatches.Ellipse(xy=center, width=width + xdescent,                              height=height + ydescent)         self.update_prop(p, orig_handle, legend)         p.set_transform(trans)         return [p]   c = mpatches.Circle((0.5, 0.5), 0.25, facecolor=\"green\",                     edgecolor=\"red\", linewidth=3) plt.gca().add_patch(c)  plt.legend([c], [\"An ellipse, not a rectangle\"],            handler_map={mpatches.Circle: HandlerEllipse()})  plt.show()                                     ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/07.html",
        "teaser":null},{
        "title": "06-08 figures, subplots, axes 和 ticks 对象",
        
        "excerpt":
            "figures, subplots, axes 和 ticks 对象   figures, axes 和 ticks 的关系   这些对象的关系可以用下面的图来表示：   示例图像：   &lt;img src=”./artists_figure.png” width = “600” height = “400” alt=”图1” align=left /&gt;   具体结构：   &lt;img src=”./artists_tree.png” width = “600” height = “400” alt=”图2” align=left /&gt;   figure 对象   figure 对象是最外层的绘图单位，默认是以 1 开始编号（MATLAB 风格，Figure 1, Figure 2, ...），可以用 plt.figure() 产生一幅图像，除了默认参数外，可以指定的参数有：      num - 编号   figsize - 图像大小   dpi - 分辨率   facecolor - 背景色   edgecolor - 边界颜色   frameon - 边框   这些属性也可以通过 Figure 对象的 set_xxx 方法来改变。   subplot 和 axes 对象   subplot   subplot 主要是使用网格排列子图：           %pylab inline  subplot(2,1,1) xticks([]), yticks([]) text(0.5,0.5, 'subplot(2,1,1)',ha='center',va='center',size=24,alpha=.5)  subplot(2,1,2) xticks([]), yticks([]) text(0.5,0.5, 'subplot(2,1,2)',ha='center',va='center',size=24,alpha=.5)  show()                        Populating the interactive namespace from numpy and matplotlib                                            更高级的可以用 gridspec 来绘图：           import matplotlib.gridspec as gridspec  G = gridspec.GridSpec(3, 3)  axes_1 = subplot(G[0, :]) xticks([]), yticks([]) text(0.5,0.5, 'Axes 1',ha='center',va='center',size=24,alpha=.5)  axes_2 = subplot(G[1,:-1]) xticks([]), yticks([]) text(0.5,0.5, 'Axes 2',ha='center',va='center',size=24,alpha=.5)  axes_3 = subplot(G[1:, -1]) xticks([]), yticks([]) text(0.5,0.5, 'Axes 3',ha='center',va='center',size=24,alpha=.5)  axes_4 = subplot(G[-1,0]) xticks([]), yticks([]) text(0.5,0.5, 'Axes 4',ha='center',va='center',size=24,alpha=.5)  axes_5 = subplot(G[-1,-2]) xticks([]), yticks([]) text(0.5,0.5, 'Axes 5',ha='center',va='center',size=24,alpha=.5)  show()                                      axes 对象   subplot 返回的是 Axes 对象，但是 Axes 对象相对于 subplot 返回的对象来说要更自由一点。Axes 对象可以放置在图像中的任意位置：           axes([0.1,0.1,.8,.8]) xticks([]), yticks([]) text(0.6,0.6, 'axes([0.1,0.1,.8,.8])',ha='center',va='center',size=20,alpha=.5)  axes([0.2,0.2,.3,.3]) xticks([]), yticks([]) text(0.5,0.5, 'axes([0.2,0.2,.3,.3])',ha='center',va='center',size=16,alpha=.5)  show()                                              axes([0.1,0.1,.5,.5]) xticks([]), yticks([]) text(0.1,0.1, 'axes([0.1,0.1,.8,.8])',ha='left',va='center',size=16,alpha=.5)  axes([0.2,0.2,.5,.5]) xticks([]), yticks([]) text(0.1,0.1, 'axes([0.2,0.2,.5,.5])',ha='left',va='center',size=16,alpha=.5)  axes([0.3,0.3,.5,.5]) xticks([]), yticks([]) text(0.1,0.1, 'axes([0.3,0.3,.5,.5])',ha='left',va='center',size=16,alpha=.5)  axes([0.4,0.4,.5,.5]) xticks([]), yticks([]) text(0.1,0.1, 'axes([0.4,0.4,.5,.5])',ha='left',va='center',size=16,alpha=.5)  show()                                      后面的 Axes 对象会覆盖前面的内容。   ticks 对象   ticks 用来注释轴的内容，我们可以通过控制它的属性来决定在哪里显示轴、轴的内容是什么等等。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/08.html",
        "teaser":null},{
        "title": "06-09 不要迷信默认设置",
        
        "excerpt":
            "不要迷信默认设置   导入相关的包：           import numpy as np import matplotlib.pyplot as plt            生成三角函数：           x = np.linspace(-np.pi, np.pi) c, s = np.cos(x), np.sin(x)            默认绘图           %matplotlib inline  # 画图 p = plt.plot(x,c) p = plt.plot(x,s)  # 在脚本中需要加上这句才会显示图像 plt.show()                                      默认效果如图所示，我们可以修改默认的属性来得到更漂亮的结果。   图   图像以 Figure # 为窗口标题，并且数字从 1 开始，figure() 函数的主要参数如下：                  参数       默认值       描述                       num       1       图号                 figsize       figure.figsize       图大小（宽，高）（单位英寸）                 dpi       figure.dpi       分辨率（每英寸所打印的点数）                 facecolor       figure.facecolor       背景颜色                 edgecolor       figure.edgecolor       边界颜色                 frameon       True       是否显示图框架                   # 设置图像大小 f = plt.figure(figsize=(10,6), dpi=80)  # 画图 p = plt.plot(x,c) p = plt.plot(x,s)  # 在脚本中需要加上这句才会显示图像 plt.show()            设置线条颜色，粗细，类型   首先，我们使用 figure() 函数来创建一幅新图像，并且指定它的大小，使得长宽比更合适。   然后，我们使用 color, linewidth, linestyle 参数，指定曲线的颜色，粗细，类型：           # 设置图像大小 f = plt.figure(figsize=(10,6), dpi=80)  # 画图，指定颜色，线宽，类型 p = plt.plot(x, c, color=\"blue\", linewidth=2.5, linestyle=\"-\") p = plt.plot(x, s, color=\"red\",  linewidth=2.5, linestyle=\"-\")  # 在脚本中需要加上这句才会显示图像 # plt.show()                                      也可以像 Matlab 中一样使用格式字符来修改参数：   表示颜色的字符参数有：                  字符       颜色                       ‘b’       蓝色，blue                 ‘g’       绿色，green                 ‘r’       红色，red                 ‘c’       青色，cyan                 ‘m’       品红，magenta                 ‘y’       黄色，yellow                 ‘k’       黑色，black                 ‘w’       白色，white           表示类型的字符参数有：                  字符       类型       字符       类型                         '-'\t       实线       '--'       虚线                 '-.'       虚点线       ':'       点线                 '.'       点       ','       像素点                 'o'       圆点       'v'       下三角点                 '^'       上三角点       '&lt;'       左三角点                 '&gt;'       右三角点       '1'       下三叉点                 '2'       上三叉点       '3'       左三叉点                 '4'       右三叉点       's'       正方点                 'p'       五角点       '*'       星形点                 'h'       六边形点1       'H'       六边形点2                 '+'       加号点       'x'       乘号点                 'D'       实心菱形点       'd'       瘦菱形点                 '_'       横线点                                   # 设置图像大小 f = plt.figure(figsize=(10,6), dpi=80)  # 画图，指定颜色，线宽，类型 p = plt.plot(x, c, 'b-',           x, s, 'r-', linewidth=2.5)  # 在脚本中需要加上这句才会显示图像 # plt.show()                                      设置横轴纵轴的显示区域   我们希望将坐标轴的显示区域放大一些，这样可以看到所有的点，可以使用 plt 中的 xlim 和 ylim 来设置：           # 设置图像大小 p = plt.figure(figsize=(10,6), dpi=80)  # 画图，指定颜色，线宽，类型 p = plt.plot(x, c, 'b-',           x, s, 'r-', linewidth=2.5)  ########################################################################  # 设置显示范围 p = plt.xlim(x.min() * 1.1, x.max() * 1.1) p = plt.ylim(c.min() * 1.1, c.max() * 1.1)  ########################################################################  # 在脚本中需要加上这句才会显示图像 # plt.show()                                      设置刻度   对于三教函数来说，我们希望将 x 轴的刻度设为与 $\\pi$ 有关的点，可以使用 plt 中的 xticks 和 yticks 函数，将需要的刻度传入：           # 设置图像大小 f = plt.figure(figsize=(10,6), dpi=80)  # 画图，指定颜色，线宽，类型 p = plt.plot(x, c, 'b-',           x, s, 'r-', linewidth=2.5)  # 设置显示范围 plt.xlim(x.min() * 1.1, x.max() * 1.1) plt.ylim(c.min() * 1.1, c.max() * 1.1)  ###########################################################################  # 设置刻度 p = plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi]) p = plt.yticks([-1, 0, 1])  ###########################################################################  # 在脚本中需要加上这句才会显示图像 # plt.show()                                      设定 x 轴 y 轴标题   我们想让刻度的位置显示的是含有 $\\pi$ 的标识而不是浮点数，可以在 xticks 中传入第二组参数，这组参数代表对应刻度的显示标识。这里，我们使用 latex 的语法来显示特殊符号（使用 $$ 包围的部分）：           # 设置图像大小 f = plt.figure(figsize=(10,6), dpi=80)  # 画图，指定颜色，线宽，类型 p = plt.plot(x, c, 'b-',           x, s, 'r-', linewidth=2.5)  # 设置显示范围 plt.xlim(x.min() * 1.1, x.max() * 1.1) plt.ylim(c.min() * 1.1, c.max() * 1.1)  # 设置刻度及其标识 p = plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],                 ['$-\\pi$', '$-\\pi/2$', '$0$', '$\\pi/2$', '$\\pi$'], fontsize ='xx-large') p = plt.yticks([-1, 0, 1],                 ['$-1$', '$0$', '$+1$'], fontsize ='xx-large')  # 在脚本中需要加上这句才会显示图像 # plt.show()                                      移动坐标轴的位置   现在坐标轴的位置是在边界上，而且有上下左右四条，我们现在想将下面和左边的两条移动到中间，并将右边和上面的两条去掉：           # 设置图像大小 f = plt.figure(figsize=(10,6), dpi=80)  # 画图，指定颜色，线宽，类型 plt.plot(x, c, 'b-',           x, s, 'r-', linewidth=2.5)  # 设置显示范围 plt.xlim(x.min() * 1.1, x.max() * 1.1) plt.ylim(c.min() * 1.1, c.max() * 1.1)  # 得到轴的句柄 ax = plt.gca() # ax.spines参数表示四个坐标轴线 # 将右边和上边的颜色设为透明 ax.spines['right'].set_color('none') ax.spines['top'].set_color('none')  ###################################################################################  # 将 x 轴的刻度设置在下面的坐标轴上 ax.xaxis.set_ticks_position('bottom') # 设置位置 ax.spines['bottom'].set_position(('data',0))  # 将 y 轴的刻度设置在左边的坐标轴上 ax.yaxis.set_ticks_position('left') # 设置位置 ax.spines['left'].set_position(('data',0))  ###################################################################################  # 设置刻度及其标识 p = plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],             ['$-\\pi$', '$-\\pi/2$', '$0$', '$\\pi/2$', '$\\pi$'], fontsize ='xx-large') p = plt.yticks([-1, 0, 1],             ['$-1$', '$0$', '$+1$'], fontsize ='xx-large')  # 在脚本中需要加上这句才会显示图像 # plt.show()                                      加入图例   使用 legend() 加入图例：           # 设置图像大小 plt.figure(figsize=(10,6), dpi=80)  # 画图，指定颜色，线宽，类型 plt.plot(x, c, 'b-',           x, s, 'r-', linewidth=2.5)  # 设置显示范围 plt.xlim(x.min() * 1.1, x.max() * 1.1) plt.ylim(c.min() * 1.1, c.max() * 1.1)  # 得到画图的句柄 ax = plt.gca()  # ax.spines参数表示四个坐标轴线 # 将右边和上边的颜色设为透明 ax.spines['right'].set_color('none') ax.spines['top'].set_color('none')  # 将 x 轴的刻度设置在下面的坐标轴上 ax.xaxis.set_ticks_position('bottom') # 设置位置 ax.spines['bottom'].set_position(('data',0))  # 将 y 轴的刻度设置在左边的坐标轴上 ax.yaxis.set_ticks_position('left') # 设置位置 ax.spines['left'].set_position(('data',0))  # 设置刻度及其标识 plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],             ['$-\\pi$', '$-\\pi/2$', '$0$', '$\\pi/2$', '$\\pi$'], fontsize ='xx-large') plt.yticks([-1, 0, 1],             ['$-1$', '$0$', '$+1$'], fontsize ='xx-large')  ##################################################################################################  # 加入图例，frameon表示去掉图例周围的边框 l = plt.legend(['cosine', 'sine'], loc='upper left', frameon=False)  ##################################################################################################  # 在脚本中需要加上这句才会显示图像 # plt.show()                                      注释特殊点   我们可以使用 anotate 函数来注释特殊的点，假设我们要显示的点是 $2\\pi/3$：           # 设置图像大小 plt.figure(figsize=(10,6), dpi=80)  # 画图，指定颜色，线宽，类型 plt.plot(x, c, 'b-',           x, s, 'r-', linewidth=2.5)  # 设置显示范围 plt.xlim(x.min() * 1.1, x.max() * 1.1) plt.ylim(c.min() * 1.1, c.max() * 1.1)  # 得到画图的句柄 ax = plt.gca()  # ax.spines参数表示四个坐标轴线 # 将右边和上边的颜色设为透明 ax.spines['right'].set_color('none') ax.spines['top'].set_color('none')  # 将 x 轴的刻度设置在下面的坐标轴上 ax.xaxis.set_ticks_position('bottom') # 设置位置 ax.spines['bottom'].set_position(('data',0))  # 将 y 轴的刻度设置在左边的坐标轴上 ax.yaxis.set_ticks_position('left') # 设置位置 ax.spines['left'].set_position(('data',0))  # 设置刻度及其标识 plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],             ['$-\\pi$', '$-\\pi/2$', '$0$', '$\\pi/2$', '$\\pi$'], fontsize ='xx-large') plt.yticks([-1, 0, 1],             ['$-1$', '$0$', '$+1$'], fontsize ='xx-large')  # 加入图例，frameon表示图例周围是否需要边框 l = plt.legend(['cosine', 'sine'], loc='upper left', frameon=False)  ####################################################################################  # 数据点 t = 2 * np.pi / 3  # 蓝色虚线 plt.plot([t,t],[0,np.cos(t)], color ='blue', linewidth=2.5, linestyle=\"--\")  # 该点处的 cos 值 plt.scatter([t,],[np.cos(t),], 50, color ='blue')  # 在对应的点显示文本 plt.annotate(r'$\\sin(\\frac{2\\pi}{3})=\\frac{\\sqrt{3}}{2}$', # 文本              xy=(t, np.sin(t)), # 数据点坐标位置              xycoords='data',   # 坐标相对于数据              xytext=(+10, +30), # 文本位置坐标              textcoords='offset points', # 坐标相对于数据点的坐标              fontsize=16,       # 文本大小              arrowprops=dict(arrowstyle=\"-&gt;\", connectionstyle=\"arc3,rad=.2\")) # 箭头  # 红色虚线 p = plt.plot([t,t],[0,np.sin(t)], color ='red', linewidth=2.5, linestyle=\"--\")  # 该点处的 sin 值 p = plt.scatter([t,],[np.sin(t),], 50, color ='red')  # 显示文本 p = plt.annotate(r'$\\cos(\\frac{2\\pi}{3})=-\\frac{1}{2}$',              xy=(t, np.cos(t)), xycoords='data',              xytext=(-90, -50), textcoords='offset points', fontsize=16,              arrowprops=dict(arrowstyle=\"-&gt;\", connectionstyle=\"arc3,rad=.2\"))   #####################################################################################  # 在脚本中需要加上这句才会显示图像 # plt.show()                                      最后调整   调整刻度值的大小，并让其显示在曲线上方。           # 设置图像大小 plt.figure(figsize=(10,6), dpi=80)  # 画图，指定颜色，线宽，类型 plt.plot(x, c, 'b-',           x, s, 'r-', linewidth=2.5)  # 设置显示范围 plt.xlim(x.min() * 1.1, x.max() * 1.1) plt.ylim(c.min() * 1.1, c.max() * 1.1)  # 得到画图的句柄 ax = plt.gca()  # ax.spines参数表示四个坐标轴线 # 将右边和上边的颜色设为透明 ax.spines['right'].set_color('none') ax.spines['top'].set_color('none')  # 将 x 轴的刻度设置在下面的坐标轴上 ax.xaxis.set_ticks_position('bottom') # 设置位置 ax.spines['bottom'].set_position(('data',0))  # 将 y 轴的刻度设置在左边的坐标轴上 ax.yaxis.set_ticks_position('left') # 设置位置 ax.spines['left'].set_position(('data',0))  # 设置刻度及其标识 plt.xticks([-np.pi, -np.pi/2, 0, np.pi/2, np.pi],             ['$-\\pi$', '$-\\pi/2$', '$0$', '$\\pi/2$', '$\\pi$'], fontsize ='xx-large') plt.yticks([-1, 0, 1],             ['$-1$', '$0$', '$+1$'], fontsize ='xx-large')  # 加入图例，frameon表示图例周围是否需要边框 l = plt.legend(['cosine', 'sine'], loc='upper left', frameon=False)  # 数据点 t = 2 * np.pi / 3  # 蓝色虚线 plt.plot([t,t],[0,np.cos(t)], color ='blue', linewidth=2.5, linestyle=\"--\")  # 该点处的 cos 值 plt.scatter([t,],[np.cos(t),], 50, color ='blue')  # 在对应的点显示文本 plt.annotate(r'$\\sin(\\frac{2\\pi}{3})=\\frac{\\sqrt{3}}{2}$', # 文本              xy=(t, np.sin(t)), # 数据点坐标位置              xycoords='data',   # 坐标相对于数据              xytext=(+10, +30), # 文本位置坐标              textcoords='offset points', # 坐标相对于数据点的坐标              fontsize=16,       # 文本大小              arrowprops=dict(arrowstyle=\"-&gt;\", connectionstyle=\"arc3,rad=.2\")) # 箭头  # 红色虚线 p = plt.plot([t,t],[0,np.sin(t)], color ='red', linewidth=2.5, linestyle=\"--\")  # 该点处的 sin 值 p = plt.scatter([t,],[np.sin(t),], 50, color ='red')  # 显示文本 p = plt.annotate(r'$\\cos(\\frac{2\\pi}{3})=-\\frac{1}{2}$',              xy=(t, np.cos(t)), xycoords='data',              xytext=(-90, -50), textcoords='offset points', fontsize=16,              arrowprops=dict(arrowstyle=\"-&gt;\", connectionstyle=\"arc3,rad=.2\"))   #####################################################################################  for label in ax.get_xticklabels() + ax.get_yticklabels():     label.set_fontsize(16)     label.set_bbox(dict(facecolor='white', edgecolor='None', alpha=0.65 ))  ####################################################################################  # 在脚本中需要加上这句才会显示图像 # plt.show()                                         The devil is in the details.   ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/09.html",
        "teaser":null},{
        "title": "06-10 各种绘图实例",
        
        "excerpt":
            "各种绘图实例 简单绘图 plot 函数： %matplotlib inline import numpy as np import matplotlib.pyplot as plt t = np.arange(0.0, 2.0, 0.01) s = np.sin(2*np.pi*t) plt.plot(t, s) plt.xlabel('time (s)') plt.ylabel('voltage (mV)') plt.title('About as simple as it gets, folks') plt.grid(True) plt.show() 子图 subplot 函数： import numpy as np import matplotlib.mlab as mlab x1 = np.linspace(0.0, 5.0) x2 = np.linspace(0.0, 2.0) y1 = np.cos(2 * np.pi * x1) * np.exp(-x1) y2 = np.cos(2 * np.pi * x2) plt.subplot(2, 1, 1) plt.plot(x1, y1, 'yo-') plt.title('A tale of 2 subplots') plt.ylabel('Damped oscillation') plt.subplot(2, 1, 2) plt.plot(x2, y2, 'r.-') plt.xlabel('time (s)') plt.ylabel('Undamped') plt.show() 直方图 hist 函数： import numpy as np import matplotlib.mlab as mlab import matplotlib.pyplot as plt # example data mu = 100 # mean of distribution sigma = 15 # standard deviation of distribution x = mu + sigma * np.random.randn(10000) num_bins = 50 # the histogram of the data n, bins, patches = plt.hist(x, num_bins, normed=1, facecolor='green', alpha=0.5) # add a 'best fit' line y = mlab.normpdf(bins, mu, sigma) plt.plot(bins, y, 'r--') plt.xlabel('Smarts') plt.ylabel('Probability') plt.title(r'Histogram of IQ: $\\mu=100$, $\\sigma=15$') # Tweak spacing to prevent clipping of ylabel plt.subplots_adjust(left=0.15) plt.show() 路径图 matplotlib.path 包： import matplotlib.path as mpath import matplotlib.patches as mpatches import matplotlib.pyplot as plt fig, ax = plt.subplots() Path = mpath.Path path_data = [ (Path.MOVETO, (1.58, -2.57)), (Path.CURVE4, (0.35, -1.1)), (Path.CURVE4, (-1.75, 2.0)), (Path.CURVE4, (0.375, 2.0)), (Path.LINETO, (0.85, 1.15)), (Path.CURVE4, (2.2, 3.2)), (Path.CURVE4, (3, 0.05)), (Path.CURVE4, (2.0, -0.5)), (Path.CLOSEPOLY, (1.58, -2.57)), ] codes, verts = zip(*path_data) path = mpath.Path(verts, codes) patch = mpatches.PathPatch(path, facecolor='r', alpha=0.5) ax.add_patch(patch) # plot control points and connecting lines x, y = zip(*path.vertices) line, = ax.plot(x, y, 'go-') ax.grid() ax.axis('equal') plt.show() 三维绘图 导入 Axex3D： from mpl_toolkits.mplot3d import Axes3D from matplotlib import cm from matplotlib.ticker import LinearLocator, FormatStrFormatter import matplotlib.pyplot as plt import numpy as np fig = plt.figure() ax = fig.gca(projection='3d') X = np.arange(-5, 5, 0.25) Y = np.arange(-5, 5, 0.25) X, Y = np.meshgrid(X, Y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R) surf = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=cm.coolwarm, linewidth=0, antialiased=False) ax.set_zlim(-1.01, 1.01) ax.zaxis.set_major_locator(LinearLocator(10)) ax.zaxis.set_major_formatter(FormatStrFormatter('%.02f')) fig.colorbar(surf, shrink=0.5, aspect=5) plt.show() 流向图 主要函数：plt.streamplot import numpy as np import matplotlib.pyplot as plt Y, X = np.mgrid[-3:3:100j, -3:3:100j] U = -1 - X**2 + Y V = 1 + X - Y**2 speed = np.sqrt(U*U + V*V) plt.streamplot(X, Y, U, V, color=U, linewidth=2, cmap=plt.cm.autumn) plt.colorbar() f, (ax1, ax2) = plt.subplots(ncols=2) ax1.streamplot(X, Y, U, V, density=[0.5, 1]) lw = 5*speed/speed.max() ax2.streamplot(X, Y, U, V, density=0.6, color='k', linewidth=lw) plt.show() 椭圆 Ellipse 对象： from pylab import figure, show, rand from matplotlib.patches import Ellipse NUM = 250 ells = [Ellipse(xy=rand(2)*10, width=rand(), height=rand(), angle=rand()*360) for i in range(NUM)] fig = figure() ax = fig.add_subplot(111, aspect='equal') for e in ells: ax.add_artist(e) e.set_clip_box(ax.bbox) e.set_alpha(rand()) e.set_facecolor(rand(3)) ax.set_xlim(0, 10) ax.set_ylim(0, 10) show() 条状图 bar 函数： import numpy as np import matplotlib.pyplot as plt n_groups = 5 means_men = (20, 35, 30, 35, 27) std_men = (2, 3, 4, 1, 2) means_women = (25, 32, 34, 20, 25) std_women = (3, 5, 2, 3, 3) fig, ax = plt.subplots() index = np.arange(n_groups) bar_width = 0.35 opacity = 0.4 error_config = {'ecolor': '0.3'} rects1 = plt.bar(index, means_men, bar_width, alpha=opacity, color='b', yerr=std_men, error_kw=error_config, label='Men') rects2 = plt.bar(index + bar_width, means_women, bar_width, alpha=opacity, color='r', yerr=std_women, error_kw=error_config, label='Women') plt.xlabel('Group') plt.ylabel('Scores') plt.title('Scores by group and gender') plt.xticks(index + bar_width, ('A', 'B', 'C', 'D', 'E')) plt.legend() plt.tight_layout() plt.show() 饼状图 pie 函数： import matplotlib.pyplot as plt # The slices will be ordered and plotted counter-clockwise. labels = 'Frogs', 'Hogs', 'Dogs', 'Logs' sizes = [15, 30, 45, 10] colors = ['yellowgreen', 'gold', 'lightskyblue', 'lightcoral'] explode = (0, 0.1, 0, 0) # only \"explode\" the 2nd slice (i.e. 'Hogs') plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=90) # Set aspect ratio to be equal so that pie is drawn as a circle. plt.axis('equal') plt.show() 图像中的表格 table 函数： import numpy as np import matplotlib.pyplot as plt data = [[ 66386, 174296, 75131, 577908, 32015], [ 58230, 381139, 78045, 99308, 160454], [ 89135, 80552, 152558, 497981, 603535], [ 78415, 81858, 150656, 193263, 69638], [ 139361, 331509, 343164, 781380, 52269]] columns = ('Freeze', 'Wind', 'Flood', 'Quake', 'Hail') rows = ['%d year' % x for x in (100, 50, 20, 10, 5)] values = np.arange(0, 2500, 500) value_increment = 1000 # Get some pastel shades for the colors colors = plt.cm.BuPu(np.linspace(0, 0.5, len(columns))) n_rows = len(data) index = np.arange(len(columns)) + 0.3 bar_width = 0.4 # Initialize the vertical-offset for the stacked bar chart. y_offset = np.array([0.0] * len(columns)) # Plot bars and create text labels for the table cell_text = [] for row in range(n_rows): plt.bar(index, data[row], bar_width, bottom=y_offset, color=colors[row]) y_offset = y_offset + data[row] cell_text.append(['%1.1f' % (x/1000.0) for x in y_offset]) # Reverse colors and text labels to display the last value at the top. colors = colors[::-1] cell_text.reverse() # Add a table at the bottom of the axes the_table = plt.table(cellText=cell_text, rowLabels=rows, rowColours=colors, colLabels=columns, loc='bottom') # Adjust layout to make room for the table: plt.subplots_adjust(left=0.2, bottom=0.2) plt.ylabel(\"Loss in ${0}'s\".format(value_increment)) plt.yticks(values * value_increment, ['%d' % val for val in values]) plt.xticks([]) plt.title('Loss by Disaster') plt.show() 散点图 scatter 函数： import numpy as np import matplotlib.pyplot as plt import matplotlib.cbook as cbook # Load a numpy record array from yahoo csv data with fields date, # open, close, volume, adj_close from the mpl-data/example directory. # The record array stores python datetime.date as an object array in # the date column datafile = cbook.get_sample_data('goog.npy') price_data = np.load(datafile).view(np.recarray) price_data = price_data[-250:] # get the most recent 250 trading days delta1 = np.diff(price_data.adj_close)/price_data.adj_close[:-1] # Marker size in units of points^2 volume = (15 * price_data.volume[:-2] / price_data.volume[0])**2 close = 0.003 * price_data.close[:-2] / 0.003 * price_data.open[:-2] fig, ax = plt.subplots() ax.scatter(delta1[:-1], delta1[1:], c=close, s=volume, alpha=0.5) ax.set_xlabel(r'$\\Delta_i$', fontsize=20) ax.set_ylabel(r'$\\Delta_{i+1}$', fontsize=20) ax.set_title('Volume and percent change') ax.grid(True) fig.tight_layout() plt.show() 设置按钮 matplotlib.widgets 模块： import numpy as np import matplotlib.pyplot as plt from matplotlib.widgets import Slider, Button, RadioButtons fig, ax = plt.subplots() plt.subplots_adjust(left=0.25, bottom=0.25) t = np.arange(0.0, 1.0, 0.001) a0 = 5 f0 = 3 s = a0*np.sin(2*np.pi*f0*t) l, = plt.plot(t,s, lw=2, color='red') plt.axis([0, 1, -10, 10]) axcolor = 'lightgoldenrodyellow' axfreq = plt.axes([0.25, 0.1, 0.65,...",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/10.html",
        "teaser":null},{
        "title": "第6章 Matplotlib",
        
        "excerpt":
            "第6章 Matplotlib   06-1-Pyplot 教程   06-2-使用 style 来配置 pyplot 风格   06-3-处理文本（基础）   06-4-处理文本（数学表达式）   06-5-图像基础   06-6-注释   06-7-标签   06-8-figures, subplots, axes 和 ticks 对象   06-9-不要迷信默认设置   06-10-各种绘图实例  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/06/features.html",
        "teaser":null},{
        "title": "07-01 Scientific Python 简介",
        
        "excerpt":
            "Scientific Python 简介   Ipython 提供了一个很好的解释器界面。   Matplotlib 提供了一个类似 Matlab 的画图工具。   Numpy 提供了 ndarray 对象，可以进行快速的向量化计算。   Scipy 是 Python 中进行科学计算的一个第三方库，以 Numpy 为基础。   Pandas 是处理时间序列数据的第三方库，提供一个类似 R 语言的环境。   StatsModels 是一个统计库，着重于统计模型。   Scikits 以 Scipy 为基础，提供如 scikits-learn 机器学习和scikits-image 图像处理等高级用法。   Scipy   Scipy 由不同科学计算领域的子模块组成：                  子模块       描述                       cluster       聚类算法                 constants       物理数学常数                 fftpack       快速傅里叶变换                 integrate       积分和常微分方程求解                 interpolate       插值                 io       输入输出                 linalg       线性代数                 odr       正交距离回归                 optimize       优化和求根                 signal       信号处理                 sparse       稀疏矩阵                 spatial       空间数据结构和算法                 special       特殊方程                 stats       统计分布和函数                 weave       C/C++ 积分           在使用 Scipy 之前，为了方便，假定这些基础的模块已经被导入：           import numpy as np import scipy as sp import matplotlib as mpl import matplotlib.pyplot as plt            使用 Scipy 中的子模块时，需要分别导入：           from scipy import linalg, optimize            对于一些常用的函数，这些在子模块中的函数可以在 scipy 命名空间中调用。另一方面，由于 Scipy 以 Numpy 为基础，因此很多基础的 Numpy 函数可以在scipy 命名空间中直接调用。   我们可以使用 numpy 中的 info 函数来查看函数的文档：           np.info(optimize.fmin)                         fmin(func, x0, args=(), xtol=0.0001, ftol=0.0001, maxiter=None, maxfun=None,       full_output=0, disp=1, retall=0, callback=None)  Minimize a function using the downhill simplex algorithm.  This algorithm only uses function values, not derivatives or second derivatives.  Parameters ---------- func : callable func(x,*args)     The objective function to be minimized. x0 : ndarray     Initial guess. args : tuple, optional     Extra arguments passed to func, i.e. ``f(x,*args)``. callback : callable, optional     Called after each iteration, as callback(xk), where xk is the     current parameter vector. xtol : float, optional     Relative error in xopt acceptable for convergence. ftol : number, optional     Relative error in func(xopt) acceptable for convergence. maxiter : int, optional     Maximum number of iterations to perform. maxfun : number, optional     Maximum number of function evaluations to make. full_output : bool, optional     Set to True if fopt and warnflag outputs are desired. disp : bool, optional     Set to True to print convergence messages. retall : bool, optional     Set to True to return list of solutions at each iteration.  Returns ------- xopt : ndarray     Parameter that minimizes function. fopt : float     Value of function at minimum: ``fopt = func(xopt)``. iter : int     Number of iterations performed. funcalls : int     Number of function calls made. warnflag : int     1 : Maximum number of function evaluations made.     2 : Maximum number of iterations reached. allvecs : list     Solution at each iteration.  See also -------- minimize: Interface to minimization algorithms for multivariate     functions. See the 'Nelder-Mead' `method` in particular.  Notes ----- Uses a Nelder-Mead simplex algorithm to find the minimum of function of one or more variables.  This algorithm has a long history of successful use in applications. But it will usually be slower than an algorithm that uses first or second derivative information. In practice it can have poor performance in high-dimensional problems and is not robust to minimizing complicated functions. Additionally, there currently is no complete theory describing when the algorithm will successfully converge to the minimum, or how fast it will if it does.  References ---------- .. [1] Nelder, J.A. and Mead, R. (1965), \"A simplex method for function        minimization\", The Computer Journal, 7, pp. 308-313  .. [2] Wright, M.H. (1996), \"Direct Search Methods: Once Scorned, Now        Respectable\", in Numerical Analysis 1995, Proceedings of the        1995 Dundee Biennial Conference in Numerical Analysis, D.F.        Griffiths and G.A. Watson (Eds.), Addison Wesley Longman,        Harlow, UK, pp. 191-208.                  可以用 lookfor 来查询特定关键词相关的函数：           np.lookfor(\"resize array\")                        Search results for 'resize array' --------------------------------- numpy.chararray.resize     Change shape and size of array in-place. numpy.ma.resize     Return a new masked array with the specified size and shape. numpy.oldnumeric.ma.resize     The original array's total size can be any size. numpy.resize     Return a new array with the specified shape. numpy.chararray     chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0, numpy.memmap     Create a memory-map to an array stored in a *binary* file on disk. numpy.ma.mvoid.resize     .. warning::                  还可以指定查找的模块：           np.lookfor(\"remove path\", module=\"os\")                        Search results for 'remove path' -------------------------------- os.removedirs     removedirs(path) os.walk     Directory tree generator.                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/01.html",
        "teaser":null},{
        "title": "07-02 插值",
        
        "excerpt":
            "插值           import numpy as np import matplotlib.pyplot as plt %matplotlib inline            设置 Numpy 浮点数显示格式：           np.set_printoptions(precision=2, suppress=True)            从文本中读入数据，数据来自 http://kinetics.nist.gov/janaf/html/C-067.txt ，保存为结构体数组：           data = np.genfromtxt(\"JANAF_CH4.txt\",                    delimiter=\"\\t\", # TAB 分隔                   skiprows=1,     # 忽略首行                   names=True,     # 读入属性                   missing_values=\"INFINITE\",  # 缺失值                   filling_values=np.inf)      # 填充缺失值            显示部分数据：           for row in data[:7]:     print \"{}\\t{}\".format(row['TK'], row['Cp']) print \"...\\t...\"                        0.0\t0.0 100.0\t33.258 200.0\t33.473 250.0\t34.216 298.15\t35.639 300.0\t35.708 350.0\t37.874 ...\t...                  绘图：           p = plt.plot(data['TK'], data['Cp'], 'kx') t = plt.title(\"JANAF data for Methane $CH_4$\") a = plt.axis([0, 6000, 30, 120]) x = plt.xlabel(\"Temperature (K)\") y = plt.ylabel(r\"$C_p$ ($\\frac{kJ}{kg K}$)\")                                      插值   假设我们要对这组数据进行插值。   先导入一维插值函数 interp1d：   interp1d(x, y)           from scipy.interpolate import interp1d                    ch4_cp = interp1d(data['TK'], data['Cp'])            interp1d 的返回值可以像函数一样接受输入，并返回插值的结果。   单个输入值，注意返回的是数组：           ch4_cp(382.2)                         array(39.565144000000004)                   输入数组，返回的是对应的数组：           ch4_cp([32.2,323.2])                         array([ 10.71,  36.71])                   默认情况下，输入值要在插值允许的范围内，否则插值会报错：           ch4_cp(8752)                             ---------------------------------------------------------------------------      ValueError                                Traceback (most recent call last)      &lt;ipython-input-10-5d727af9aa33&gt; in &lt;module&gt;()     ----&gt; 1 ch4_cp(8752)           d:\\Miniconda\\lib\\site-packages\\scipy\\interpolate\\polyint.pyc in __call__(self, x)          77         \"\"\"          78         x, x_shape = self._prepare_x(x)     ---&gt; 79         y = self._evaluate(x)          80         return self._finish_y(y, x_shape)          81            d:\\Miniconda\\lib\\site-packages\\scipy\\interpolate\\interpolate.pyc in _evaluate(self, x_new)         496         #    The behavior is set by the bounds_error variable.         497         x_new = asarray(x_new)     --&gt; 498         out_of_bounds = self._check_bounds(x_new)         499         y_new = self._call(self, x_new)         500         if len(y_new) &gt; 0:           d:\\Miniconda\\lib\\site-packages\\scipy\\interpolate\\interpolate.pyc in _check_bounds(self, x_new)         526                 \"range.\")         527         if self.bounds_error and above_bounds.any():     --&gt; 528             raise ValueError(\"A value in x_new is above the interpolation \"         529                 \"range.\")         530            ValueError: A value in x_new is above the interpolation range.                    但我们可以通过参数设置允许超出范围的值存在：           ch4_cp = interp1d(data['TK'], data['Cp'],                    bounds_error=False)            不过由于超出范围，所以插值的输出是非法值：           ch4_cp(8752)                         array(nan)                   可以使用指定值替代这些非法值：           ch4_cp = interp1d(data['TK'], data['Cp'],                    bounds_error=False, fill_value=-999.25)                    ch4_cp(8752)                         array(-999.25)                   线性插值   interp1d 默认的插值方法是线性，关于线性插值的定义，请参见：      维基百科-线性插值： https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC   百度百科-线性插值： http://baike.baidu.com/view/4685624.htm   其基本思想是，已知相邻两点 $x_1,x_2$ 对应的值 $y_1,y_2$ ，那么对于 $(x_1,x_2)$ 之间的某一点 $x$ ，线性插值对应的值 $y$ 满足：点 $(x,y)$ 在 $(x_1,y_1),(x_2,y_2)$ 所形成的线段上。   应用线性插值：           T = np.arange(100,355,5) plt.plot(T, ch4_cp(T), \"+k\") p = plt.plot(data['TK'][1:7], data['Cp'][1:7], 'ro', markersize=8)                                      其中红色的圆点为原来的数据点，黑色的十字点为对应的插值点，可以明显看到，相邻的数据点的插值在一条直线上。   多项式插值   我们可以通过 kind 参数来调节使用的插值方法，来得到不同的结果：      nearest 最近邻插值   zero 0阶插值   linear 线性插值   quadratic 二次插值   cubic 三次插值   4,5,6,7 更高阶插值   最近邻插值：           cp_ch4 = interp1d(data['TK'], data['Cp'], kind=\"nearest\") p = plt.plot(T, cp_ch4(T), \"k+\") p = plt.plot(data['TK'][1:7], data['Cp'][1:7], 'ro', markersize=8)                                      0阶插值：           cp_ch4 = interp1d(data['TK'], data['Cp'], kind=\"zero\") p = plt.plot(T, cp_ch4(T), \"k+\") p = plt.plot(data['TK'][1:7], data['Cp'][1:7], 'ro', markersize=8)                                      二次插值：           cp_ch4 = interp1d(data['TK'], data['Cp'], kind=\"quadratic\") p = plt.plot(T, cp_ch4(T), \"k+\") p = plt.plot(data['TK'][1:7], data['Cp'][1:7], 'ro', markersize=8)                                      三次插值：           cp_ch4 = interp1d(data['TK'], data['Cp'], kind=\"cubic\") p = plt.plot(T, cp_ch4(T), \"k+\") p = plt.plot(data['TK'][1:7], data['Cp'][1:7], 'ro', markersize=8)                                      事实上，我们可以使用更高阶的多项式插值，只要将 kind 设为对应的数字即可：   四次多项式插值：           cp_ch4 = interp1d(data['TK'], data['Cp'], kind=4) p = plt.plot(T, cp_ch4(T), \"k+\") p = plt.plot(data['TK'][1:7], data['Cp'][1:7], 'ro', markersize=8)                                      可以参见：      维基百科-多项式插值：https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%8F%92%E5%80%BC   百度百科-插值法：http://baike.baidu.com/view/754506.htm   对于二维乃至更高维度的多项式插值：           from scipy.interpolate import interp2d, interpnd            其使用方法与一维类似。   径向基函数   关于径向基函数，可以参阅：     维基百科-Radial basis fucntion：https://en.wikipedia.org/wiki/Radial_basis_function   径向基函数，简单来说就是点 $x$ 处的函数值只依赖于 $x$ 与某点 $c$ 的距离：             x = np.linspace(-3,3,100)            常用的径向基（RBF）函数有：   高斯函数：           plt.plot(x, np.exp(-1 * x **2)) t = plt.title(\"Gaussian\")                                      Multiquadric 函数：           plt.plot(x, np.sqrt(1 + x **2)) t = plt.title(\"Multiquadric\")                                      Inverse Multiquadric 函数：           plt.plot(x, 1. / np.sqrt(1 + x **2)) t = plt.title(\"Inverse Multiquadric\")                                      径向基函数插值   对于径向基函数，其插值的公式为：     我们通过数据点 $x_j$ 来计算出 $n_j$ 的值，来计算 $x$ 处的插值结果。           from scipy.interpolate.rbf import Rbf            使用 multiquadric 核的：           cp_rbf = Rbf(data['TK'], data['Cp'], function = \"multiquadric\") plt.plot(data['TK'], data['Cp'], 'k+') p = plt.plot(data['TK'], cp_rbf(data['TK']), 'r-')                                      使用 gaussian 核：           cp_rbf = Rbf(data['TK'], data['Cp'], function = \"gaussian\") plt.plot(data['TK'], data['Cp'], 'k+') p = plt.plot(data['TK'], cp_rbf(data['TK']), 'r-')                                      使用 nverse_multiquadric 核：           cp_rbf = Rbf(data['TK'], data['Cp'], function = \"inverse_multiquadric\") plt.plot(data['TK'], data['Cp'], 'k+') p = plt.plot(data['TK'], cp_rbf(data['TK']), 'r-')                                      不同的 RBF 核的结果也不同。   高维 RBF 插值           from mpl_toolkits.mplot3d import Axes3D            三维数据点：           x, y = np.mgrid[-np.pi/2:np.pi/2:5j, -np.pi/2:np.pi/2:5j] z = np.cos(np.sqrt(x**2 + y**2))                    fig = plt.figure(figsize=(12,6)) ax = fig.gca(projection=\"3d\") ax.scatter(x,y,z)                         &lt;mpl_toolkits.mplot3d.art3d.Path3DCollection at 0x176b4da0&gt;                                             3维 RBF 插值：           zz = Rbf(x, y, z)                    xx, yy = np.mgrid[-np.pi/2:np.pi/2:50j, -np.pi/2:np.pi/2:50j] fig = plt.figure(figsize=(12,6)) ax = fig.gca(projection=\"3d\") ax.plot_surface(xx,yy,zz(xx,yy),rstride=1, cstride=1, cmap=plt.cm.jet)                         &lt;mpl_toolkits.mplot3d.art3d.Poly3DCollection at 0x176e5c50&gt;                                            ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/02.html",
        "teaser":null},{
        "title": "07-03 统计概率方法",
        
        "excerpt":
            "概率统计方法   简介   Python 中常用的统计工具有 Numpy, Pandas, PyMC, StatsModels 等。   Scipy 中的子库 scipy.stats 中包含很多统计上的方法。   导入 numpy 和 matplotlib：           %pylab inline                        Populating the interactive namespace from numpy and matplotlib                          heights = array([1.46, 1.79, 2.01, 1.75, 1.56, 1.69, 1.88, 1.76, 1.88, 1.78])            Numpy 自带简单的统计方法：           print 'mean, ', heights.mean() print 'min, ', heights.min() print 'max, ', heights.max() print 'standard deviation, ', heights.std()                        mean,  1.756 min,  1.46 max,  2.01 standard deviation,  0.150811140172                  导入 Scipy 的统计模块：           import scipy.stats.stats as st            其他统计量：           print 'median, ', st.nanmedian(heights)    # 忽略nan值之后的中位数 print 'mode, ', st.mode(heights)           # 众数及其出现次数 print 'skewness, ', st.skew(heights)       # 偏度 print 'kurtosis, ', st.kurtosis(heights)   # 峰度 print 'and so many more...'                        median,  1.77 mode,  (array([ 1.88]), array([ 2.])) skewness,  -0.393524456473 kurtosis,  -0.330672097724 and so many more...                  概率分布   常见的连续概率分布有：      均匀分布   正态分布   学生t分布   F分布   Gamma分布   …   离散概率分布：      伯努利分布   几何分布   …   这些都可以在 scipy.stats 中找到。   连续分布   正态分布   以正态分布为例，先导入正态分布：           from scipy.stats import norm            它包含四类常用的函数：      norm.cdf 返回对应的累计分布函数值   norm.pdf 返回对应的概率密度函数值   norm.rvs 产生指定参数的随机变量   norm.fit 返回给定数据下，各参数的最大似然估计（MLE）值   从正态分布产生500个随机点：           x_norm = norm.rvs(size=500) type(x_norm)                         numpy.ndarray                   直方图：           h = hist(x_norm) print 'counts, ', h[0] print 'bin centers', h[1]                        counts,  [   7.   21.   42.   97.  120.   91.   64.   38.   17.    3.] bin centers [-2.68067801 -2.13266147 -1.58464494 -1.0366284  -0.48861186  0.05940467   0.60742121  1.15543774  1.70345428  2.25147082  2.79948735]                                            归一化直方图（用出现频率代替次数），将划分区间变为 20（默认 10）：           h = hist(x_norm, normed=True, bins=20)                                      在这组数据下，正态分布参数的最大似然估计值为：           x_mean, x_std = norm.fit(x_norm)  print 'mean, ', x_mean print 'x_std, ', x_std                        mean,  -0.0426135499965 x_std,  0.950754110144                  将真实的概率密度函数与直方图进行比较：           h = hist(x_norm, normed=True, bins=20)  x = linspace(-3,3,50) p = plot(x, norm.pdf(x), 'r-')                                      导入积分函数：           from scipy.integrate import trapz             通过积分，计算落在某个区间的概率大小：           x1 = linspace(-2,2,108) p = trapz(norm.pdf(x1), x1)  print '{:.2%} of the values lie between -2 and 2'.format(p)  fill_between(x1, norm.pdf(x1), color = 'red') plot(x, norm.pdf(x), 'k-')                        95.45% of the values lie between -2 and 2                               [&lt;matplotlib.lines.Line2D at 0x15cbb8d0&gt;]                                             默认情况，正态分布的参数为均值0，标准差1，即标准正态分布。   可以通过 loc 和 scale 来调整这些参数，一种方法是调用相关函数时进行输入：           p = plot(x, norm.pdf(x, loc=0, scale=1)) p = plot(x, norm.pdf(x, loc=0.5, scale=2)) p = plot(x, norm.pdf(x, loc=-0.5, scale=.5))                                      另一种则是将 loc, scale 作为参数直接输给 norm 生成相应的分布：           p = plot(x, norm(loc=0, scale=1).pdf(x)) p = plot(x, norm(loc=0.5, scale=2).pdf(x)) p = plot(x, norm(loc=-0.5, scale=.5).pdf(x))                                      其他连续分布           from scipy.stats import lognorm, t, dweibull            支持与 norm 类似的操作，如概率密度函数等。   不同参数的对数正态分布：           x = linspace(0.01, 3, 100)  plot(x, lognorm.pdf(x, 1), label='s=1') plot(x, lognorm.pdf(x, 2), label='s=2') plot(x, lognorm.pdf(x, .1), label='s=0.1')  legend()                         &lt;matplotlib.legend.Legend at 0x15781c88&gt;                                             不同的韦氏分布：           x = linspace(0.01, 3, 100)  plot(x, dweibull.pdf(x, 1), label='s=1, constant failure rate') plot(x, dweibull.pdf(x, 2), label='s&gt;1, increasing failure rate') plot(x, dweibull.pdf(x, .1), label='0&lt;s&lt;1, decreasing failure rate')  legend()                         &lt;matplotlib.legend.Legend at 0xaa9bc50&gt;                                             不同自由度的学生 t 分布：           x = linspace(-3, 3, 100)  plot(x, t.pdf(x, 1), label='df=1') plot(x, t.pdf(x, 2), label='df=2') plot(x, t.pdf(x, 100), label='df=100') plot(x[::5], norm.pdf(x[::5]), 'kx', label='normal')  legend()                         &lt;matplotlib.legend.Legend at 0x164582e8&gt;                                             离散分布   导入离散分布：           from scipy.stats import binom, poisson, randint            离散分布没有概率密度函数，但是有概率质量函数。   离散均匀分布的概率质量函数（PMF）：           high = 10 low = -10  x = arange(low, high+1, 0.5) p = stem(x, randint(low, high).pmf(x))  # 杆状图                                      二项分布：           num_trials = 60 x = arange(num_trials)  plot(x, binom(num_trials, 0.5).pmf(x), 'o-', label='p=0.5') plot(x, binom(num_trials, 0.2).pmf(x), 'o-', label='p=0.2')  legend()                         &lt;matplotlib.legend.Legend at 0x1738a198&gt;                                             泊松分布：           x = arange(0,21)  plot(x, poisson(1).pmf(x), 'o-', label=r'$\\lambda$=1') plot(x, poisson(4).pmf(x), 'o-', label=r'$\\lambda$=4') plot(x, poisson(9).pmf(x), 'o-', label=r'$\\lambda$=9')  legend()                         &lt;matplotlib.legend.Legend at 0x1763e320&gt;                                             自定义离散分布   导入要用的函数：           from scipy.stats import rv_discrete            一个不均匀的骰子对应的离散值及其概率：           xk = [1, 2, 3, 4, 5, 6] pk = [.3, .35, .25, .05, .025, .025]            定义离散分布：           loaded = rv_discrete(values=(xk, pk))            此时， loaded 可以当作一个离散分布的模块来使用。   产生两个服从该分布的随机变量：           loaded.rvs(size=2)                         array([3, 1])                   产生100个随机变量，将直方图与概率质量函数进行比较：           samples = loaded.rvs(size=100) bins = linspace(.5,6.5,7)  hist(samples, bins=bins, normed=True) stem(xk, loaded.pmf(xk), markerfmt='ro', linefmt='r-')                         &lt;Container object of 3 artists&gt;                                             假设检验   导入相关的函数：      正态分布   独立双样本 t 检验，配对样本 t 检验，单样本 t 检验   学生 t 分布   t 检验的相关内容请参考：     百度百科-t 检验：http://baike.baidu.com/view/557340.htm   维基百科-学生 t 检验：https://en.wikipedia.org/wiki/Student%27s_t-test           from scipy.stats import norm from scipy.stats import ttest_ind, ttest_rel, ttest_1samp from scipy.stats import t            独立样本 t 检验   两组参数不同的正态分布：           n1 = norm(loc=0.3, scale=1.0) n2 = norm(loc=0, scale=1.0)            从分布中产生两组随机样本：           n1_samples = n1.rvs(size=100) n2_samples = n2.rvs(size=100)            将两组样本混合在一起：           samples = hstack((n1_samples, n2_samples))             最大似然参数估计：           loc, scale = norm.fit(samples) n = norm(loc=loc, scale=scale)            比较：           x = linspace(-3,3,100)  hist([samples, n1_samples, n2_samples], normed=True) plot(x, n.pdf(x), 'b-') plot(x, n1.pdf(x), 'g-') plot(x, n2.pdf(x), 'r-')                         [&lt;matplotlib.lines.Line2D at 0x17ca7278&gt;]                                             独立双样本 t 检验的目的在于判断两组样本之间是否有显著差异：           t_val, p = ttest_ind(n1_samples, n2_samples)  print 't = {}'.format(t_val) print 'p-value = {}'.format(p)                        t = 0.868384594123 p-value = 0.386235148899                  p 值小，说明这两个样本有显著性差异。   配对样本 t 检验   配对样本指的是两组样本之间的元素一一对应，例如，假设我们有一组病人的数据：           pop_size = 35  pre_treat = norm(loc=0, scale=1) n0 = pre_treat.rvs(size=pop_size)            经过某种治疗后，对这组病人得到一组新的数据：           effect = norm(loc=0.05, scale=0.2) eff = effect.rvs(size=pop_size)  n1 = n0 + eff            新数据的最大似然估计：           loc, scale = norm.fit(n1) post_treat = norm(loc=loc, scale=scale)            画图：           fig = figure(figsize=(10,4))  ax1 = fig.add_subplot(1,2,1) h = ax1.hist([n0, n1], normed=True) p = ax1.plot(x, pre_treat.pdf(x), 'b-') p = ax1.plot(x, post_treat.pdf(x), 'g-')  ax2 = fig.add_subplot(1,2,2) h = ax2.hist(eff, normed=True)                                      独立 t 检验：           t_val, p = ttest_ind(n0, n1)  print 't = {}'.format(t_val) print 'p-value = {}'.format(p)                        t = -0.347904839913 p-value = 0.728986322039                  高 p 值说明两组样本之间没有显著性差异。   配对 t 检验：           t_val, p = ttest_rel(n0, n1)  print 't = {}'.format(t_val) print 'p-value = {}'.format(p)                        t = -1.89564459709 p-value = 0.0665336223673                  配对 t 检验的结果说明，配对样本之间存在显著性差异，说明治疗时有效的，符合我们的预期。   p 值计算原理   p 值对应的部分是下图中的红色区域，边界范围由 t 值决定。           my_t = t(pop_size) # 传入参数为自由度，这里自由度为50  p = plot(x, my_t.pdf(x), 'b-') lower_x = x[x&lt;= -abs(t_val)] upper_x = x[x&gt;= abs(t_val)]  p = fill_between(lower_x, my_t.pdf(lower_x), color='red') p = fill_between(upper_x, my_t.pdf(upper_x), color='red')                                     ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/03.html",
        "teaser":null},{
        "title": "07-04 曲线拟合",
        
        "excerpt":
            "曲线拟合   导入基础包：           import numpy as np import matplotlib as mpl import matplotlib.pyplot as plt            多项式拟合   导入线多项式拟合工具：           from numpy import polyfit, poly1d            产生数据：           x = np.linspace(-5, 5, 100) y = 4 * x + 1.5 noise_y = y + np.random.randn(y.shape[-1]) * 2.5            画出数据：           %matplotlib inline  p = plt.plot(x, noise_y, 'rx') p = plt.plot(x, y, 'b:')                                      进行线性拟合，polyfit 是多项式拟合函数，线性拟合即一阶多项式：           coeff = polyfit(x, noise_y, 1) print coeff                        [ 3.93921315  1.59379469]                  一阶多项式 $y = a_1 x + a_0$ 拟合，返回两个系数 $[a_1, a_0]$。   画出拟合曲线：           p = plt.plot(x, noise_y, 'rx') p = plt.plot(x, coeff[0] * x + coeff[1], 'k-') p = plt.plot(x, y, 'b--')                                      还可以用 poly1d 生成一个以传入的 coeff 为参数的多项式函数：           f = poly1d(coeff) p = plt.plot(x, noise_y, 'rx') p = plt.plot(x, f(x))                                              f                         poly1d([ 3.93921315,  1.59379469])                   显示 f：           print f                          3.939 x + 1.594                  还可以对它进行数学操作生成新的多项式：           print f + 2 * f ** 2                               2 31.03 x + 29.05 x + 6.674                  多项式拟合正弦函数   正弦函数：           x = np.linspace(-np.pi,np.pi,100) y = np.sin(x)            用一阶到九阶多项式拟合，类似泰勒展开：           y1 = poly1d(polyfit(x,y,1)) y3 = poly1d(polyfit(x,y,3)) y5 = poly1d(polyfit(x,y,5)) y7 = poly1d(polyfit(x,y,7)) y9 = poly1d(polyfit(x,y,9))                    x = np.linspace(-3 * np.pi,3 * np.pi,100)  p = plt.plot(x, np.sin(x), 'k') p = plt.plot(x, y1(x)) p = plt.plot(x, y3(x)) p = plt.plot(x, y5(x)) p = plt.plot(x, y7(x)) p = plt.plot(x, y9(x))  a = plt.axis([-3 * np.pi, 3 * np.pi, -1.25, 1.25])                                      黑色为原始的图形，可以看到，随着多项式拟合的阶数的增加，曲线与拟合数据的吻合程度在逐渐增大。   最小二乘拟合   导入相关的模块：           from scipy.linalg import lstsq from scipy.stats import linregress                    x = np.linspace(0,5,100) y = 0.5 * x + np.random.randn(x.shape[-1]) * 0.35  plt.plot(x,y,'x')                         [&lt;matplotlib.lines.Line2D at 0xbc98518&gt;]                                             一般来书，当我们使用一个 N-1 阶的多项式拟合这 M 个点时，有这样的关系存在：     即     Scipy.linalg.lstsq 最小二乘解   要得到 C ，可以使用 scipy.linalg.lstsq 求最小二乘解。   这里，我们使用 1 阶多项式即 N = 2，先将 x 扩展成 X：           X = np.hstack((x[:,np.newaxis], np.ones((x.shape[-1],1)))) X[1:5]                         array([[ 0.05050505,  1.        ],        [ 0.1010101 ,  1.        ],        [ 0.15151515,  1.        ],        [ 0.2020202 ,  1.        ]])                   求解：           C, resid, rank, s = lstsq(X, y) C, resid, rank, s                         (array([ 0.50432002,  0.0415695 ]),  12.182942535066523,  2,  array([ 30.23732043,   4.82146667]))                   画图：           p = plt.plot(x, y, 'rx') p = plt.plot(x, C[0] * x + C[1], 'k--') print \"sum squared residual = {:.3f}\".format(resid) print \"rank of the X matrix = {}\".format(rank) print \"singular values of X = {}\".format(s)                        sum squared residual = 12.183 rank of the X matrix = 2 singular values of X = [ 30.23732043   4.82146667]                                            Scipy.stats.linregress 线性回归   对于上面的问题，还可以使用线性回归进行求解：           slope, intercept, r_value, p_value, stderr = linregress(x, y) slope, intercept                         (0.50432001884393252, 0.041569499438028901)                           p = plt.plot(x, y, 'rx') p = plt.plot(x, slope * x + intercept, 'k--') print \"R-value = {:.3f}\".format(r_value) print \"p-value (probability there is no correlation) = {:.3e}\".format(p_value) print \"Root mean squared error of the fit = {:.3f}\".format(np.sqrt(stderr))                        R-value = 0.903 p-value (probability there is no correlation) = 8.225e-38 Root mean squared error of the fit = 0.156                                            可以看到，两者求解的结果是一致的，但是出发的角度是不同的。   更高级的拟合           from scipy.optimize import leastsq            先定义这个非线性函数：$y = a e^{-b sin( f x + \\phi)}$           def function(x, a , b, f, phi):     \"\"\"a function of x with four parameters\"\"\"     result = a * np.exp(-b * np.sin(f * x + phi))     return result            画出原始曲线：           x = np.linspace(0, 2 * np.pi, 50) actual_parameters = [3, 2, 1.25, np.pi / 4] y = function(x, *actual_parameters) p = plt.plot(x,y)                                      加入噪声：           from scipy.stats import norm y_noisy = y + 0.8 * norm.rvs(size=len(x)) p = plt.plot(x, y, 'k-') p = plt.plot(x, y_noisy, 'rx')                                      Scipy.optimize.leastsq   定义误差函数，将要优化的参数放在前面：           def f_err(p, y, x):     return y - function(x, *p)            将这个函数作为参数传入 leastsq 函数，第二个参数为初始值：           c, ret_val = leastsq(f_err, [1, 1, 1, 1], args=(y_noisy, x)) c, ret_val                         (array([ 3.03199715,  1.97689384,  1.30083191,  0.6393337 ]), 1)                   ret_val 是 1~4 时，表示成功找到最小二乘解：           p = plt.plot(x, y_noisy, 'rx') p = plt.plot(x, function(x, *c), 'k--')                                      Scipy.optimize.curve_fit   更高级的做法：           from scipy.optimize import curve_fit            不需要定义误差函数，直接传入 function 作为参数：           p_est, err_est = curve_fit(function, x, y_noisy)                    print p_est p = plt.plot(x, y_noisy, \"rx\") p = plt.plot(x, function(x, *p_est), \"k--\")                        [ 3.03199711  1.97689385  1.3008319   0.63933373]                                            这里第一个返回的是函数的参数，第二个返回值为各个参数的协方差矩阵：           print err_est                        [[ 0.08483704 -0.02782318  0.00967093 -0.03029038]  [-0.02782318  0.00933216 -0.00305158  0.00955794]  [ 0.00967093 -0.00305158  0.0014972  -0.00468919]  [-0.03029038  0.00955794 -0.00468919  0.01484297]]                  协方差矩阵的对角线为各个参数的方差：           print \"normalized relative errors for each parameter\" print \"   a\\t  b\\t f\\tphi\" print np.sqrt(err_est.diagonal()) / p_est                        normalized relative errors for each parameter    a\t  b\t f\tphi [ 0.09606473  0.0488661   0.02974528  0.19056043]                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/04.html",
        "teaser":null},{
        "title": "07-05 最小化函数",
        
        "excerpt":
            "最小化函数 minimize 函数 %pylab inline set_printoptions(precision=3, suppress=True) Populating the interactive namespace from numpy and matplotlib 已知斜抛运动的水平飞行距离公式： $d = 2 \\frac{v_0^2}{g} \\sin(\\theta) \\cos (\\theta)$ $d$ 水平飞行距离 $v_0$ 初速度大小 $g$ 重力加速度 $\\theta$ 抛出角度 希望找到使 $d$ 最大的角度 $\\theta$。 定义距离函数： def dist(theta, v0): \"\"\"calculate the distance travelled by a projectile launched at theta degrees with v0 (m/s) initial velocity. \"\"\" g = 9.8 theta_rad = pi * theta / 180 return 2 * v0 ** 2 / g * sin(theta_rad) * cos(theta_rad) theta = linspace(0,90,90) p = plot(theta, dist(theta, 1.)) xl = xlabel(r'launch angle $\\theta (^{\\circ})$') yl = ylabel('horizontal distance traveled') 因为 Scipy 提供的是最小化方法，所以最大化距离就相当于最小化距离的负数： def neg_dist(theta, v0): return -1 * dist(theta, v0) 导入 scipy.optimize.minimize： from scipy.optimize import minimize result = minimize(neg_dist, 40, args=(1,)) print \"optimal angle = {:.1f} degrees\".format(result.x[0]) optimal angle = 45.0 degrees minimize 接受三个参数：第一个是要优化的函数，第二个是初始猜测值，第三个则是优化函数的附加参数，默认 minimize 将优化函数的第一个参数作为优化变量，所以第三个参数输入的附加参数从优化函数的第二个参数开始。 查看返回结果： print result status: 0 success: True njev: 18 nfev: 54 hess_inv: array([[ 8110.515]]) fun: -0.10204079220645729 x: array([ 45.02]) message: 'Optimization terminated successfully.' jac: array([ 0.]) Rosenbrock 函数 Rosenbrock 函数是一个用来测试优化函数效果的一个非凸函数： $f(x)=\\sum\\limits_{i=1}^{N-1}{100\\left(x_{i+1}^2 - x_i\\right) ^2 + \\left(1-x_{i}\\right)^2 }$ 导入该函数： from scipy.optimize import rosen from mpl_toolkits.mplot3d import Axes3D 使用 N = 2 的 Rosenbrock 函数： x, y = meshgrid(np.linspace(-2,2,25), np.linspace(-0.5,3.5,25)) z = rosen([x,y]) 图像和最低点 (1,1)： fig = figure(figsize=(12,5.5)) ax = fig.gca(projection=\"3d\") ax.azim = 70; ax.elev = 48 ax.set_xlabel(\"X\"); ax.set_ylabel(\"Y\") ax.set_zlim((0,1000)) p = ax.plot_surface(x,y,z,rstride=1, cstride=1, cmap=cm.jet) rosen_min = ax.plot([1],[1],[0],\"ro\") 传入初始值： x0 = [1.3, 1.6, -0.5, -1.8, 0.8] result = minimize(rosen, x0) print result.x [ 1. 1. 1. 1. 1.] 随机给定初始值： x0 = np.random.randn(10) result = minimize(rosen, x0) print x0 print result.x [ 0.815 -2.086 0.297 1.079 -0.528 0.461 -0.13 -0.715 0.734 0.621] [-0.993 0.997 0.998 0.999 0.999 0.999 0.998 0.997 0.994 0.988] 对于 N &gt; 3，函数的最小值为 $(x_1,x_2, …, x_N) = (1,1,…,1)$，不过有一个局部极小值点 $(x_1,x_2, …, x_N) = (-1,1,…,1)$，所以随机初始值如果选的不好的话，有可能返回的结果是局部极小值点： 优化方法 BFGS 算法 minimize 函数默认根据问题是否有界或者有约束，使用 'BFGS', 'L-BFGS-B', 'SLSQP' 中的一种。 可以查看帮助来得到更多的信息： info(minimize) minimize(fun, x0, args=(), method=None, jac=None, hess=None, hessp=None, bounds=None, constraints=(), tol=None, callback=None, options=None) Minimization of scalar function of one or more variables. Parameters ---------- fun : callable Objective function. x0 : ndarray Initial guess. args : tuple, optional Extra arguments passed to the objective function and its derivatives (Jacobian, Hessian). method : str or callable, optional Type of solver. Should be one of - 'Nelder-Mead' - 'Powell' - 'CG' - 'BFGS' - 'Newton-CG' - 'Anneal (deprecated as of scipy version 0.14.0)' - 'L-BFGS-B' - 'TNC' - 'COBYLA' - 'SLSQP' - 'dogleg' - 'trust-ncg' - custom - a callable object (added in version 0.14.0) If not given, chosen to be one of ``BFGS``, ``L-BFGS-B``, ``SLSQP``, depending if the problem has constraints or bounds. jac : bool or callable, optional Jacobian (gradient) of objective function. Only for CG, BFGS, Newton-CG, L-BFGS-B, TNC, SLSQP, dogleg, trust-ncg. If `jac` is a Boolean and is True, `fun` is assumed to return the gradient along with the objective function. If False, the gradient will be estimated numerically. `jac` can also be a callable returning the gradient of the objective. In this case, it must accept the same arguments as `fun`. hess, hessp : callable, optional Hessian (matrix of second-order derivatives) of objective function or Hessian of objective function times an arbitrary vector p. Only for Newton-CG, dogleg, trust-ncg. Only one of `hessp` or `hess` needs to be given. If `hess` is provided, then `hessp` will be ignored. If neither `hess` nor `hessp` is provided, then the Hessian product will be approximated using finite differences on `jac`. `hessp` must compute the Hessian times an arbitrary vector. bounds : sequence, optional Bounds for variables (only for L-BFGS-B, TNC and SLSQP). ``(min, max)`` pairs for each element in ``x``, defining the bounds on that parameter. Use None for one of ``min`` or ``max`` when there is no bound in that direction. constraints : dict or sequence of dict, optional Constraints definition (only for COBYLA and SLSQP). Each constraint is defined in a dictionary with fields: type : str Constraint type: 'eq' for equality, 'ineq' for inequality. fun : callable The function defining the constraint. jac : callable, optional The Jacobian of `fun` (only for SLSQP). args : sequence, optional Extra arguments to be passed to the function and Jacobian. Equality constraint means that the constraint function result is to be zero whereas inequality means that it is to be non-negative. Note that COBYLA only supports inequality constraints. tol : float, optional Tolerance for termination. For detailed control, use solver-specific options. options : dict, optional A dictionary of solver options. All methods accept the following generic options: maxiter : int Maximum number of iterations to perform. disp : bool Set to True to print convergence messages. For method-specific options, see :func:`show_options()`. callback : callable, optional Called after each iteration, as ``callback(xk)``, where ``xk`` is the current parameter vector. Returns ------- res : OptimizeResult The optimization result represented as a ``OptimizeResult`` object. Important attributes are: ``x`` the solution array, ``success`` a Boolean flag indicating if the optimizer exited successfully and ``message`` which describes the cause of the termination. See `OptimizeResult` for a description of other attributes. See also -------- minimize_scalar : Interface to minimization algorithms for scalar univariate functions show_options : Additional options accepted by the solvers Notes ----- This section describes the available solvers that can be selected by the 'method' parameter. The default method is *BFGS*. **Unconstrained minimization** Method *Nelder-Mead* uses the Simplex algorithm [1]_, [2]_. This algorithm has been successful in many applications but other algorithms using the first and/or second derivatives information might be preferred for their better performances and robustness in general. Method *Powell* is a modification of Powell's method [3]_, [4]_ which is a conjugate direction method. It performs sequential one-dimensional minimizations along each vector of the directions set (`direc` field in `options` and `info`), which is updated at each iteration of the main minimization loop. The function need not be differentiable, and no derivatives are taken. Method *CG* uses a nonlinear conjugate gradient algorithm by Polak and Ribiere, a variant of the Fletcher-Reeves method described in [5]_ pp. 120-122. Only the first derivatives are used. Method *BFGS* uses the quasi-Newton method of Broyden, Fletcher, Goldfarb, and Shanno...",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/05.html",
        "teaser":null},{
        "title": "07-06 积分",
        
        "excerpt":
            "积分 符号积分 积分与求导的关系： 符号运算可以用 sympy 模块完成。 先导入 init_printing 模块方便其显示： from sympy import init_printing init_printing() from sympy import symbols, integrate import sympy 产生 x 和 y 两个符号变量，并进行运算： x, y = symbols('x y') sympy.sqrt(x ** 2 + y ** 2) 对于生成的符号变量 z，我们将其中的 x 利用 subs 方法替换为 3： z = sympy.sqrt(x ** 2 + y ** 2) z.subs(x, 3) 再替换 y： z.subs(x, 3).subs(y, 4) 还可以从 sympy.abc 中导入现成的符号变量： from sympy.abc import theta y = sympy.sin(theta) ** 2 y 对 y 进行积分： Y = integrate(y) Y 计算 $Y(\\pi) - Y(0)$： import numpy as np np.set_printoptions(precision=3) Y.subs(theta, np.pi) - Y.subs(theta, 0) 计算 $\\int_0^\\pi y d\\theta$ ： integrate(y, (theta, 0, sympy.pi)) 显示的是字符表达式，查看具体数值可以使用 evalf() 方法，或者传入 numpy.pi，而不是 sympy.pi ： integrate(y, (theta, 0, sympy.pi)).evalf() integrate(y, (theta, 0, np.pi)) 根据牛顿莱布尼兹公式，这两个数值应该相等。 产生不定积分对象： Y_indef = sympy.Integral(y) Y_indef print type(Y_indef) &lt;class 'sympy.integrals.integrals.Integral'&gt; 定积分： Y_def = sympy.Integral(y, (theta, 0, sympy.pi)) Y_def 产生函数 $Y(x) = \\int_0^x sin^2(\\theta) d\\theta$，并将其向量化： Y_raw = lambda x: integrate(y, (theta, 0, x)) Y = np.vectorize(Y_raw) %matplotlib inline import matplotlib.pyplot as plt x = np.linspace(0, 2 * np.pi) p = plt.plot(x, Y(x)) t = plt.title(r'$Y(x) = \\int_0^x sin^2(\\theta) d\\theta$') 数值积分 数值积分： 导入贝塞尔函数： from scipy.special import jv def f(x): return jv(2.5, x) x = np.linspace(0, 10) p = plt.plot(x, f(x), 'k-') quad 函数 Quadrature 积分的原理参见： http://en.wikipedia.org/wiki/Numerical_integration#Quadrature_rules_based_on_interpolating_functions quad 返回一个 (积分值，误差) 组成的元组： from scipy.integrate import quad interval = [0, 6.5] value, max_err = quad(f, *interval) 积分值： print value 1.28474297234 最大误差： print max_err 2.34181853668e-09 积分区间图示，蓝色为正，红色为负： print \"integral = {:.9f}\".format(value) print \"upper bound on error: {:.2e}\".format(max_err) x = np.linspace(0, 10, 100) p = plt.plot(x, f(x), 'k-') x = np.linspace(0, 6.5, 45) p = plt.fill_between(x, f(x), where=f(x)&gt;0, color=\"blue\") p = plt.fill_between(x, f(x), where=f(x)&lt;0, color=\"red\", interpolate=True) integral = 1.284742972 upper bound on error: 2.34e-09 积分到无穷 from numpy import inf interval = [0., inf] def g(x): return np.exp(-x ** 1/2) value, max_err = quad(g, *interval) x = np.linspace(0, 10, 50) fig = plt.figure(figsize=(10,3)) p = plt.plot(x, g(x), 'k-') p = plt.fill_between(x, g(x)) plt.annotate(r\"$\\int_0^{\\infty}e^{-x^1/2}dx = $\" + \"{}\".format(value), (4, 0.6), fontsize=16) print \"upper bound on error: {:.1e}\".format(max_err) upper bound on error: 7.2e-11 双重积分 假设我们要进行如下的积分： def h(x, t, n): \"\"\"core function, takes x, t, n\"\"\" return np.exp(-x * t) / (t ** n) 一种方式是调用两次 quad 函数，不过这里 quad 的返回值不能向量化，所以使用了修饰符 vectorize 将其向量化： from numpy import vectorize @vectorize def int_h_dx(t, n): \"\"\"Time integrand of h(x).\"\"\" return quad(h, 0, np.inf, args=(t, n))[0] @vectorize def I_n(n): return quad(int_h_dx, 1, np.inf, args=(n)) I_n([0.5, 1.0, 2.0, 5]) (array([ 1.97, 1. , 0.5 , 0.2 ]), array([ 9.804e-13, 1.110e-14, 5.551e-15, 2.220e-15])) 或者直接调用 dblquad 函数，并将积分参数传入，传入方式有多种，后传入的先进行积分： from scipy.integrate import dblquad @vectorize def I(n): \"\"\"Same as I_n, but using the built-in dblquad\"\"\" x_lower = 0 x_upper = np.inf return dblquad(h, lambda t_lower: 1, lambda t_upper: np.inf, x_lower, x_upper, args=(n,)) I_n([0.5, 1.0, 2.0, 5]) (array([ 1.97, 1. , 0.5 , 0.2 ]), array([ 9.804e-13, 1.110e-14, 5.551e-15, 2.220e-15])) 采样点积分 trapz 方法 和 simps 方法 from scipy.integrate import trapz, simps sin 函数， 100 个采样点和 5 个采样点： x_s = np.linspace(0, np.pi, 5) y_s = np.sin(x_s) x = np.linspace(0, np.pi, 100) y = np.sin(x) p = plt.plot(x, y, 'k:') p = plt.plot(x_s, y_s, 'k+-') p = plt.fill_between(x_s, y_s, color=\"gray\") 采用 trapezoidal 方法 和 simpson 方法 对这些采样点进行积分（函数积分为 2）： result_s = trapz(y_s, x_s) result_s_s = simps(y_s, x_s) result = trapz(y, x) print \"Trapezoidal Integration over 5 points : {:.3f}\".format(result_s) print \"Simpson Integration over 5 points : {:.3f}\".format(result_s_s) print \"Trapezoidal Integration over 100 points : {:.3f}\".format(result) Trapezoidal Integration over 5 points : 1.896 Simpson Integration over 5 points : 2.005 Trapezoidal Integration over 100 points : 2.000 使用 ufunc 进行积分 Numpy 中有很多 ufunc 对象： type(np.add) numpy.ufunc np.info(np.add.accumulate) accumulate(array, axis=0, dtype=None, out=None) Accumulate the result of applying the operator to all elements. For a one-dimensional array, accumulate produces results equivalent to:: r = np.empty(len(A)) t = op.identity # op = the ufunc being applied to A's elements for i in range(len(A)): t = op(t, A[i]) r[i] = t return r For example, add.accumulate() is equivalent to np.cumsum(). For a multi-dimensional array, accumulate is applied along only one axis (axis zero by default; see Examples below) so repeated use is necessary if one wants to accumulate over multiple axes. Parameters ---------- array : array_like The array to act on. axis : int, optional The axis along which to apply the accumulation; default is zero. dtype : data-type code, optional The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided. out : ndarray, optional A location into which the result is stored. If not provided a freshly-allocated array is returned. Returns ------- r : ndarray The accumulated values. If `out` was supplied, `r` is a reference to `out`. Examples -------- 1-D array examples: &gt;&gt;&gt; np.add.accumulate([2, 3, 5]) array([ 2, 5, 10]) &gt;&gt;&gt; np.multiply.accumulate([2, 3, 5]) array([ 2, 6, 30]) 2-D array examples: &gt;&gt;&gt; I = np.eye(2) &gt;&gt;&gt; I array([[ 1., 0.], [ 0., 1.]]) Accumulate along axis 0 (rows), down columns: &gt;&gt;&gt; np.add.accumulate(I, 0) array([[ 1., 0.], [ 1., 1.]]) &gt;&gt;&gt; np.add.accumulate(I) # no axis specified = axis zero array([[ 1., 0.], [ 1., 1.]]) Accumulate along axis 1 (columns), through rows: &gt;&gt;&gt; np.add.accumulate(I, 1) array([[ 1., 1.], [ 0., 1.]]) np.add.accumulate 相当于 cumsum ： result_np = np.add.accumulate(y) * (x[1] - x[0]) - (x[1] - x[0]) / 2 p = plt.plot(x, - np.cos(x) + np.cos(0), 'rx') p = plt.plot(x, result_np) 速度比较 计算积分： import sympy from sympy.abc import x, theta sympy_x = x x = np.linspace(0, 20 * np.pi, 1e+4) y = np.sin(x) sympy_y = vectorize(lambda x: sympy.integrate(sympy.sin(theta), (theta, 0, x))) numpy 方法： %timeit np.add.accumulate(y) * (x[1] - x[0]) y0 = np.add.accumulate(y) * (x[1] - x[0]) print y0[-1] The slowest run took 4.32 times longer than the fastest. This could mean that an intermediate result is being cached 10000 loops, best of 3: 56.2 µs per loop -2.34138044756e-17 quad 方法： %timeit quad(np.sin, 0, 20 * np.pi) y2 = quad(np.sin, 0, 20 * np.pi, full_output=True) print \"result = \", y2[0] print \"number of evaluations\", y2[-1]['neval'] 10000 loops, best of 3: 40.5 µs per loop result = 3.43781337153e-15 number of evaluations 21 trapz 方法：...",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/06.html",
        "teaser":null},{
        "title": "07-07 解微分方程",
        
        "excerpt":
            "解微分方程           %pylab inline                        Populating the interactive namespace from numpy and matplotlib                  积分求解   简单的例子             def dy_dt(y, t):     return np.sin(t)            积分求解：           from scipy.integrate import odeint  t = np.linspace(0, 2*pi, 100)  result = odeint(dy_dt, 0, t)                    fig = figure(figsize=(12,4)) p = plot(t, result, \"rx\", label=r\"$\\int_{0}^{x}sin(t) dt $\") p = plot(t, -cos(t) + cos(0), label=r\"$cos(0) - cos(t)$\") p = plot(t, dy_dt(0, t), \"g-\", label=r\"$\\frac{dy}{dt}(t)$\") l = legend(loc=\"upper right\") xl = xlabel(\"t\")                                      高阶微分方程   抛物运动（竖直方向）：     改写成如下形式：               def dy_dt(y, t):     \"\"\"Governing equations for projectile motion with drag.     y[0] = position     y[1] = velocity     g = gravity (m/s2)     D = drag (1/s) = force/velocity     m = mass (kg)     \"\"\"     g = -9.8     D = 0.1     m = 0.15     dy1 = g - (D/m) * y[1]     dy0 = y[1] if y[0] &gt;= 0 else 0.     return [dy0, dy1]                    position_0 = 0. velocity_0 = 100 t = linspace(0, 12, 100) y = odeint(dy_dt, [position_0, velocity_0], t)                    p = plot(t, y[:,0]) yl = ylabel(\"Height (m)\") xl = xlabel(\"Time (s)\")                                              y, infodict = odeint(dy_dt, [position_0, velocity_0], t, full_output=True, printmessg=True, ) print sorted(infodict.keys()) print \"cumulative number of function evaluations at each calculated point:\", infodict['nfe'] print \"cumulative number of time steps\", infodict['nst']                        Integration successful. ['hu', 'imxer', 'leniw', 'lenrw', 'message', 'mused', 'nfe', 'nje', 'nqu', 'nst', 'tcur', 'tolsf', 'tsw'] cumulative number of function evaluations at each calculated point: [ 45  49  51  53  55  59  61  61  63  65  67  67  69  71  73  73  75  77   77  79  79  81  81  83  85  85  87  87  89  89  91  91  93  95  95  97   97  99  99 101 101 103 103 105 107 107 109 109 111 111 113 113 115 115  117 117 119 119 121 121 123 123 123 125 125 127 127 129 129 131 131 131  133 133 135 135 135 137 137 139 139 139 141 141 143 143 143 145 145 147  147 149 149 149 154 158 274 280 280] cumulative number of time steps [ 20  22  23  24  25  27  28  28  29  30  31  31  32  33  34  34  35  36   36  37  37  38  38  39  40  40  41  41  42  42  43  43  44  45  45  46   46  47  47  48  48  49  49  50  51  51  52  52  53  53  54  54  55  55   56  56  57  57  58  58  59  59  59  60  60  61  61  62  62  63  63  63   64  64  65  65  65  66  66  67  67  67  68  68  69  69  69  70  70  71   71  72  72  72  73  75 130 133 133]                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/07.html",
        "teaser":null},{
        "title": "07-08 稀疏矩阵",
        
        "excerpt":
            "稀疏矩阵   Scipy 提供了稀疏矩阵的支持（scipy.sparse）。   稀疏矩阵主要使用 位置 + 值 的方法来存储矩阵的非零元素，根据存储和使用方式的不同，有如下几种类型的稀疏矩阵：                  类型       描述                       bsr_matrix(arg1[, shape, dtype, copy, blocksize])       Block Sparse Row matrix                 coo_matrix(arg1[, shape, dtype, copy])       A sparse matrix in COOrdinate format.                 csc_matrix(arg1[, shape, dtype, copy])       Compressed Sparse Column matrix                 csr_matrix(arg1[, shape, dtype, copy])       Compressed Sparse Row matrix                 dia_matrix(arg1[, shape, dtype, copy])       Sparse matrix with DIAgonal storage                 dok_matrix(arg1[, shape, dtype, copy])       Dictionary Of Keys based sparse matrix.                 lil_matrix(arg1[, shape, dtype, copy])       Row-based linked list sparse matrix           在这些存储格式中：      COO 格式在构建矩阵时比较高效   CSC 和 CSR 格式在乘法计算时比较高效   构建稀疏矩阵           from scipy.sparse import * import numpy as np            创建一个空的稀疏矩阵：           coo_matrix((2,3))                         &lt;2x3 sparse matrix of type '&lt;type 'numpy.float64'&gt;' \twith 0 stored elements in COOrdinate format&gt;                   也可以使用一个已有的矩阵或数组或列表中创建新矩阵：           A = coo_matrix([[1,2,0],[0,0,3],[4,0,5]]) print A                          (0, 0)\t1   (0, 1)\t2   (1, 2)\t3   (2, 0)\t4   (2, 2)\t5                  不同格式的稀疏矩阵可以相互转化：           type(A)                         scipy.sparse.coo.coo_matrix                           B = A.tocsr() type(B)                         scipy.sparse.csr.csr_matrix                   可以转化为普通矩阵：           C = A.todense() C                         matrix([[1, 2, 0],         [0, 0, 3],         [4, 0, 5]])                   与向量的乘法：           v = np.array([1,0,-1]) A.dot(v)                         array([ 1, -3, -1])                   还可以传入一个 (data, (row, col)) 的元组来构建稀疏矩阵：           I = np.array([0,3,1,0]) J = np.array([0,3,1,2]) V = np.array([4,5,7,9]) A = coo_matrix((V,(I,J)),shape=(4,4))                    print A                          (0, 0)\t4   (3, 3)\t5   (1, 1)\t7   (0, 2)\t9                  COO 格式的稀疏矩阵在构建的时候只是简单的将坐标和值加到后面，对于重复的坐标不进行处理：           I = np.array([0,0,1,3,1,0,0]) J = np.array([0,2,1,3,1,0,0]) V = np.array([1,1,1,1,1,1,1]) B = coo_matrix((V,(I,J)),shape=(4,4)) print B                          (0, 0)\t1   (0, 2)\t1   (1, 1)\t1   (3, 3)\t1   (1, 1)\t1   (0, 0)\t1   (0, 0)\t1                  转换成 CSR 格式会自动将相同坐标的值合并：           C = B.tocsr() print C                          (0, 0)\t3   (0, 2)\t1   (1, 1)\t2   (3, 3)\t1                  求解微分方程           from scipy.sparse import lil_matrix from scipy.sparse.linalg import spsolve from numpy.linalg import solve, norm from numpy.random import rand            构建 1000 x 1000 的稀疏矩阵：           A = lil_matrix((1000, 1000)) A[0, :100] = rand(100) A[1, 100:200] = A[0, :100] A.setdiag(rand(1000))            转化为 CSR 之后，用 spsolve 求解 $Ax=b$：           A = A.tocsr() b = rand(1000) x = spsolve(A, b)            转化成正常数组之后求解：           x_ = solve(A.toarray(), b)            查看误差：           err = norm(x-x_) err                         6.4310987107687431e-13                   sparse.find 函数   返回一个三元组，表示稀疏矩阵中非零元素的 (row, col, value)：           from scipy import sparse  row, col, val = sparse.find(C) print row, col, val                        [0 0 1 3] [0 2 1 3] [3 1 2 1]                  sparse.issparse 函数   查看一个对象是否为稀疏矩阵：           sparse.issparse(B)                         True                   或者           sparse.isspmatrix(B.todense())                         False                   还可以查询是否为指定格式的稀疏矩阵：           sparse.isspmatrix_coo(B)                         True                           sparse.isspmatrix_csr(B)                         False                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/08.html",
        "teaser":null},{
        "title": "07-09 线性代数",
        
        "excerpt":
            "线性代数 numpy 和 scipy 中，负责进行线性代数部分计算的模块叫做 linalg。 import numpy as np import numpy.linalg import scipy as sp import scipy.linalg import matplotlib.pyplot as plt from scipy import linalg %matplotlib inline numpy.linalg VS scipy.linalg 一方面scipy.linalg 包含 numpy.linalg 中的所有函数，同时还包含了很多 numpy.linalg 中没有的函数。 另一方面，scipy.linalg 能够保证这些函数使用 BLAS/LAPACK 加速，而 numpy.linalg 中这些加速是可选的。 因此，在使用时，我们一般使用 scipy.linalg 而不是 numpy.linalg。 我们可以简单看看两个模块的差异： print \"number of items in numpy.linalg:\", len(dir(numpy.linalg)) print \"number of items in scipy.linalg:\", len(dir(scipy.linalg)) number of items in numpy.linalg: 36 number of items in scipy.linalg: 115 numpy.matrix VS 2D numpy.ndarray 线性代数的基本操作对象是矩阵，而矩阵的表示方法主要有两种：numpy.matrix 和 2D numpy.ndarray。 numpy.matrix numpy.matrix 是一个矩阵类，提供了一些方便的矩阵操作： 支持类似 MATLAB 创建矩阵的语法 矩阵乘法默认用 * 号 .I 表示逆，.T 表示转置 可以用 mat 或者 matrix 来产生矩阵： A = np.mat(\"[1, 2; 3, 4]\") print repr(A) A = np.matrix(\"[1, 2; 3, 4]\") print repr(A) matrix([[1, 2], [3, 4]]) matrix([[1, 2], [3, 4]]) 转置和逆： print repr(A.I) print repr(A.T) matrix([[-2. , 1. ], [ 1.5, -0.5]]) matrix([[1, 3], [2, 4]]) 矩阵乘法： b = np.mat('[5; 6]') print repr(A * b) matrix([[17], [39]]) 2 维 numpy.ndarray 虽然 numpy.matrix 有着上面的好处，但是一般不建议使用，而是用 2 维 numpy.ndarray 对象替代，这样可以避免一些不必要的困惑。 我们可以使用 array 复现上面的操作： A = np.array([[1,2], [3,4]]) print repr(A) array([[1, 2], [3, 4]]) 逆和转置： print repr(linalg.inv(A)) print repr(A.T) array([[-2. , 1. ], [ 1.5, -0.5]]) array([[1, 3], [2, 4]]) 矩阵乘法： b = np.array([5, 6]) print repr(A.dot(b)) array([17, 39]) 普通乘法： print repr(A * b) array([[ 5, 12], [15, 24]]) scipy.linalg 的操作可以作用到两种类型的对象上，没有区别。 基本操作 求逆 矩阵 $\\mathbf{A}$ 的逆 $\\mathbf{B}$ 满足：$\\mathbf{BA}=\\mathbf{AB}=I$，记作 $\\mathbf{B} = \\mathbf{A}^{-1}$。 事实上，我们已经见过求逆的操作，linalg.inv 可以求一个可逆矩阵的逆： A = np.array([[1,2],[3,4]]) print linalg.inv(A) print A.dot(scipy.linalg.inv(A)) [[-2. 1. ] [ 1.5 -0.5]] [[ 1.00000000e+00 0.00000000e+00] [ 8.88178420e-16 1.00000000e+00]] 求解线性方程组 例如，下列方程组 的解为： 我们可以使用 linalg.solve 求解方程组，也可以先求逆再相乘，两者中 solve 比较快。 import time A = np.array([[1, 3, 5], [2, 5, 1], [2, 3, 8]]) b = np.array([10, 8, 3]) tic = time.time() for i in xrange(1000): x = linalg.inv(A).dot(b) print x print A.dot(x)-b print \"inv and dot: {} s\".format(time.time() - tic) tic = time.time() for i in xrange(1000): x = linalg.solve(A, b) print x print A.dot(x)-b print \"solve: {} s\".format(time.time() - tic) [-9.28 5.16 0.76] [ 0.00000000e+00 -1.77635684e-15 -8.88178420e-16] inv and dot: 0.0353579521179 s [-9.28 5.16 0.76] [ 0.00000000e+00 -1.77635684e-15 -1.77635684e-15] solve: 0.0284671783447 s 计算行列式 方阵的行列式为 其中 $a_{ij}$ 表示 $\\mathbf{A}$ 的第 $i$ 行 第 $j$ 列的元素，$M_{ij}$ 表示矩阵 $\\mathbf{A}$ 去掉第 $i$ 行 第 $j$ 列的新矩阵的行列式。 例如，矩阵 的行列式是： 可以用 linalg.det 计算行列式： A = np.array([[1, 3, 5], [2, 5, 1], [2, 3, 8]]) print linalg.det(A) -25.0 计算矩阵或向量的模 矩阵的模定义如下： 其中，$\\sigma_i$ 是矩阵的奇异值。 向量的模定义如下： linalg.norm 可以计算向量或者矩阵的模： A = np.array([[1, 2], [3, 4]]) print linalg.norm(A) print linalg.norm(A,'fro') # frobenius norm 默认值 print linalg.norm(A,1) # L1 norm 最大列和 print linalg.norm(A,-1) # L -1 norm 最小列和 print linalg.norm(A,np.inf) # L inf norm 最大行和 5.47722557505 5.47722557505 6 4 7 最小二乘解和伪逆 问题描述 所谓最小二乘问题的定义如下： 假设 $y_i$ 与 $\\mathbf{x_i}$ 的关系可以用一组系数 $c_j$ 和对应的模型函数 $f_j(\\mathbf{x_i})$ 的模型表示： 其中 $\\epsilon_i$ 表示数据的不确定性。最小二乘就是要优化这样一个关于 $c_j$ 的问题： 其理论解满足： 改写为： 其中： 当 $\\mathbf{A^HA}$ 可逆时，我们有： 矩阵 $\\mathbf{A}^{\\dagger}$ 叫做 $\\mathbf{A}$ 的伪逆。 问题求解 注意到，我们的模型可以写为： 在给定 $\\mathbf{y}$ 和 $\\mathbf{A}$ 的情况下，我们可以使用 linalg.lstsq 求解 $\\mathbf c$。 在给定 $\\mathbf{A}$ 的情况下，我们可以使用 linalg.pinv 或者 linalg.pinv2 求解 $\\mathbf{A}^{\\dagger}$。 例子 假设我们的数据满足： 其中 $x_i = \\frac{i}{10},\\ i = 1,\\dots,10$，$c_1 = 5, c_2 = 2$，产生数据 c1, c2 = 5.0, 2.0 i = np.r_[1:11] xi = 0.1*i yi = c1*np.exp(-xi) + c2*xi zi = yi + 0.05 * np.max(yi) * np.random.randn(len(yi)) 构造矩阵 $\\mathbf A$： A = np.c_[np.exp(-xi)[:, np.newaxis], xi[:, np.newaxis]] print A [[ 0.90483742 0.1 ] [ 0.81873075 0.2 ] [ 0.74081822 0.3 ] [ 0.67032005 0.4 ] [ 0.60653066 0.5 ] [ 0.54881164 0.6 ] [ 0.4965853 0.7 ] [ 0.44932896 0.8 ] [ 0.40656966 0.9 ] [ 0.36787944 1. ]] 求解最小二乘问题： c, resid, rank, sigma = linalg.lstsq(A, zi) print c [ 4.87016856 2.19081311] 其中 c 的形状与 zi 一致，为最小二乘解，resid 为 zi - A c 每一列差值的二范数，rank 为矩阵 A 的秩，sigma 为矩阵 A 的奇异值。 查看拟合效果： xi2 = np.r_[0.1:1.0:100j] yi2 = c[0]*np.exp(-xi2) + c[1]*xi2 plt.plot(xi,zi,'x',xi2,yi2) plt.axis([0,1.1,3.0,5.5]) plt.xlabel('$x_i$') plt.title('Data fitting with linalg.lstsq') plt.show() 广义逆 linalg.pinv 或 linalg.pinv2 可以用来求广义逆，其区别在于前者使用求最小二乘解的算法，后者使用求奇异值的算法求解。 矩阵分解 特征值和特征向量 问题描述 对于给定的 $N \\times N$ 矩阵 $\\mathbf A$，特征值和特征向量问题相当与寻找标量 $\\lambda$ 和对应的向量 $\\mathbf v$ 使得： 矩阵的 $N$ 个特征值（可能相同）可以通过计算特征方程的根得到： 然后利用这些特征值求（归一化的）特征向量。 问题求解 linalg.eig(A) 返回矩阵的特征值与特征向量 linalg.eigvals(A) 返回矩阵的特征值 linalg.eig(A, B) 求解 $\\mathbf{Av} = \\lambda\\mathbf{Bv}$ 的问题 例子 矩阵为 特征多项式为： 特征根为： A = np.array([[1, 5, 2], [2, 4, 1], [3, 6, 2]]) la, v = linalg.eig(A) print la # 验证是否归一化 print np.sum(abs(v**2),axis=0) # 第一个特征值 l1 = la[0] # 对应的特征向量 v1 = v[:, 0].T # 验证是否为特征值和特征向量对 print linalg.norm(A.dot(v1)-l1*v1) [ 7.95791620+0.j -1.25766471+0.j 0.29974850+0.j] [ 1. 1. 1.] 3.23301824835e-15 奇异值分解 问题描述 $M \\times N$ 矩阵 $\\mathbf A$ 的奇异值分解为： 其中 $\\boldsymbol{\\Sigma}, (M \\times N)$ 只有对角线上的元素不为 0，$\\mathbf U, (M \\times M)$ 和 $\\mathbf V, (N \\times N)$ 为正交矩阵。 其具体原理可以查看维基百科： https://en.wikipedia.org/wiki/Singular_value_decomposition 问题求解 U,s,Vh = linalg.svd(A) 返回 $U$ 矩阵，奇异值 $s$，$V^H$ 矩阵 Sig = linalg.diagsvd(s,M,N) 从奇异值恢复 $\\boldsymbol{\\Sigma}$ 矩阵 例子 奇异值分解： A = np.array([[1,2,3],[4,5,6]]) U, s, Vh = linalg.svd(A) $\\boldsymbol{\\Sigma}$ 矩阵： M, N = A.shape Sig = linalg.diagsvd(s,M,N) print Sig [[ 9.508032 0. 0. ] [ 0. 0.77286964 0. ]] 检查正确性： print A print U.dot(Sig.dot(Vh)) [[1 2 3] [4 5 6]] [[ 1. 2. 3.] [ 4. 5. 6.]] LU 分解 $M \\times N$ 矩阵 $\\mathbf A$ 的 LU 分解为： $\\mathbf P$ 是 $M \\times M$ 的单位矩阵的一个排列，$\\mathbf L$ 是下三角阵，$\\mathbf U$ 是上三角阵。 可以使用 linalg.lu 进行 LU 分解的求解： 具体原理可以查看维基百科： https://en.wikipedia.org/wiki/LU_decomposition A = np.array([[1,2,3],[4,5,6]]) P, L, U = linalg.lu(A) print P print L print U print P.dot(L).dot(U) [[ 0. 1.] [ 1. 0.]] [[ 1. 0. ] [ 0.25 1. ]] [[ 4. 5. 6. ] [ 0. 0.75 1.5 ]] [[ 1. 2. 3.] [ 4. 5. 6.]] Cholesky 分解 Cholesky 分解是一种特殊的 LU 分解，此时要求 $\\mathbf A$ 为 Hermitian 正定矩阵 （$\\mathbf A = \\mathbf{A^H}$）。 此时有： 即 可以用 linalg.cholesky 求解。 QR 分解 $M×N$ 矩阵 $\\mathbf A$ 的 QR 分解为： $\\mathbf R$ 为上三角形矩阵，$\\mathbf Q$ 是正交矩阵。 维基链接： https://en.wikipedia.org/wiki/QR_decomposition 可以用 linalg.qr 求解。 Schur 分解 对于 $N\\times N$ 方阵 $\\mathbf A$, Schur 分解要求找到满足下式的矩阵： 其中 $\\mathbf Z$ 是正交矩阵，$\\mathbf T$ 是一个上三角矩阵。 维基链接： https://en.wikipedia.org/wiki/Schur_decomposition A = np.mat('[1 3 2; 1 4 5; 2 3 6]') print A T, Z = linalg.schur(A) print T, Z print Z.dot(T).dot(Z.T) [[1 3 2] [1 4 5] [2 3 6]] [[ 9.90012467 1.78947961 -0.65498528] [ 0. 0.54993766 -1.57754789] [ 0. 0.51260928 0.54993766]] [[ 0.36702395 -0.85002495 -0.37782404] [ 0.63681656 -0.06646488 0.76814522] [ 0.67805463 0.52253231 -0.51691576]] [[ 1. 3. 2.] [ 1. 4. 5.] [ 2. 3. 6.]] 矩阵函数 考虑函数 $f(x)$ 的泰勒展开： 对于方阵，矩阵函数可以定义如下： 这也是计算矩阵函数的最好的方式。 指数和对数函数 指数 指数可以定义如下： linalg.expm3 使用的是泰勒展开的方法计算结果： A = np.array([[1, 2], [3, 4]]) print linalg.expm3(A)...",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/09.html",
        "teaser":null},{
        "title": "07-10 系数矩阵的线性代数",
        
        "excerpt":
            "稀疏矩阵的线性代数   对于稀疏矩阵来说，其线性代数操作可以使用 scipy.sparse.linalg 实现：           import scipy.sparse.linalg            矩阵操作      scipy.sparse.linalg.inv            稀疏矩阵求逆           scipy.sparse.linalg.expm            求稀疏矩阵的指数函数           矩阵范数      scipy.sparse.linalg.norm            稀疏矩阵求范数           线性方程组求解   提供了一系列求解方法： http://docs.scipy.org/doc/scipy/reference/sparse.linalg.html#solving-linear-problems   主要使用的是迭代方法求解。   特征值分解和奇异值分解   对于特别大的矩阵，原来的方法可能需要太大的内存，考虑使用这两个方法替代：      scipy.sparse.linalg.eigs            返回前 k 大的特征值和特征向量           scipy.sparse.linalg.svds            返回前 k 大的奇异值和奇异向量           所有的这些操作既可以在稀疏矩阵上使用，也可以在普通矩阵上使用。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/10.html",
        "teaser":null},{
        "title": "第7章 Scipy",
        
        "excerpt":
            "第7章 Scipy   07-1-Scientific Python 简介   07-2-插值   07-3-统计概率方法   07-4-曲线拟合   07-5-最小化函数   07-6-积分   07-7-解微分方程   07-8-稀疏矩阵   07-9-线性代数   07-10-系数矩阵的线性代数  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/07/features.html",
        "teaser":null},{
        "title": "08-01 pprint 模块",
        
        "excerpt":
            "pprint 模块：打印 Python 对象   pprint 是 pretty printer 的缩写，用来打印 Python 数据结构，与 print 相比，它打印出来的结构更加整齐，便于阅读。           import pprint            生成一个 Python 对象：           data = (     \"this is a string\",      [1, 2, 3, 4],      (\"more tuples\", 1.0, 2.3, 4.5),      \"this is yet another string\"     )            使用普通的 print 函数：           print data                        ('this is a string', [1, 2, 3, 4], ('more tuples', 1.0, 2.3, 4.5), 'this is yet another string')                  使用 pprint 模块中的 pprint 函数：           pprint.pprint(data)                        ('this is a string',  [1, 2, 3, 4],  ('more tuples', 1.0, 2.3, 4.5),  'this is yet another string')                  可以看到，这样打印出来的公式更加美观。  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/01.html",
        "teaser":null},{
        "title": "08-02 pickle 和 cPickle 模块",
        
        "excerpt":
            "pickle, cPickle 模块：序列化 Python 对象   pickle 模块实现了一种算法，可以将任意一个 Python 对象转化为一系列的字节，也可以将这些字节重构为一个有相同特征的新对象。   由于字节可以被传输或者存储，因此 pickle 事实上实现了传递或者保存 Python 对象的功能。   cPickle 使用 C 而不是 Python 实现了相同的算法，因此速度上要比 pickle 快一些。但是它不允许用户从 pickle 派生子类。如果子类对你的使用来说无关紧要，那么 cPickle 是个更好的选择。           try:     import cPickle as pickle except:     import pickle            编码和解码   使用 pickle.dumps() 可以将一个对象转换为字符串（dump string）：           data = [ { 'a':'A', 'b':2, 'c':3.0 } ]  data_string = pickle.dumps(data)  print \"DATA:\" print data print \"PICKLE:\" print data_string                        DATA: [{'a': 'A', 'c': 3.0, 'b': 2}] PICKLE: (lp1 (dp2 S'a' S'A' sS'c' F3 sS'b' I2 sa.                  虽然 pickle 编码的字符串并不一定可读，但是我们可以用 pickle.loads() 来从这个字符串中恢复原对象中的内容（load string）：           data_from_string = pickle.loads(data_string)  print data_from_string                        [{'a': 'A', 'c': 3.0, 'b': 2}]                  编码协议   dumps 可以接受一个可省略的 protocol 参数（默认为 0），目前有 3 种编码方式：      0：原始的 ASCII 编码格式   1：二进制编码格式   2：更有效的二进制编码格式   当前最高级的编码可以通过 HIGHEST_PROTOCOL 查看：           print pickle.HIGHEST_PROTOCOL                        2                  例如：           data_string_1 = pickle.dumps(data, 1)  print \"Pickle 1:\", data_string_1  data_string_2 = pickle.dumps(data, 2)  print \"Pickle 2:\", data_string_2                        Pickle 1: ]q\u0001}q\u0002(U\u0001aU\u0001AU\u0001cG\u0000\u0000\u0000\u0000\u0000\u0000U\u0001bK\u0002ua. Pickle 2: �\u0002]q\u0001}q\u0002(U\u0001aU\u0001AU\u0001cG\u0000\u0000\u0000\u0000\u0000\u0000U\u0001bK\u0002ua.                  如果 protocol 参数指定为负数，那么将调用当前的最高级的编码协议进行编码：           print pickle.dumps(data, -1)                        �\u0002]q\u0001}q\u0002(U\u0001aU\u0001AU\u0001cG\u0000\u0000\u0000\u0000\u0000\u0000U\u0001bK\u0002ua.                  从这些格式中恢复对象时，不需要指定所用的协议，pickle.load() 会自动识别：           print \"Load 1:\", pickle.loads(data_string_1) print \"Load 2:\", pickle.loads(data_string_2)                        Load 1: [{'a': 'A', 'c': 3.0, 'b': 2}] Load 2: [{'a': 'A', 'c': 3.0, 'b': 2}]                  存储和读取 pickle 文件   除了将对象转换为字符串这种方式，pickle 还支持将对象写入一个文件中，通常我们将这个文件命名为 xxx.pkl，以表示它是一个 pickle 文件：   存储和读取的函数分别为：      pickle.dump(obj, file, protocol=0) 将对象序列化并存入 file 文件中   pickle.load(file) 从 file 文件中的内容恢复对象   将对象存入文件：           with open(\"data.pkl\", \"wb\") as f:     pickle.dump(data, f)            从文件中读取：           with open(\"data.pkl\") as f:     data_from_file = pickle.load(f)      print data_from_file                        [{'a': 'A', 'c': 3.0, 'b': 2}]                  清理生成的文件：           import os os.remove(\"data.pkl\")           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/02.html",
        "teaser":null},{
        "title": "08-03 json 模块",
        
        "excerpt":
            "json 模块：处理 JSON 数据   JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。   JSON 基础   JSON 的基础结构有两种：键值对 (name/value pairs) 和数组 (array)。   JSON 具有以下形式：      object - 对象，用花括号表示，形式为（数据是无序的）：            { pair_1, pair_2, ..., pair_n }           pair - 键值对，形式为：            string : value           array - 数组，用中括号表示，形式为（数据是有序的）：            [value_1, value_2, ..., value_n ]           value - 值，可以是            string 字符串       number 数字       object 对象       array 数组       true / false / null 特殊值           string 字符串   例子：   {     \"name\": \"echo\",     \"age\": 24,     \"coding skills\": [\"python\", \"matlab\", \"java\", \"c\", \"c++\", \"ruby\", \"scala\"],     \"ages for school\": {          \"primary school\": 6,         \"middle school\": 9,         \"high school\": 15,         \"university\": 18     },     \"hobby\": [\"sports\", \"reading\"],     \"married\": false }   JSON 与 Python 的转换   假设我们已经将上面这个 JSON 对象写入了一个字符串：           import json from pprint import pprint  info_string = \"\"\" {     \"name\": \"echo\",     \"age\": 24,     \"coding skills\": [\"python\", \"matlab\", \"java\", \"c\", \"c++\", \"ruby\", \"scala\"],     \"ages for school\": {          \"primary school\": 6,         \"middle school\": 9,         \"high school\": 15,         \"university\": 18     },     \"hobby\": [\"sports\", \"reading\"],     \"married\": false } \"\"\"            我们可以用 json.loads() (load string) 方法从字符串中读取 JSON 数据：           info = json.loads(info_string)  pprint(info)                        {u'age': 24,  u'ages for school': {u'high school': 15,                       u'middle school': 9,                       u'primary school': 6,                       u'university': 18},  u'coding skills': [u'python',                     u'matlab',                     u'java',                     u'c',                     u'c++',                     u'ruby',                     u'scala'],  u'hobby': [u'sports', u'reading'],  u'married': False,  u'name': u'echo'}                  此时，我们将原来的 JSON 数据变成了一个 Python 对象，在我们的例子中这个对象是个字典（也可能是别的类型，比如列表）：           type(info)                         dict                   可以使用 json.dumps() 将一个 Python 对象变成 JSON 对象：           info_json = json.dumps(info)  print info_json                        {\"name\": \"echo\", \"age\": 24, \"married\": false, \"ages for school\": {\"middle school\": 9, \"university\": 18, \"high school\": 15, \"primary school\": 6}, \"coding skills\": [\"python\", \"matlab\", \"java\", \"c\", \"c++\", \"ruby\", \"scala\"], \"hobby\": [\"sports\", \"reading\"]}                  从中我们可以看到，生成的 JSON 字符串中，数组的元素顺序是不变的（始终是 [\"python\", \"matlab\", \"java\", \"c\", \"c++\", \"ruby\", \"scala\"]），而对象的元素顺序是不确定的。   生成和读取 JSON 文件   与 pickle 类似，我们可以直接从文件中读取 JSON 数据，也可以将对象保存为 JSON 格式。      json.dump(obj, file) 将对象保存为 JSON 格式的文件   json.load(file) 从 JSON 文件中读取数据           with open(\"info.json\", \"w\") as f:     json.dump(info, f)            可以查看 info.json 的内容：           with open(\"info.json\") as f:     print f.read()                        {\"name\": \"echo\", \"age\": 24, \"married\": false, \"ages for school\": {\"middle school\": 9, \"university\": 18, \"high school\": 15, \"primary school\": 6}, \"coding skills\": [\"python\", \"matlab\", \"java\", \"c\", \"c++\", \"ruby\", \"scala\"], \"hobby\": [\"sports\", \"reading\"]}                  从文件中读取数据：           with open(\"info.json\") as f:     info_from_file = json.load(f)      pprint(info_from_file)                        {u'age': 24,  u'ages for school': {u'high school': 15,                       u'middle school': 9,                       u'primary school': 6,                       u'university': 18},  u'coding skills': [u'python',                     u'matlab',                     u'java',                     u'c',                     u'c++',                     u'ruby',                     u'scala'],  u'hobby': [u'sports', u'reading'],  u'married': False,  u'name': u'echo'}                  删除生成的文件：           import os os.remove(\"info.json\")           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/03.html",
        "teaser":null},{
        "title": "08-04 glob 模块",
        
        "excerpt":
            "glob 模块：文件模式匹配           import glob            glob 模块提供了方便的文件模式匹配方法。   例如，找到所有以 .ipynb 结尾的文件名：           glob.glob(\"*.ipynb\")                         ['11.03 json.ipynb',  '11.01 pprint.ipynb',  '11.02 pickle and cpickle.ipynb',  '11.04 glob.ipynb']                   glob 函数支持三种格式的语法：      * 匹配单个或多个字符   ? 匹配任意单个字符   [] 匹配指定范围内的字符，如：[0-9]匹配数字。   假设我们要匹配第 09 节所有的 .ipynb 文件：           glob.glob(\"../09*/*.ipynb\")                         ['../09. theano/09.05 configuration settings and compiling modes.ipynb',  '../09. theano/09.03 gpu on windows.ipynb',  '../09. theano/09.07 loop with scan.ipynb',  '../09. theano/09.13 modern net on mnist.ipynb',  '../09. theano/09.11 net on mnist.ipynb',  '../09. theano/09.09 logistic regression .ipynb',  '../09. theano/09.10 softmax on mnist.ipynb',  '../09. theano/09.01 introduction and installation.ipynb',  '../09. theano/09.02 theano basics.ipynb',  '../09. theano/09.12 random streams.ipynb',  '../09. theano/09.04 graph structures.ipynb',  '../09. theano/09.14 convolutional net on mnist.ipynb',  '../09. theano/09.08 linear regression.ipynb',  '../09. theano/09.15 tensor module.ipynb',  '../09. theano/09.06 conditions in theano.ipynb']                   匹配数字开头的文件夹名：           glob.glob(\"../[0-9]*\")                         ['../04. scipy',  '../02. python essentials',  '../07. interfacing with other languages',  '../11. useful tools',  '../05. advanced python',  '../10. something interesting',  '../03. numpy',  '../06. matplotlib',  '../08. object-oriented programming',  '../01. python tools',  '../09. theano']                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/04.html",
        "teaser":null},{
        "title": "08-05 shutil 模块",
        
        "excerpt":
            "shutil 模块：高级文件操作           import shutil import os            shutil 是 Python 中的高级文件操作模块。   复制文件           with open(\"test.file\", \"w\") as f:     pass  print \"test.file\" in os.listdir(os.curdir)                        True                  shutil.copy(src, dst) 将源文件复制到目标地址：           shutil.copy(\"test.file\", \"test.copy.file\")  print \"test.file\" in os.listdir(os.curdir) print \"test.copy.file\" in os.listdir(os.curdir)                        True True                  如果目标地址中间的文件夹不存在则会报错：           try:     shutil.copy(\"test.file\", \"my_test_dir/test.copy.file\") except IOError as msg:     print msg                        [Errno 2] No such file or directory: 'my_test_dir/test.copy.file'                  另外的一个函数 shutil.copyfile(src, dst) 与 shutil.copy 使用方法一致，不过只是简单复制文件的内容，并不会复制文件本身的读写可执行权限，而 shutil.copy 则是完全复制。   复制文件夹   将文件转移到 test_dir 文件夹：           os.renames(\"test.file\", \"test_dir/test.file\") os.renames(\"test.copy.file\", \"test_dir/test.copy.file\")            使用 shutil.copytree 来复制文件夹：           shutil.copytree(\"test_dir/\", \"test_dir_copy/\")  \"test_dir_copy\" in os.listdir(os.curdir)                         True                   删除非空文件夹   os.removedirs 不能删除非空文件夹：           try:     os.removedirs(\"test_dir_copy\") except Exception as msg:     print msg                        [Errno 39] Directory not empty: 'test_dir_copy'                  使用 shutil.rmtree 来删除非空文件夹：           shutil.rmtree(\"test_dir_copy\")            移动文件夹   shutil.move 可以整体移动文件夹，与 os.rename 功能差不多。   产生压缩文件   查看支持的压缩文件格式：           shutil.get_archive_formats()                         [('bztar', \"bzip2'ed tar-file\"),  ('gztar', \"gzip'ed tar-file\"),  ('tar', 'uncompressed tar file'),  ('zip', 'ZIP file')]                   产生压缩文件：   shutil.make_archive(basename, format, root_dir)           shutil.make_archive(\"test_archive\", \"zip\", \"test_dir/\")                         '/home/lijin/notes-python/11. useful tools/test_archive.zip'                   清理生成的文件和文件夹：           os.remove(\"test_archive.zip\") shutil.rmtree(\"test_dir/\")           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/05.html",
        "teaser":null},{
        "title": "08-06 gzip, zipfile, tarfile 模块",
        
        "excerpt":
            "gzip, zipfile, tarfile 模块：处理压缩文件           import os, shutil, glob import zlib, gzip, bz2, zipfile, tarfile            gzip   zilb 模块   zlib 提供了对字符串进行压缩和解压缩的功能：           orginal = \"this is a test string\"  compressed = zlib.compress(orginal)  print compressed print zlib.decompress(compressed)                        x�+��,V\u0000�D����\u0012�⒢̼t\u0000S�\u0007� this is a test string                  同时提供了两种校验和的计算方法：           print zlib.adler32(orginal) &amp; 0xffffffff                        1407780813                          print zlib.crc32(orginal) &amp; 0xffffffff                        4236695221                  gzip 模块   gzip 模块可以产生 .gz 格式的文件，其压缩方式由 zlib 模块提供。   我们可以通过 gzip.open 方法来读写 .gz 格式的文件：           content = \"Lots of content here\" with gzip.open('file.txt.gz', 'wb') as f:     f.write(content)            读：           with gzip.open('file.txt.gz', 'rb') as f:     file_content = f.read()  print file_content                        Lots of content here                  将压缩文件内容解压出来：           with gzip.open('file.txt.gz', 'rb') as f_in, open('file.txt', 'wb') as f_out:     shutil.copyfileobj(f_in, f_out)            此时，目录下应有 file.txt 文件，内容为：           with open(\"file.txt\") as f:     print f.read()                        Lots of content here                          os.remove(\"file.txt.gz\")            bz2 模块   bz2 模块提供了另一种压缩文件的方法：           orginal = \"this is a test string\"  compressed = bz2.compress(orginal)  print compressed print bz2.decompress(compressed)                        BZh91AY&amp;SY*\u001c�v\u0000\u0000\t��@\u0000\"�\u001c\u0000 \u00001\u00000\"zi\u000f�\u0015\u001b�FLT`�軒)�P�˰ this is a test string                  zipfile 模块   产生一些 file.txt 的复制：           for i in range(10):     shutil.copy(\"file.txt\", \"file.txt.\" + str(i))            将这些复制全部压缩到一个 .zip 文件中：           f = zipfile.ZipFile('files.zip','w')  for name in glob.glob(\"*.txt.[0-9]\"):     f.write(name)     os.remove(name)      f.close()            解压这个 .zip 文件，用 namelist 方法查看压缩文件中的子文件名：           f = zipfile.ZipFile('files.zip','r') print f.namelist()                        ['file.txt.9', 'file.txt.6', 'file.txt.2', 'file.txt.1', 'file.txt.5', 'file.txt.4', 'file.txt.3', 'file.txt.7', 'file.txt.8', 'file.txt.0']                  使用 f.read(name) 方法来读取 name 文件中的内容：           for name in f.namelist():     print name, \"content:\", f.read(name)  f.close()                        file.txt.9 content: Lots of content here file.txt.6 content: Lots of content here file.txt.2 content: Lots of content here file.txt.1 content: Lots of content here file.txt.5 content: Lots of content here file.txt.4 content: Lots of content here file.txt.3 content: Lots of content here file.txt.7 content: Lots of content here file.txt.8 content: Lots of content here file.txt.0 content: Lots of content here                  可以用 extract(name) 或者 extractall() 解压单个或者全部文件。   tarfile 模块   支持 .tar 格式文件的读写：   例如可以这样将 file.txt 写入：           f = tarfile.open(\"file.txt.tar\", \"w\") f.add(\"file.txt\") f.close()            清理生成的文件：           os.remove(\"file.txt\") os.remove(\"file.txt.tar\") os.remove(\"files.zip\")           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/06.html",
        "teaser":null},{
        "title": "08-07 logging 模块",
        
        "excerpt":
            "logging 模块：记录日志   logging 模块可以用来记录日志：           import logging            logging 的日志类型有以下几种：      logging.critical(msg)   logging.error(msg)   logging.warning(msg)   logging.info(msg)   logging.debug(msg)   级别排序为：CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET   默认情况下，logging 的日志级别为 WARNING，只有不低于 WARNING 级别的日志才会显示在命令行。           logging.critical('This is critical message') logging.error('This is error message') logging.warning('This is warning message')  # 不会显示 logging.info('This is info message') logging.debug('This is debug message')            可以这样修改默认的日志级别：           logging.root.setLevel(level=logging.INFO)  logging.info('This is info message')            可以通过 logging.basicConfig() 函数来改变默认的日志显示方式：           logging.basicConfig(format='%(asctime)s: %(levelname)s: %(message)s')  logger = logging.getLogger(\"this program\")  logger.critical('This is critical message')           ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/07.html",
        "teaser":null},{
        "title": "08-08 string 模块",
        
        "excerpt":
            "string 模块：字符串处理           import string            标点符号：           string.punctuation                         '!\"#$%&amp;\\'()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~'                   字母表：           print string.letters print string.ascii_letters                        ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ                  小写和大写：           print string.ascii_lowercase print string.lowercase  print string.ascii_uppercase print string.uppercase                        abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ                          print string.lower                        &lt;function lower at 0x7efda4f2ae60&gt;                  数字：           string.digits                         '0123456789'                   16 进制数字：           string.hexdigits                         '0123456789abcdefABCDEF'                   每个单词的首字符大写：           string.capwords(\"this is a big world\")                         'This Is A Big World'                   将指定的单词放到中央：           string.center(\"test\", 20)                         '        test        '                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/08.html",
        "teaser":null},{
        "title": "08-09 collections 模块",
        
        "excerpt":
            "collections 模块：更多数据结构           import collections            计数器   可以使用 Counter(seq) 对序列中出现的元素个数进行统计。   例如，我们可以统计一段文本中出现的单词及其出现的次数：           from string import punctuation  sentence = \"One, two, three, one, two, tree, I come from China.\"  words_count = collections.Counter(sentence.translate(None, punctuation).lower().split())  print words_count                        Counter({'two': 2, 'one': 2, 'from': 1, 'i': 1, 'tree': 1, 'three': 1, 'china': 1, 'come': 1})                  双端队列   双端队列支持从队头队尾出入队：           dq = collections.deque()  for i in xrange(10):     dq.append(i)      print dq  for i in xrange(10):     print dq.pop(),   print   for i in xrange(10):     dq.appendleft(i)      print dq  for i in xrange(10):     print dq.popleft(),                        deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 9 8 7 6 5 4 3 2 1 0 deque([9, 8, 7, 6, 5, 4, 3, 2, 1, 0]) 9 8 7 6 5 4 3 2 1 0                  与列表相比，双端队列在队头的操作更快：           lst = [] dq = collections.deque()  %timeit -n100 lst.insert(0, 10) %timeit -n100 dq.appendleft(10)                        100 loops, best of 3: 598 ns per loop 100 loops, best of 3: 291 ns per loop                  有序字典   字典的 key 按顺序排列：           items = (     ('A', 1),     ('B', 2),     ('C', 3) )  regular_dict = dict(items) ordered_dict = collections.OrderedDict(items)  print 'Regular Dict:' for k, v in regular_dict.items():     print k, v  print 'Ordered Dict:' for k, v in ordered_dict.items():     print k, v                        Regular Dict: A 1 C 3 B 2 Ordered Dict: A 1 B 2 C 3                  带默认值的字典   对于 Python 自带的词典 d，当 key 不存在的时候，调用 d[key] 会报错，但是 defaultdict 可以为这样的 key 提供一个指定的默认值，我们只需要在定义时提供默认值的类型即可，如果 key 不存在返回指定类型的默认值：           dd = collections.defaultdict(list)  print dd[\"foo\"]  dd = collections.defaultdict(int)  print dd[\"foo\"]  dd = collections.defaultdict(float)  print dd[\"foo\"]                        [] 0 0.0                 ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/09.html",
        "teaser":null},{
        "title": "08-10 requests 模块",
        
        "excerpt":
            "requests 模块：HTTP for Human           import requests            Python 标准库中的 urllib2 模块提供了你所需要的大多数 HTTP 功能，但是它的 API 不是特别方便使用。   requests 模块号称 HTTP for Human，它可以这样使用：           r = requests.get(\"http://httpbin.org/get\") r = requests.post('http://httpbin.org/post', data = {'key':'value'}) r = requests.put(\"http://httpbin.org/put\") r = requests.delete(\"http://httpbin.org/delete\") r = requests.head(\"http://httpbin.org/get\") r = requests.options(\"http://httpbin.org/get\")            传入 URL 参数   假如我们想访问 httpbin.org/get?key=val，我们可以使用 params 传入这些参数：           payload = {'key1': 'value1', 'key2': 'value2'} r = requests.get(\"http://httpbin.org/get\", params=payload)            查看 url ：           print(r.url)                        http://httpbin.org/get?key2=value2&amp;key1=value1                  读取响应内容   Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。           r = requests.get('https://github.com/timeline.json')  print r.text                        {\"message\":\"Hello there, wayfaring stranger. If you’re reading this then you probably didn’t see our blog post a couple of years back announcing that this API would go away: http://git.io/17AROg Fear not, you should be able to get what you need from the shiny new Events API instead.\",\"documentation_url\":\"https://developer.github.com/v3/activity/events/#list-public-events\"}                  查看文字编码：           r.encoding                         'utf-8'                   每次改变文字编码，text 的内容也随之变化：           r.encoding = \"ISO-8859-1\"  r.text                         u'{\"message\":\"Hello there, wayfaring stranger. If you\\xe2\\x80\\x99re reading this then you probably didn\\xe2\\x80\\x99t see our blog post a couple of years back announcing that this API would go away: http://git.io/17AROg Fear not, you should be able to get what you need from the shiny new Events API instead.\",\"documentation_url\":\"https://developer.github.com/v3/activity/events/#list-public-events\"}'                   Requests 中也有一个内置的 JSON 解码器处理 JSON 数据：           r.json()                         {u'documentation_url': u'https://developer.github.com/v3/activity/events/#list-public-events',  u'message': u'Hello there, wayfaring stranger. If you\\xe2\\x80\\x99re reading this then you probably didn\\xe2\\x80\\x99t see our blog post a couple of years back announcing that this API would go away: http://git.io/17AROg Fear not, you should be able to get what you need from the shiny new Events API instead.'}                   如果 JSON 解码失败， r.json 就会抛出一个异常。   响应状态码           r = requests.get('http://httpbin.org/get')  r.status_code                         407                   响应头           r.headers['Content-Type']                         'text/html'                  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/10.html",
        "teaser":null},{
        "title": "第8章 Python 有用的库",
        
        "excerpt":
            "第8章 Python 有用的库   08-1-pprint 模块   08-2-pickle 和 cPickle 模块   08-3-json 模块   08-4-glob 模块   08-5-shutil 模块   08-6-gzip, zipfile, tarfile 模块   08-7-logging 模块   08-8-string 模块   08-9-collections 模块   08-10-requests 模块  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/08/features.html",
        "teaser":null},{
        "title": "第1章 Python 介绍",
        
        "excerpt":
            "第1章 Python 介绍   01-1-Python 简介   第2章 Python 基础   02-1-Python 入门演示   02-2-Python 数据类型   02-3-Python 数字   02-4-Python 字符串   02-5-索引和切片   02-6-列表   02-7-可变和不可变类型   02-8-元组   02-9-列表与元组的速度比较   02-10-字典   02-11-集合   02-12-不可变集合   02-13-Python 赋值机制   02-14-判断语句   02-15-循环   02-16-列表推导式   02-17-函数   02-18-模块和包   02-19-异常   02-20-警告   02-21-文件读写   第3章 Python 进阶   03-1-sys 模块简介   03-2-与操作系统进行交互：os 模块   03-3-CSV 文件和 csv 模块   03-4-正则表达式和 re 模块   03-5-datetime 模块   03-6-SQL 数据库   03-7-对象关系映射   03-8-函数进阶   03-9-迭代器   03-10-生成器   03-11-with 语句和上下文管理器   03-12-装饰器   03-13-装饰器的使用   03-14-Python 常用模块   03-15-作用域   03-16-动态编译   第4章 Numpy   04-1-Numpy 简介   04-2-Matplotlib基础   04-3-Numpy 数组及其索引   04-4-数组类型   04-5-数组方法   04-6-数组排序   04-7-数组形状   04-8-对角线   04-9-数组与字符串的转换   04-10-数组属性方法总结   04-11-生成数组的函数   04-12-矩阵   04-13-一般函数   04-14-向量化函数   04-15-二元运算   04-16-ufunc 对象   04-17-choose 函数   04-18-数组广播机制   04-19-数组读写   04-20-结构化数组   04-21-记录数组   04-22-内存映射   04-23-从 Matlab 到 Numpy   第5章 Pandas   05-1-十分钟上手 Pandas   05-2-Series   05-3-Dataframe   第6章 Matplotlib   06-1-Pyplot 教程   06-2-使用 style 来配置 pyplot 风格   06-3-处理文本（基础）   06-4-处理文本（数学表达式）   06-5-图像基础   06-6-注释   06-7-标签   06-8-figures, subplots, axes 和 ticks 对象   06-9-不要迷信默认设置   06-10-各种绘图实例   第7章 Scipy   07-1-Scientific Python 简介   07-2-插值   07-3-统计概率方法   07-4-曲线拟合   07-5-最小化函数   07-6-积分   07-7-解微分方程   07-8-稀疏矩阵   07-9-线性代数   07-10-系数矩阵的线性代数   第8章 Python 有用的库   08-1-pprint 模块   08-2-pickle 和 cPickle 模块   08-3-json 模块   08-4-glob 模块   08-5-shutil 模块   08-6-gzip, zipfile, tarfile 模块   08-7-logging 模块   08-8-string 模块   08-9-collections 模块   08-10-requests 模块  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/features.html",
        "teaser":null},{
        "title": "第3章 Python 进阶",
        
        "excerpt":
            "Features   This is a short demonstration textbook to show the general layout / style of textbooks built with Jupyter and Jekyll. The markdown files for this page (and others in the textbook) is generated from the notebooks with the scripts/generate_textbook.py script, which is called when you run make book.   The content for the book is contained in a folder in the site’s repository called content/. It has a combination of markdown and Jupyter notebooks. This content is rendered into the textbook that you see here!   To begin, click on one of the chapter sections in the sidebar to the left. The first section demonstrates some simple functionality of this repository, while the following chapters contain a subset of content from the Foundations in Data Science.   Quickstart   This chapter shows a couple ways to add content to your course textbook. Click on the section headers to the left, or on the “next” button below in order to read further.  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/features/features.html",
        "teaser":null},{
        "title": "目录",
        
        "excerpt":
            "目录   第1章 Python 介绍   01-1-Python 简介   第2章 Python 基础   02-1-Python 入门演示   02-2-Python 数据类型   02-3-Python 数字   02-4-Python 字符串   02-5-索引和切片   02-6-列表   02-7-可变和不可变类型   02-8-元组   02-9-列表与元组的速度比较   02-10-字典   02-11-集合   02-12-不可变集合   02-13-Python 赋值机制   02-14-判断语句   02-15-循环   02-16-列表推导式   02-17-函数   02-18-模块和包   02-19-异常   02-20-警告   02-21-文件读写   第3章 Python 进阶   03-1-sys 模块简介   03-2-与操作系统进行交互：os 模块   03-3-CSV 文件和 csv 模块   03-4-正则表达式和 re 模块   03-5-datetime 模块   03-6-SQL 数据库   03-7-对象关系映射   03-8-函数进阶   03-9-迭代器   03-10-生成器   03-11-with 语句和上下文管理器   03-12-装饰器   03-13-装饰器的使用   03-14-Python 常用模块   03-15-作用域   03-16-动态编译   第4章 Numpy   04-1-Numpy 简介   04-2-Matplotlib基础   04-3-Numpy 数组及其索引   04-4-数组类型   04-5-数组方法   04-6-数组排序   04-7-数组形状   04-8-对角线   04-9-数组与字符串的转换   04-10-数组属性方法总结   04-11-生成数组的函数   04-12-矩阵   04-13-一般函数   04-14-向量化函数   04-15-二元运算   04-16-ufunc 对象   04-17-choose 函数   04-18-数组广播机制   04-19-数组读写   04-20-结构化数组   04-21-记录数组   04-22-内存映射   04-23-从 Matlab 到 Numpy   第5章 Pandas   05-1-十分钟上手 Pandas   05-2-Series   05-3-Dataframe   第6章 Matplotlib   06-1-Pyplot 教程   06-2-使用 style 来配置 pyplot 风格   06-3-处理文本（基础）   06-4-处理文本（数学表达式）   06-5-图像基础   06-6-注释   06-7-标签   06-8-figures, subplots, axes 和 ticks 对象   06-9-不要迷信默认设置   06-10-各种绘图实例   第7章 Scipy   07-1-Scientific Python 简介   07-2-插值   07-3-统计概率方法   07-4-曲线拟合   07-5-最小化函数   07-6-积分   07-7-解微分方程   07-8-稀疏矩阵   07-9-线性代数   07-10-系数矩阵的线性代数   第8章 Python 有用的库   08-1-pprint 模块   08-2-pickle 和 cPickle 模块   08-3-json 模块   08-4-glob 模块   08-5-shutil 模块   08-6-gzip, zipfile, tarfile 模块   08-7-logging 模块   08-8-string 模块   08-9-collections 模块   08-10-requests 模块  ",
        "categories": [],
        "tags": [],
        "url": "http://0.0.0.0:4000/intro.html",
        "teaser":null},]
</script>
              <nav class="c-page__nav">
  

  
</nav>

            </div>
          </div>
        </div>
      </main>
    </div>

  </body>
</html>
